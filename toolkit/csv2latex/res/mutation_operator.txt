   & 7\\
  \hline
  testing-based process for component substitutability & 2\\
  \hline
  a case study in model-based testing of specifications and implementations & 1\\
  \hline
  a case study using the round-trip strategy for state-based class testing & 1\\
  \hline
  a controlled experiment assessing test case prioritization techniques via mutation faults & 1\\
  \hline
  a framework for practical & 1\\
  \hline
  a practical approach to testing gui systems & 1\\
  \hline
  a specification-based adaptive test case generation strategy for open operating system standards & 1\\
  \hline
  a state-based approach to integration testing based on uml models & 1\\
  \hline
  achieving scalable mutation-based generation of whole test suites & 1\\
  \hline
  adaptive random testing: an illusion of effectiveness? & 1\\
  \hline
  an analysis of the relationship between conditional entropy and failed error propagation in software testing & 1\\
  \hline
  an approach and tool for measurement of state variable based data-flow test coverage for aspect-oriented programs & 1\\
  \hline
  an approach for testing pointcut descriptors in aspectj & 1\\
  \hline
  an approach to test data generation for killing multiple mutants & 1\\
  \hline
  an automated approach to reducing test suites for testing retargeted c compilers for embedded systems & 1\\
  \hline
  an empirical analysis and comparison of random testing techniques & 1\\
  \hline
  an empirical evaluation of assertions as oracles & 1\\
  \hline
  an empirical evaluation of mutation testing for improving the test quality of safety-critical software & 1\\
  \hline
  an empirical evaluation of statistical testing designed from uml state diagrams: the flight guidance system case study & 1\\
  \hline
  an empirical study of junit test-suite reduction & 1\\
  \hline
  an empirical study of the effect of time constraints on the cost-benefits of regression testing & 1\\
  \hline
  an evaluation of required element testing strategies & 1\\
  \hline
  analysing the effectiveness of rule-coverage as a reduction criterion for test suites of grammar-based software & 1\\
  \hline
  applying interface-contract mutation in regression testing of component-based software & 1\\
  \hline
  are concurrency coverage metrics effective for testing: a comprehensive empirical investigation & 1\\
  \hline
  assertions are strongly correlated with test suite effectiveness & 1\\
  \hline
  assessing and generating test sets in terms of behavioural adequacy & 1\\
  \hline
  assessing and improving state-based class testing: a series of experiments & 1\\
  \hline
  automated black-box testing of component-based software & 1\\
  \hline
  automated oracle data selection support & 1\\
  \hline
  automated test case generation for fbd programs implementing reactor protection system software & 1\\
  \hline
  automated test data generation on the analyses of feature models: a metamorphic testing approach & 1\\
  \hline
  automatic mutation test case generation via dynamic symbolic execution & 1\\
  \hline
  automatic recovery from runtime failures & 1\\
  \hline
  automatic xacml requests generation for policy testing & 1\\
  \hline
  automatically generating test data from a boolean specification & 1\\
  \hline
  automatically performing weak mutation with the aid of symbolic execution & 1\\
  \hline
  balancing trade-offs in test-suite reduction & 1\\
  \hline
  behaviour abstraction adequacy criteria for api call protocol testing & 1\\
  \hline
  behaviour abstraction coverage as black-box adequacy criteria & 1\\
  \hline
  black-box testing using flowgraphs: an experimental assessment of effectiveness and automation potential & 1\\
  \hline
  building trust into oo components using a genetic analogy & 1\\
  \hline
  combining multiple coverage criteria in search-based unit test generation & 1\\
  \hline
  compatibility and regression testing of cots-component-based software & 1\\
  \hline
  concolic testing and search-based testing & 1\\
  \hline
  constraint based structural testing criteria & 1\\
  \hline
  correlating context-awareness and mutation analysis for pervasive computing systems & 1\\
  \hline
  cross-checking oracles from intrinsic software redundancy & 1\\
  \hline
  crowdoracles: can the crowd solve the oracle problem? & 1\\
  \hline
  design by contract to improve software vigilance & 1\\
  \hline
  effective test case selection for component customization and its application to enterprise javabeans & 1\\
  \hline
  empirically evaluating the quality of automatically generated and manually written test suites & 1\\
  \hline
  evaluating automated unit testing in sulu & 1\\
  \hline
  evaluating test suites and adequacy criteria using simulation-based models of distributed systems & 1\\
  \hline
  evaluating testing strategies for imaging software by means of mutation analysis & 1\\
  \hline
  exploiting model morphology for event-based testing & 1\\
  \hline
  from genetic to bacteriological algorithms for mutation-based testing & 1\\
  \hline
  full predicate coverage for testing sql database queries & 1\\
  \hline
  general test result checking with log file analysis & 1\\
  \hline
  generating complex and faulty test data through model-based mutation analysis & 1\\
  \hline
  generating test cases for xml-based web component interactions using mutation analysis & 1\\
  \hline
  generating test data from sofl specifications & 1\\
  \hline
  genes and bacteria for automatic test cases optimization in the. net environment & 1\\
  \hline
  how significant is the effect of fault interactions on coverage-based fault localizations? & 1\\
  \hline
  improving statechart testing criteria using data flow information & 1\\
  \hline
  integrating techniques and tools for testing automation & 1\\
  \hline
  jdama: java database application mutation analyser & 1\\
  \hline
  killing strategies for model-based mutation testing & 1\\
  \hline
  leveraging existing tests in automated test generation for web applications & 1\\
  \hline
  location pairs: a test coverage metric for shared-memory concurrent programs & 1\\
  \hline
  minimization of randomized unit test cases & 1\\
  \hline
  model clone detector evaluation using mutation analysis & 1\\
  \hline
  model-based testing of obligations & 1\\
  \hline
  model-based tests for access control policies & 1\\
  \hline
  multi-objective construction of an entire adequate test suite for an efsm & 1\\
  \hline
  mutation based test case generation via a path selection strategy & 1\\
  \hline
  mutation testing of" go-back" functions based on pushdown automata & 1\\
  \hline
  mutation-based test generation from security protocols in hlpsl & 1\\
  \hline
  mutation-based test-case prioritization in software evolution & 1\\
  \hline
  on guiding the augmentation of an automated test suite via mutation analysis & 1\\
  \hline
  on random testing of image processing applications & 1\\
  \hline
  on the round trip path testing strategy & 1\\
  \hline
  on the use of mutation faults in empirical assessments of test case prioritization techniques & 1\\
  \hline
  oracle-centric test case prioritization & 1\\
  \hline
  planner based error recovery testing & 1\\
  \hline
  prioritizing state-based aspect tests & 1\\
  \hline
  procedures for reducing the size of coverage-based test sets & 1\\
  \hline
  sampling program inputs with mutation analysis: going beyond combinatorial interaction testing & 1\\
  \hline
  search-based testing of relational schema integrity constraints across multiple database management systems & 1\\
  \hline
  should software testers use mutation analysis to augment a test set? & 1\\
  \hline
  sound and quasi-complete detection of infeasible test requirements & 1\\
  \hline
  state coverage: a structural test adequacy criterion for behavior checking & 1\\
  \hline
  state-based testing: industrial evaluation of the cost-effectiveness of round-trip path and sneak-path strategies & 1\\
  \hline
  static analysis of model transformations for effective test generation & 1\\
  \hline
  test case purification for improving fault localization & 1\\
  \hline
  test data regeneration: generating new test data from existing test data & 1\\
  \hline
  test generation via dynamic symbolic execution for mutation testing & 1\\
  \hline
  test input generation using uml sequence and state machines models & 1\\
  \hline
  test inspected unit or inspect unit tested code? & 1\\
  \hline
  testing and validating machine learning classifiers by metamorphic testing & 1\\
  \hline
  testing aspect-oriented programs with finite state machines & 1\\
  \hline
  testing real-time embedded systems using timed automata based approaches & 1\\
  \hline
  testing security policies: going beyond functional testing & 1\\
  \hline
  the effectiveness of test coverage criteria for relational database schema integrity constraints & 1\\
  \hline
  the impact of concurrent coverage metrics on testing effectiveness & 1\\
  \hline
  the influence of size and coverage on test suite effectiveness & 1\\
  \hline
  the right choice matters! smt solving substantially improves model-based debugging of spreadsheets & 1\\
  \hline
  time-aware test-case prioritization using integer linear programming & 1\\
  \hline
  unit and integration testing strategies for c programs using mutation & 1\\
  \hline
  using machine learning techniques to detect metamorphic relations for programs without test oracles & 1\\
  \hline
  using mutation analysis for assessing and comparing testing coverage criteria & 1\\
  \hline
  using mutation to assess fault detection capability of model review & 1\\
  \hline
  why does my spreadsheet compute wrong values? & 1\\
  \hline

  program & 95\\
  \hline
  arithmetic op & 79\\
  \hline
  relational op & 74\\
  \hline
  conditional op & 72\\
  \hline
  bitwise op & 43\\
  \hline
  assignment op & 39\\
  \hline
  shift op & 37\\
  \hline
  constant & 36\\
  \hline
  absolute value & 31\\
  \hline
  variable & 31\\
  \hline
  oo-specific & 26\\
  \hline
  specification & 23\\
  \hline
  statement deletion & 23\\
  \hline
  java-specific & 17\\
  \hline
  method call & 16\\
  \hline
  return statement & 16\\
  \hline
  conditional exp & 14\\
  \hline
  control-flow disruption & 9\\
  \hline
  interface mutation & 7\\
  \hline
  goto label & 6\\
  \hline
  bomb statement & 5\\
  \hline
  do statement & 5\\
  \hline
  sql-specific & 5\\
  \hline
  statement swap & 5\\
  \hline
  switch statement & 5\\
  \hline
  concurrent mutation & 4\\
  \hline
  exception handler & 4\\
  \hline
  aop-specific & 3\\
  \hline
  brace & 3\\
  \hline
  loop trap & 3\\
  \hline
  parentheses & 3\\
  \hline
  type & 3\\
  \hline
  while statement & 3\\
  \hline
  spreadsheet-specific & 2\\
  \hline
  js-specific & 1\\
  \hline

  java & 58\\
  \hline
  c & 14\\
  \hline
  n/a & 5\\
  \hline
  sql & 5\\
  \hline
  c++ & 4\\
  \hline
  aspect-oriented (aspectj) & 3\\
  \hline
  eiffel & 3\\
  \hline
  c\# & 2\\
  \hline
  fortran & 2\\
  \hline
  simulink & 2\\
  \hline
  specification (object constraint language) & 2\\
  \hline
  spreadsheet & 2\\
  \hline
  ada & 1\\
  \hline
  ansi-c & 1\\
  \hline
  aspect-oriented (kermeta) & 1\\
  \hline
  aspectj & 1\\
  \hline
  c\# (statement deletion) & 1\\
  \hline
  delphi & 1\\
  \hline
  enterprise javabeans application & 1\\
  \hline
  hlpsl & 1\\
  \hline
  iso c++ grammar & 1\\
  \hline
  javascript & 1\\
  \hline
  plc & 1\\
  \hline
  specification (ctl) & 1\\
  \hline
  specification (efsm) & 1\\
  \hline
  specification (orbac) & 1\\
  \hline
  specification (policy decision point) & 1\\
  \hline
  specification (pushdown automata) & 1\\
  \hline
  specification (resolve) & 1\\
  \hline
  specification (z notation) & 1\\
  \hline
  sulu & 1\\
  \hline
  uml & 1\\
  \hline
  xacml & 1\\
  \hline
  xml & 1\\
  \hline

   & 42\\
  \hline
  mujava & 19\\
  \hline
  self-written & 7\\
  \hline
  muclipse & 6\\
  \hline
  major & 4\\
  \hline
  evosuite & 3\\
  \hline
  pit & 3\\
  \hline
  proteum & 3\\
  \hline
  proteum/im & 3\\
  \hline
  $\mu$java & 2\\
  \hline
  $\mu$slayer & 2\\
  \hline
  ajmutator & 2\\
  \hline
  javalanche & 2\\
  \hline
  jfuzz & 2\\
  \hline
  manual & 2\\
  \hline
  mothra & 2\\
  \hline
  sqlmutation & 2\\
  \hline
  testooj & 2\\
  \hline
  $\mu$-java & 1\\
  \hline
  \cite{andrews2003general} & 1\\
  \hline
  \cite{budd1979mutation} & 1\\
  \hline
  \cite{martin2007fault} & 1\\
  \hline
  createmutants.py & 1\\
  \hline
  exman & 1\\
  \hline
  genmutants & 1\\
  \hline
  hand-seeded & 1\\
  \hline
  jdama (based on sqlmutation) & 1\\
  \hline
  jester & 1\\
  \hline
  jmuhlpsl & 1\\
  \hline
  jumble & 1\\
  \hline
  milu & 1\\
  \hline
  mutandis \cite{mirshokraie2013efficient} & 1\\
  \hline
  pexmutator & 1\\
  \hline
  proteum/aj & 1\\
  \hline
  schemaanalyst & 1\\
  \hline
  smt-c & 1\\
  \hline
  sofya & 1\\
  \hline
  sulu tool & 1\\
  \hline
  tecc & 1\\
  \hline

