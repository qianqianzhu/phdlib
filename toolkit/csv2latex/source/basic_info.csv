search_title,database,result_title,authors,citation,venue,abstract,keywords
Testing real-time embedded systems using timed automata based approaches,Elsevier,Testing real-time embedded systems using timed automata based approaches,"AbouTrab, M. Saeed, Michael Brockway, Steve Counsell, and Robert M. Hierons",20," <i>Journal of Systems and Software</i> 86, no. 5 (2013): 1209-1223.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id=""spar0010"">Real-Time Embedded Systems (RTESs) have an increasing role in controlling the IT that we use on a day-to-day basis. The behaviour of an RTES is not based solely on the interactions it might have with its surrounding environment, but also on the timing requirements it induces. As a result, ensuring that an RTES behaves correctly is non-trivial, especially after adding time as a new dimension to the complexity of the testing process. We previously introduced the ‘priority-based’ approach which tests the logical and timing behaviour of an RTES modelled formally as UPPAAL automata. The ‘priority-based’ approach was based on producing sets of timed test traces by achieving clock region coverage. In this paper, we empirically validate the ‘priority-based’ approach with comparison to well-known timed testing approaches based on a Timed Automata (TA) formalism using a complete test bed based on an industrial-strength case study (production cell). The validation assessment is based on both fault coverage and structural coverage by a minimal number of generated test traces; the former is achieved using the Mutation Analysis Technique (MAT) by introducing a set of timed and functional mutation operators. The latter is based on clock region coverage as a main timed structural coverage criterion. This study shows that ‘priority-based’ approach can combine a high fault coverage and clock region coverage with a relatively small number of test traces in comparison with other test approaches. A set of experiences and lessons learned are highlighted as result of the real-time test bed.</p>","<li id="""" class=""svKeywords""><span id="""">Test bed</span>; </li><li id="""" class=""svKeywords""><span id="""">Timed Automata</span>; </li><li id="""" class=""svKeywords""><span id="""">Timed model-based testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Real-Time Embedded Systems</span></li>"
Efficient Mutation Killers in Action,ieeexplore,Efficient mutation killers in action,"Aichernig, Bernhard K., Harald Brandl, Elisabeth Jöbstl, and Willibald Krenn",23," In <i>Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on</i>, pp. 120-129. IEEE, 2011.","This paper presents the techniques and results of a novel model-based test case generation approach that automatically derives test cases from UML state machines. Mutation testing is applied on the modeling level to generate test cases. We present the test case generation approach, discuss the tool chain, and present the properties of the generated test cases. The main contribution of this paper is an empirical study of a car alarm system where different strategies for killing mutants are compared. We present detailed figures on the effectiveness of the test case generation technique. Although UML serves as an input language, all techniques are grounded on solid foundations: we give UML state transition diagrams a formal semantics by mapping them to Back's action systems.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Unified Modeling Language.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Unified Modeling Language</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.ioco.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">ioco</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.action systems.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">action systems</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Killing strategies for model-based mutation testing,Wiley Online Library,Killing strategies for model‐based mutation testing,"Aichernig, Bernhard K., Harald Brandl, Elisabeth Jöbstl, Willibald Krenn, Rupert Schlick, and Stefan Tiran",32," <i>Software Testing, Verification and Reliability</i> 25, no. 8 (2015): 716-748.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">Summary</h2><p>This article presents the techniques and results of a novel model-based test case generation approach that automatically derives test cases from UML state machines. The main contribution of this article is the fully automated fault-based test case generation technique together with two empirical case studies derived from industrial use cases. Also, an in-depth evaluation of different fault-based test case generation strategies on each of the case studies is given and a comparison with plain random testing is conducted. The test case generation methodology supports a wide range of UML constructs and is grounded on the formal semantics of Back's action systems and the well-known input–output conformance relation. Mutation operators are employed on the level of the specification to insert faults and generate test cases that will reveal the faults inserted. The effectiveness of this approach is shown and it is discussed how to gain a more expressive test suite by combining cheap but undirected random test case generation with the more expensive but directed mutation-based technique. Finally, an extensive and critical discussion of the lessons learnt is given as well as a future outlook on the general usefulness and practicability of mutation-based test case generation. Copyright © 2014 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test case generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model-based testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">random testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">ioco; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">action systems; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Unified Modeling Language; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">UML</span></li>"
A state-based approach to integration testing based on UML models,Elsevier,A state-based approach to integration testing based on UML models,"Ali, Shaukat, Lionel C. Briand, Muhammad Jaffar-ur Rehman, Hajra Asghar, Muhammad Zohaib Z. Iqbal, and Aamer Nadeem",107," <i>Information and Software Technology</i> 49, no. 11 (2007): 1087-1106.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Correct functioning of object-oriented software depends upon the successful integration of classes. While individual classes may function correctly, several new faults can arise when these classes are integrated together. In this paper, we present a technique to enhance testing of interactions among modal classes. The technique combines UML collaboration diagrams and statecharts to automatically generate an intermediate test model, called SCOTEM (State COllaboration TEst Model). The SCOTEM is then used to generate valid test paths. We also define various coverage criteria to generate test paths from the SCOTEM model. In order to assess our technique, we have developed a tool and applied it to a case study to investigate its fault detection capability. The results show that the proposed technique effectively detects all the seeded integration faults when complying with the most demanding adequacy criterion and still achieves reasonably good results for less expensive adequacy criteria.</p>","<li id="""" class=""svKeywords""><span id="""">UML based testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Automated testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Object-oriented systems</span></li>"
General test result checking with log file analysis,ieeexplore,General test result checking with log file analysis,"Andrews, James H., and Yingjun Zhang",94," <i>IEEE Transactions on Software Engineering</i> 29, no. 7 (2003): 634-648.",We describe and apply a lightweight formal method for checking test results. The method assumes that the software under test writes a text log file; this log file is then analyzed by a program to see if it reveals failures. We suggest a state-machine-based formalism for specifying the log file analyzer programs and describe a language and implementation based on that formalism. We report on empirical studies of the application of log file analysis to random testing of units. We describe the results of experiments done to compare the performance and effectiveness of random unit testing with coverage checking and log file analysis to other unit testing procedures. The experiments suggest that writing a formal log file analyzer and using random testing is competitive with other formal and informal methods for unit testing.,
Using mutation analysis for assessing and comparing testing coverage criteria,ieeexplore,Using mutation analysis for assessing and comparing testing coverage criteria,"Andrews, James H., Lionel C. Briand, Yvan Labiche, and Akbar Siami Namin",330," <i>IEEE Transactions on Software Engineering</i> 32, no. 8 (2006): 608-624.","The empirical assessment of test techniques plays an important role in software testing research. One common practice is to seed faults in subject software, either manually or by using a program that generates all possible mutants based on a set of mutation operators. The latter allows the systematic, repeatable seeding of large numbers of faults, thus facilitating the statistical analysis of fault detection effectiveness of test suites; however, we do not know whether empirical results obtained this way lead to valid, representative conclusions. Focusing on four common control and data flow criteria (block, decision, C-use, and P-use), this paper investigates this important issue based on a middle size industrial program with a comprehensive pool of test cases and known faults. Based on the data available thus far, the results are very consistent across the investigated criteria as they show that the use of mutation operators is yielding trustworthy results: generated mutants can be used to predict the detection effectiveness of real faults. Applying such a mutation analysis, we then investigate the relative cost and effectiveness of the above-mentioned criteria by revisiting fundamental questions regarding the relationships between fault detection, test suite size, and control/data flow coverage. Although such questions have been partially investigated in previous studies, we can use a large number of mutants, which helps decrease the impact of random variation in our analysis and allows us to use a different analysis approach. Our results are then; compared with published studies, plausible reasons for the differences are provided, and the research leads us to suggest a way to tune the mutation analysis process to possible differences in fault detection probabilities in a specific environment","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.experimental design..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">experimental design.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Testing and debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Testing and debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing strategies.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing strategies</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test coverage of code.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test coverage of code</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
An analysis of the relationship between conditional entropy and failed error propagation in software testing,acm,An analysis of the relationship between conditional entropy and failed error propagation in software testing,"Androutsopoulos, Kelly, David Clark, Haitao Dan, Robert M. Hierons, and Mark Harman",12," In <i>Proceedings of the 36th International Conference on Software Engineering</i>, pp. 573-583. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Failed error propagation (FEP) is known to hamper software testing, yet it remains poorly understood. We introduce an information theoretic formulation of FEP that is based on measures of conditional entropy. This formulation considers the situation in which we are interested in the potential for an incorrect program state at statement s to fail to propagate to incorrect output. We define five metrics that differ in two ways: whether we only consider parts of the program that can be reached after executing s and whether we restrict attention to a single program path of interest .We give the results of experiments in which it was found that on average one in 10 tests suffered from FEP, earlier studies having shown that this figure can vary significantly between programs. The experiments also showed that our metrics are well-correlated with FEP. Our empirical study involved 30 programs, for which we executed a total of 7,140,000 test cases. The results reveal that the metrics differ in their performance but the Spearman rank correlation with failed error propagation is close to 0.95 for two of the metrics. These strong correlations in an experimental setting, in which all information about both FEP and conditional entropy is known, open up the possibility in the longer term of devising inexpensive information theory based metrics that allow us to minimise the effect of FEP. </p></div> 
            

            </div>
          ",Information Theory; Program Analysis
A case study using the round-trip strategy for state-based class testing,ieeexplore,A case study using the round-trip strategy for state-based class testing,"Antoniol, Giuliano, Lionel C. Briand, Massimiliano Di Penta, and Yvan Labiche",71," In <i>Software Reliability Engineering, 2002. ISSRE 2003. Proceedings. 13th International Symposium on</i>, pp. 269-279. IEEE, 2002.","A number of strategies have been proposed for state-based class testing. An important proposal made by Chow (1978), that was subsequently adapted by Binder (1999), consists in deriving test sequences covering all round-trip paths in a finite state machine (FSMs). Based on a number of (rather strong) assumptions, and for traditional FSMs, it can be demonstrated that all operation and transfer errors in the implementation can be uncovered. Through experimentation, this paper investigates this strategy when used in the context of UML statecharts. Based on a set of mutation operators proposed for object-oriented code we seed a significant number of faults in an implementation of a specific container class. We then investigate the effectiveness of four test teams at uncovering faults, based on the round-trip path strategy, and analyze the faults that seem to be difficult to detect. Our main conclusion is that the round-trip path strategy is reasonably effective at detecting faults (87% average as opposed to 69% for size-equivalent, random test cases) but that a significant number of faults can only exhibit a high detection probability by augmenting the round-trip strategy with a traditional black-box strategy such as category-partition testing. This increases the number of test cases to run -and therefore the cost of testing- and a cost-benefit analysis weighting the increase of testing effort and the likely gain in fault detection is necessary.",
Using mutation to assess fault detection capability of model review,Wiley Online Library,Using mutation to assess fault detection capability of model review,"Arcaini, Paolo, Angelo Gargantini, and Elvinia Riccobene",6," <i>Software Testing, Verification and Reliability</i> 25, no. 5-7 (2015): 629-652.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">Summary</h2><p>Among validation techniques, <em>model review</em> is a static analysis approach that can be performed at the early stages of software development, at the specification level, and aims at determining if a model owns certain quality attributes (like completeness, consistency and minimality). However, the model review capability to detect behavioural faults has never been measured. In this paper, a methodology and a supporting tool for evaluating the fault detection capability of a NuSMV model advisor are presented, which performs an automatic static model review of NuSMV models. The approach is based on the use of <em>mutation</em> in a similar way as in mutation testing: several mutation operators for NuSMV models are defined, and the model advisor is used to detect behavioural faults by statically analysing mutated specifications. In this way, it is possible to measure the model advisor ability to discover faults. To improve the quality of the analysis, the equivalence between a NuSMV model and any of its mutants must be checked. To perform this task, this paper proposes a technique based on the concept of equivalent Kripke structures, as NuSMV models are Kripke structures. A number of experiments assess the fault-detecting capability, precision and accuracy of the proposed approach. Analysis of variance is used to check if the results are statistically significant. Some relationships among mutation operators and model quality attributes are also established. Copyright © 2014 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model review; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault detection capability; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">NuSMV; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">equivalent mutants</span></li>"
Adaptive random testing: An illusion of effectiveness?,acm,Adaptive random testing: An illusion of effectiveness?,"Arcuri, Andrea, and Lionel Briand",67," In <i>Proceedings of the 2011 International Symposium on Software Testing and Analysis</i>, pp. 265-275. ACM, 2011.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Adaptive Random Testing (ART) has been proposed as an enhancement to random testing, based on assumptions on how failing test cases are distributed in the input domain. The main assumption is that failing test cases are usually grouped into contiguous regions. Many papers have been published in which ART has been described as an effective alternative to random testing when using the average number of test case executions needed to find a failure (F-measure). But all the work in the literature is based either on simulations or case studies with unreasonably high failure rates. In this paper, we report on the largest empirical analysis of ART in the literature, in which 3727 mutated programs and nearly ten trillion test cases were used. Results show that ART is highly inefficient even on trivial problems when accounting for distance calculations among test cases, to an extent that probably prevents its practical use in most situations. For example, on the infamous Triangle Classification program, random testing finds failures in few milliseconds whereas ART execution time is prohibitive. Even when assuming a small, fixed size test set and looking at the probability of failure (P-measure), ART only fares slightly better than random testing, which is not sufficient to make it applicable in realistic conditions. We provide precise explanations of this phenomenon based on rigorous empirical analyses. For the simpler case of single-dimension input domains, we also perform formal analyses to support our claim that ART is of little use in most situations, unless drastic enhancements are developed. Such analyses help us explain some of the empirical results and identify the components of ART that need to be improved to make it a viable option in practice.</p></div> 
            

            </div>
          ",F-measure; P-measure; distance; diversity; faulty region; random testing; shape; similarity
Multi-objective construction of an entire adequate test suite for an EFSM,ieeexplore,Multi-objective construction of an entire adequate test suite for an EFSM,"Asoudeh, Nesa, and Yvan Labiche",7," In <i>Software Reliability Engineering (ISSRE), 2014 IEEE 25th International Symposium on</i>, pp. 288-299. IEEE, 2014.","In this paper we propose a method and a tool to generate test suites from extended finite state machines, accounting for multiple (potentially conflicting) objectives. We aim at maximizing coverage and feasibility of a test suite while minimizing similarity between its test cases and minimizing overall cost. Therefore, we define a multi-objective genetic algorithm that searches for optimal test suites based on four objective functions. In doing so, we create an entire test suite at once as opposed to test cases one at a time. Our approach is evaluated on two different case studies, showing interesting initial results.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.case studies.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">case studies</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.state-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">state-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.EFSM.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">EFSM</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.genetic algorithm.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">genetic algorithm</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.multi-objective optimization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">multi-objective optimization</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
The right choice matters! SMT solving substantially improves model-based debugging of spreadsheets,ieeexplore,The right choice matters! SMT solving substantially improves model-based debugging of spreadsheets,"Außerlechner, Simon, Sandra Fruhmann, Wolfgang Wieser, Birgit Hofer, Raphael Spörk, Clemens Mühlbacher, and Franz Wotawa",16," In <i>Quality Software (QSIC), 2013 13th International Conference on</i>, pp. 139-148. IEEE, 2013.","Spreadsheets are undoubtedly the most prominent example of end-user programs vastly used in practice. Spreadsheets are often complex and comprise several hundreds or even thousands of formulas making fault localization a very hard and painstaking task. Although there has been work based on model-based reasoning for fault localization in spreadsheets, its applicability in practice is still limited mainly due to two reasons. First, most of the available constraint solvers, used for computing diagnoses, do not sufficiently support Real numbers. Second, the runtime especially for larger spreadsheets is too long preventing truly interactive debugging. In order to eliminate limitations regarding data type support and runtime performance, we suggest the use of SMT solvers for spreadsheet debugging. Besides lying out the foundations of SMT solving for diagnoses, we introduce its application to spreadsheet debugging. The empirical evaluation shows that the SMT solver Z3 requires six times less time for computing diagnoses compared to public available constraint solvers.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.fault localization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">fault localization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Spreadsheets.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Spreadsheets</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
An empirical evaluation of mutation testing for improving the test quality of safety-critical software,ieeexplore,An empirical evaluation of mutation testing for improving the test quality of safety-critical software,"Baker, Richard, and Ibrahim Habli",24," <i>IEEE Transactions on Software Engineering</i> 39, no. 6 (2013): 787-805.","Testing provides a primary means for assuring software in safety-critical systems. To demonstrate, particularly to a certification authority, that sufficient testing has been performed, it is necessary to achieve the test coverage levels recommended or mandated by safety standards and industry guidelines. Mutation testing provides an alternative or complementary method of measuring test sufficiency, but has not been widely adopted in the safety-critical industry. In this study, we provide an empirical evaluation of the application of mutation testing to airborne software systems which have already satisfied the coverage requirements for certification. Specifically, we apply mutation testing to safety-critical software developed using high-integrity subsets of C and Ada, identify the most effective mutant types, and analyze the root causes of failures in test cases. Our findings show how mutation testing could be effective where traditional structural coverage analysis and manual peer review have failed. They also show that several testing issues have origins beyond the test activity, and this suggests improvements to the requirements definition and coding process. Our study also examines the relationship between program characteristics and mutation survival and considers how program size can provide a means for targeting test areas most likely to have dormant faults. Industry feedback is also provided, particularly on how mutation testing can be integrated into a typical verification life cycle of airborne software.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.certification.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">certification</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.safety-critical software.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">safety-critical software</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.verification.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">verification</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Test input generation using UML sequence and state machines models,ieeexplore,Test input generation using UML sequence and state machines models,"Bandyopadhyay, Aritra, and Sudipto Ghosh",29," In <i>Software Testing Verification and Validation, 2009. ICST'09. International Conference on</i>, pp. 121-130. IEEE, 2009.",We propose a novel testing approach that combines information from UML sequence models and state machine models. Current approaches that rely solely on sequence models do not consider the effects of the message path under test on the states of the participating objects. Dinh-Trong et al. proposed an approach to test input generation using information from class and sequence models.We extend their Variable Assignment Graph (VAG) based approach to include information from state machine models. The extended VAG (EVAG) produces multiple execution paths representing the effects of the messages on the states of their target objects.We performed mutation analysis on the implementation of a video store system to demonstrate that our test inputs are more effective than those that cover only sequence diagram paths.,"
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test input generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test input generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.class models.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">class models</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.model-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">model-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.sequence models.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">sequence models</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.state machine models.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">state machine models</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Sound and quasi-complete detection of infeasible test requirements,ieeexplore,Sound and quasi-complete detection of infeasible test requirements,"Bardin, Sébastien, Mickaël Delahaye, Robin David, Nikolai Kosmatov, Mike Papadakis, Yves Le Traon, and Jean-Yves Marion",17," In <i>Software Testing, Verification and Validation (ICST), 2015 IEEE 8th International Conference on</i>, pp. 1-10. IEEE, 2015.","In software testing, coverage criteria specify the requirements to be covered by the test cases. However, in practice such criteria are limited due to the well-known infeasibility problem, which concerns elements/requirements that cannot be covered by any test case. To deal with this issue we revisit and improve state-of-the-art static analysis techniques, such as Value Analysis and Weakest Precondition calculus. We propose a lightweight greybox scheme for combining these two techniques in a complementary way. In particular we focus on detecting infeasible test requirements in an automatic and sound way for condition coverage, multiple condition coverage and weak mutation testing criteria. Experimental results show that our method is capable of detecting almost all the infeasible test requirements, 95% on average, in a reasonable amount of time, i.e., less than 40 seconds, making it practical for unit testing.",
Building trust into oo components using a genetic analogy,ieeexplore,Building trust into OO components using a genetic analogy,"Baudry, Benoit, Vu Le Hanh, J-M. Jezequel, and Yves Le Traon",28," In <i>Software Reliability Engineering, 2000. ISSRE 2000. Proceedings. 11th International Symposium on</i>, pp. 4-14. IEEE, 2000.","Despite the growing interest for component based systems, few works tackle the question of the trust we can bring into a component. The paper presents a method and a tool for building trustable OO components. It is particularly adapted to a design-by-contract approach, where the specification is systematically derived into executable assertions (invariant properties, pre/postconditions of methods). A component is seen as an organic set composed of a specification, a given implementation and its embedded test cases. We propose an adaptation of mutation analysis to the OO paradigm that checks the consistency between specification/implementation and tests. Faulty programs, called ""mutants"", are generated by systematic fault injection in the implementation. The quality of tests is related to the mutation score, i.e. the proportion of faulty programs it detects. The main contribution is to show how a similar idea can be used in the same context to address the problem of effective test optimization. To map the genetic analogy to the test optimization problem, we consider mutant programs to be detected as the initial preys population and test cases as the predators population. The test selection consists of mutating the ""predator"" test cases and crossing them over in order to improve their ability to kill the prey population. The feasibility of component validation using such a ""Darwinian"" model and its usefulness for test optimization are studied.",
Genes and bacteria for automatic test cases optimization in the. net environment,ieeexplore,Genes and bacteria for automatic test cases optimization in the. net environment,"Baudry, Benoit, Franck Fleurey, J-M. Jézéquel, and Yves Le Traon",72," In <i>Software Reliability Engineering, 2002. ISSRE 2003. Proceedings. 13th International Symposium on</i>, pp. 195-206. IEEE, 2002.","The level of confidence in a software component is often linked to the quality of its test cases. This quality can in turn be evaluated with mutation analysis: faulty components (mutants) are systematically generated to check the proportion of mutants detected (""killed"") by the test cases. But while the generation of basic test cases set is easy, improving its quality may require prohibitive effort. We focus on the issue of automating the test optimization. We looked at genetic algorithms to solve this problem and modeled it as follows: a test case can be considered as a predator while a mutant program is analogous to a prey. The aim of the selection process is to generate test cases able to kill as many mutants as possible. To overcome disappointing experimentation results on the studied .NET system, we propose a slight variation on this idea, no longer at the ""animal"" level (lions killing zebras) but at the bacteriological level. The bacteriological level indeed better reflects the test case optimization issue: it introduces a memorization function and suppresses the crossover operator. We describe this model and show how it behaves on the case study.",
From genetic to bacteriological algorithms for mutation-based testing,Wiley Online Library,From genetic to bacteriological algorithms for mutation‐based testing,"Baudry, Benoit, Franck Fleurey, Jean‐Marc Jézéquel, and Yves Le Traon",82," <i>Software Testing, Verification and Reliability</i> 15, no. 2 (2005): 73-96.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>The level of confidence in a software component is often linked to the quality of its test cases. This quality can in turn be evaluated with mutation analysis: faults are injected into the software component (making mutants of it) to check the proportion of mutants detected (‘killed’) by the test cases. But while the generation of a set of basic test cases is easy, improving its quality may require prohibitive effort. This paper focuses on the issue of automating the test optimization. The application of genetic algorithms would appear to be an interesting way of tackling it. The optimization problem is modelled as follows: a test case can be considered as a predator while a mutant program is analogous to a prey. The aim of the selection process is to generate test cases able to kill as many mutants as possible, starting from an initial set of predators, which is the test cases set provided by the programmer. To overcome disappointing experimentation results, on .Net components and unit Eiffel classes, a slight variation on this idea is studied, no longer at the ‘animal’ level (lions killing zebras, say) but at the bacteriological level. The bacteriological level indeed better reflects the test case optimization issue: it mainly differs from the genetic one by the introduction of a memorization function and the suppression of the crossover operator. The purpose of this paper is to explain how the genetic algorithms have been adapted to fit with the issue of test optimization. The resulting algorithm differs so much from genetic algorithms that it has been given another name: bacteriological algorithm. Copyright © 2005 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">automatic test generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">evolutionist algorithms; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">object-oriented testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis</span></li>"
Exploiting model morphology for event-based testing,ieeexplore,Exploiting model morphology for event-based testing,"Belli, Fevzi, and Mutlu Beyazıt",3," <i>IEEE Transactions on Software Engineering</i> 41, no. 2 (2015): 113-134.","Model-based testing employs models for testing. Model-based mutation testing (MBMT) additionally involves fault models, called mutants, by applying mutation operators to the original model. A problem encountered with MBMT is the elimination of equivalent mutants and multiple mutants modeling the same faults. Another problem is the need to compare a mutant to the original model for test generation. This paper proposes an event-based approach to MBMT that is not fixed on single events and a single model but rather operates on sequences of events of length k ≥ 1 and invokes a sequence of models that are derived from the original one by varying its morphology based on k. The approach employs formal grammars, related mutation operators, and algorithms to generate test cases, enabling the following: (1) the exclusion of equivalent mutants and multiple mutants; (2) the generation of a test case in linear time to kill a selected mutant without comparing it to the original model; (3) the analysis of morphologically different models enabling the systematic generation of mutants, thereby extending the set of fault models studied in related literature. Three case studies validate the approach and analyze its characteristics in comparison to random testing and another MBMT approach.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutant selection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutant selection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-based mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-based mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.grammar-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">grammar-based testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
"Mutation Testing of"" Go-Back"" Functions Based on Pushdown Automata",ieeexplore,"Mutation Testing of ""Go-Back"" Functions Based on Pushdown Automata","Belli, Fevzi, Mutlu Beyazit, Tomohiko Takagi, and Zengo Furukawa",7,"Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on","A go-back (GB) function for canceling recent user or system operations and going back to and resuming of previous state(s) is very often used regardless of the application domain. Therefore, faulty handling of them can cause severe damages in those applications. This paper proposes a mutation-based approach to testing GB functions modeled by pushdown automata. Novel mutation operators, recent coverage criteria, and a new algorithm for test case generation are introduced. A case study validates the approach and discusses its characteristics.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.pushdown automata.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">pushdown automata</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.go-back function.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">go-back function</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.model-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">model-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Automatic XACML requests generation for policy testing,ieeexplore,Automatic XACML requests generation for policy testing,"Bertolino, Antonia, Said Daoudagh, Francesca Lonetti, and Eda Marchetti",28," In <i>Software Testing, Verification and Validation (ICST), 2012 IEEE Fifth International Conference on</i>, pp. 842-849. IEEE, 2012.","Access control policies are usually specified by the XACML language. However, policy definition could be an error prone process, because of the many constraints and rules that have to be specified. In order to increase the confidence on defined XACML policies, an accurate testing activity could be a valid solution. The typical policy testing is performed by deriving specific test cases, i.e. XACML requests, that are executed by means of a PDP implementation, so to evidence possible security lacks or problems. Thus the fault detection effectiveness of derived test suite is a fundamental property. To evaluate the performance of the applied test strategy and consequently of the test suite, a commonly adopted methodology is using mutation testing. In this paper, we propose two different methodologies for deriving XACML requests, that are defined independently from the policy under test. The proposals exploit the values of the XACML policy for better customizing the generated requests and providing a more effective test suite. The proposed methodologies have been compared in terms of their fault detection effectiveness by the application of mutation testing on a set of real policies.",
Assessing and improving state-based class testing: A series of experiments,ieeexplore,Assessing and improving state-based class testing: A series of experiments,"Briand, Lionel C., Massimiliano Di Penta, and Yvan Labiche",130," <i>IEEE Transactions on Software Engineering</i> 30, no. 11 (2004): 770-783.","This work describes an empirical investigation of the cost effectiveness of well-known state-based testing techniques for classes or clusters of classes that exhibit a state-dependent behavior. This is practically relevant as many object-oriented methodologies recommend modeling such components with statecharts which can then be used as a basis for testing. Our results, based on a series of three experiments, show that in most cases state-based techniques are not likely to be sufficient by themselves to catch most of the faults present in the code. Though useful, they need to be complemented with black-box, functional testing. We focus here on a particular technique, Category Partition, as this is the most commonly used and referenced black-box, functional testing technique. Two different oracle strategies have been applied for checking the success of test cases. One is a very precise oracle checking the concrete state of objects whereas the other one is based on the notion of state invariant (abstract states). Results show that there is a significant difference between them, both in terms of fault detection and cost. This is therefore an important choice to make that should be driven by the characteristics of the component to be tested, such as its criticality, complexity, and test budget.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.category partition..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">category partition.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Index Terms- State-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Index Terms- State-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing experimentation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing experimentation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.UML statecharts.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">UML statecharts</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Using simulation to empirically investigate test coverage criteria based on statechart,ieeexplore,Using simulation to empirically investigate test coverage criteria based on statechart,"Briand, Lionel C., Yvan Labiche, and Yihong Wang",105," In <i>Software Engineering, 2004. ICSE 2004. Proceedings. 26th International Conference on</i>, pp. 86-95. IEEE, 2004.","A number of testing strategies have been proposed using state machines and statecharts as test models in order to derive test sequences and validate classes or class clusters. Though such criteria have the advantage of being systematic, little is known on how cost effective they are and how they compare to each other. This article presents a precise simulation and analysis procedure to analyze the cost-effectiveness of statechart-based testing techniques. We then investigate, using this procedure, the cost and fault detection effectiveness of adequate test sets for the most referenced coverage criteria for statecharts on three different representative case studies. Through the analysis of common results and differences across studies, we attempt to draw more general conclusions regarding the costs and benefits of using the criteria under investigation.",
Improving statechart testing criteria using data flow information,ieeexplore,Improving statechart testing criteria using data flow information,"Briand, Lionel C., Yvan Labiche, and Q. Lin",27," In <i>Software Reliability Engineering, 2005. ISSRE 2005. 16th IEEE International Symposium on</i>, pp. 10-pp. IEEE, 2005.","Empirical studies have shown there is wide variation in cost (e.g., of devising and executing test cases) and effectiveness (at finding faults) across existing state-based coverage criteria. As these criteria can be considered as executing the control flow structure of the statechart, we are attempting to investigate how data flow information can be used to improve their cost-effectiveness. This article presents a comprehensive methodology to perform data flow analysis of UML statecharts, applies it to the round-trip path (transition tree) coverage criterion and reports on two case studies. The results of the case studies show that dataflow information can be used to select the best cost-effective transition tree when more than one satisfies the transition tree criterion. We further propose a more optimal strategy for the transition tree criterion, in terms of cost and effectiveness. The improved tree strategy is evaluated through the two case studies and the results suggest that it is a cost-effective strategy that would fit into many practical situations",
The effects of time constraints on test case prioritization: A series of controlled experiments,ieeexplore,The effects of time constraints on test case prioritization: A series of controlled experiments,"Do, Hyunsook, Siavash Mirarab, Ladan Tahvildari, and Gregg Rothermel",104," <i>IEEE Transactions on Software Engineering</i> 36, no. 5 (2010): 593-617.","Regression testing is an expensive process used to validate modified software. Test case prioritization techniques improve the cost-effectiveness of regression testing by ordering test cases such that those that are more important are run earlier in the testing process. Many prioritization techniques have been proposed and evidence shows that they can be beneficial. It has been suggested, however, that the time constraints that can be imposed on regression testing by various software development processes can strongly affect the behavior of prioritization techniques. If this is correct, a better understanding of the effects of time constraints could lead to improved prioritization techniques and improved maintenance and testing processes. We therefore conducted a series of experiments to assess the effects of time constraints on the costs and benefits of prioritization techniques. Our first experiment manipulates time constraint levels and shows that time constraints do play a significant role in determining both the cost-effectiveness of prioritization and the relative cost-benefit trade-offs among techniques. Our second experiment replicates the first experiment, controlling for several threats to validity including numbers of faults present, and shows that the results generalize to this wider context. Our third experiment manipulates the number of faults present in programs to examine the effects of faultiness levels on prioritization and shows that faultiness level affects the relative cost-effectiveness of prioritization techniques. Taken together, these results have several implications for test engineers wishing to cost-effectively regression test their software systems. These include suggestions about when and when not to prioritize, what techniques to employ, and how differences in testing processes may relate to prioritization cost--effectiveness.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical studies..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical studies.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Regression testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Regression testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case prioritization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case prioritization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.cost-benefits.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">cost-benefits</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Bayesian networks.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Bayesian networks</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
An automated approach to reducing test suites for testing retargeted C compilers for embedded systems,Elsevier,An automated approach to reducing test suites for testing retargeted C compilers for embedded systems,"Chae, Heung Seok, Gyun Woo, Tae Yeon Kim, Jung Ho Bae, and Won-Young Kim",3," <i>Journal of Systems and Software</i> 84, no. 12 (2011): 2053-2064.","With widespread use of embedded processors, there is an increasing need to develop compilers for them in a timely manner. Retargeting has been an effective approach to constructing new compilers by modifying the back-end of existing compilers. An efficient testing method for retargeted compilers using intermediate codes is proposed in this paper. The concepts of the intermediate-code-based approach are described, and it is demonstrated that the proposed approach is efficient and effective enough. We have developed an automated tool, PLOOSE, which generates test suites based on source-code coverage criteria and then reduces them based on intermediate-code coverage. In addition, case studies are presented which reveal that a test suite based on source codes can be considerably reduced using intermediate codes. Moreover, by mutation analysis, it was found that the size of the test suite has been reduced by over 90% on average, but the fault detection capability of the reduced test suites is still approximately 80% of that of the original test suites. In particular, the proposed reduction method can be useful for testing compilers in the early stage of the development of retargeted compilers.",<span>Test suite generation and reduction</span>
Can fault-exposure-potential estimates improve the fault detection abilities of test suites?,Wiley Online Library,Can fault‐exposure‐potential estimates improve the fault detection abilities of test suites?,"Chen, Wei, Roland H. Untch, Gregg Rothermel, Sebastian Elbaum, and Jeffery Von Ronne",20," <i>Software Testing, Verification and Reliability</i> 12, no. 4 (2002): 197-218.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Code-coverage-based test data adequacy criteria typically treat all coverable code elements (such as statements,  basic blocks or outcomes of decisions) as equal. In practice, however, the probability that a test case can expose a fault in a code element varies: some faults are more easily revealed than others. Thus, several researchers have suggested that if  one could estimate the probability that a fault in  a code element will cause a failure, one could use  this estimate to determine the number of executions of  a code element that are required to achieve a certain  level of confidence in that element's correctness. This estimate, in turn, could be used to improve the  fault-detection effectiveness of test suites and help  testers distribute testing resources more effectively. This conjecture is intriguing; however, like many such  conjectures it has never been directly examined empirically. If empirical evidence were to support this conjecture, it would motivate further research into methodologies for obtaining fault-exposure-potential estimates and incorporating them into test data adequacy criteria. This paper reports the results of experiments conducted to investigate the effects of incorporating an estimate of fault-exposure probability into the statement coverage test data adequacy criterion. The results of these experiments, however, ran contrary  to the conjectures of previous researchers. Although incorporation of the estimates did produce statistically significant increases in the fault-detection effectiveness of test suites, these increases were quite  small, suggesting that the approach might not be able to produce the gains hoped for and might not be worth the cost of its employment. Copyright © 2002 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test adequacy criteria; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">code coverage; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault-exposure potential</span></li>"
Abstraction in assertion-based test oracles,ieeexplore,Abstraction in assertion-based test oracles,"Cheon, Yoonsik",11," In <i>Quality Software, 2007. QSIC'07. Seventh International Conference on</i>, pp. 410-414. IEEE, 2007.","Assertions can be used as test oracles. However, writing effective assertions of right abstraction levels is difficult because on the one hand, detailed assertions are preferred for thorough testing (i.e., to detect as many errors as possible), but on the other hand abstract assertions are preferred for readability, maintainability, and reusability. As assertions become a practical tool for testing and debugging programs, this is an important and practical problem to solve for the effective use of assertions. We advocate the use of model variables - specification-only variables of which abstract values are given as mappings from concrete program states - to write abstract assertions for test oracles. We performed a mutation testing experiment to evaluate the effectiveness of the use of model variables in assertion-based test oracles. According to our experiment, assertions written in terms of model variables are as effective as assertions written without using model variables in detecting (injected) faults, and the execution time overhead of model variables are negligible. Our findings are applicable to other use of runtime checkable assertions.",
An empirical evaluation of statistical testing designed from UML state diagrams: the flight guidance system case study,ieeexplore,An empirical evaluation of statistical testing designed from UML state diagrams: the flight guidance system case study,"Chevalley, Philippe, and Pascale Thévenod-Fosse",14," In <i>Software Reliability Engineering, 2001. ISSRE 2001. Proceedings. 12th International Symposium on</i>, pp. 254-263. IEEE, 2001.","This paper presents an empirical study of the effectiveness of test cases generated from UML state diagrams using transition coverage as the testing criterion. The test cases production is mainly based on an adaptation of a probabilistic method, called statistical testing based on testing criteria. This technique was automated with the aid of the Rational Software Corporation's Rose RealTime tool. The test strategy investigated combines statistical test cases with (few) deterministic test cases focused on domain boundary values. Its feasibility is exemplified on a research version of an avionics system implemented in Java: the Flight Guidance System case study (14 concurrent state diagrams). Then, the results of an empirical evaluation of the effectiveness of the created test cases are presented. The evaluation was performed using mutation analysis to assess the error detection power of the test cases on more than 1500 faults seeded one by one in the Java source code (115 classes, 6500 LOC). A detailed analysis of the test results allows us to draw first conclusions on the expected strengths and weaknesses of the proposed test strategy.",
Behaviour abstraction coverage as black-box adequacy criteria,ieeexplore,Behaviour abstraction coverage as black-box adequacy criteria,"Czemerinski, Hernan, Victor Braberman, and Sebastián Uchitel",3," In <i>Software Testing, Verification and Validation (ICST), 2013 IEEE Sixth International Conference on</i>, pp. 222-231. IEEE, 2013.","Code artefacts that have non-trivial requirements with respect to the ordering in which their methods or procedures ought to be called are common and appear, for instance, in the form of API implementations and objects. Testing such code artefacts to gain confidence in that they conform to their intended protocols is an important and challenging problem. In this paper we propose and study experimentally conformance testing adequacy criteria based on covering an abstraction of the intended behavior's semantics. Thus, the criteria are independent of the specification language and structure used to describe the intended protocol and the language used to implement it. As a consequence the results may be of use to black box conformance testing approaches in general. Experimental results show that the criterion is a good predictor for conformance failure detection and for classical structural coverage criteria such as code and branch coverage.",
Behaviour abstraction adequacy criteria for API call protocol testing,Wiley Online Library,Behaviour abstraction adequacy criteria for API call protocol testing,"Czemerinski, Hernan, Victor Braberman, and Sebastian Uchitel",1," <i>Software Testing, Verification and Reliability</i> (2015).","Code artefacts that have non-trivial requirements with respect to the ordering in which their methods or procedures ought to be called are common and appear, for instance, in the form of API implementations and objects. Testing such code artefacts to gain confidence that they conform to their intended protocols is an important and challenging problem. This paper proposes conformance testing adequacy criteria based on covering an abstraction of the intended behaviour’s semantics. Thus, the criteria are independent of the specification language and structure used to describe the intended protocol and the language used to implement it. As a consequence, the results may be of use to black box conformance testing approaches in general. Experimental results show that the criteria are a good predictor for fault detection for protocol conformance and for classical structural coverage criteria such as statement and branch coverage. They also show that the division of the domain derived from the criterion produces subdomains such that most of its inputs are fault revealing","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">API call protocol; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">adequacy criteria</span></li>"
An approach for testing pointcut descriptors in aspectj,Wiley Online Library,An approach for testing pointcut descriptors in aspectj,"Delamare, Romain, Benoit Baudry, Sudipto Ghosh, Shashank Gupta, and Yves Le Traon",7," <i>Software Testing, Verification and Reliability</i> 21, no. 3 (2011): 215-239.","Aspect-oriented programming (AOP) promises better software quality through enhanced modularity. Crosscutting concerns are encapsulated in separate units called aspects and are introduced at specific points in the base program at compile time or runtime. However, aspect-oriented mechanisms also introduce new risks for reliability that must be tackled by specific testing techniques in order to fully benefit from the use of AOP. This paper focuses on the pointcut descriptor (PCD) that declares the set of points in the base program's execution where the crosscutting concern must be woven. A fault in the PCD can have a ripple effect and result in many different faults. New behavior may be added in unexpected places, or places where new behavior should be added may be missed. When implementing aspect-oriented programs with AspectJ, JUnit is most commonly used to test the program. However, JUnit does not offer any mechanism to look for faults specifically located in the PCD. As a consequence, these faults can be detected only through complex test scenarios and side effects that are difficult to trigger and observe. This paper proposes to monitor the execution of advices in an aspect-oriented program and use this information to build test cases that target faults in PCDs. The AdviceTracer tool has been developed to automatically monitor and store all information related to advice executions. It also offers a set of operations that can be used to check the presence or absence of advices at specific points in the execution. These operations improve the definition of an oracle for PCD test cases. An empirical study is performed to compare JUnit and AdviceTracer for testing PCDs in terms of the complexity of test cases and their ability to detect faults. The study is performed on a Healthwatcher system that has 93 classes and 19 PCDs. It reveals that test cases that use AdviceTracer to test PCDs are easier to write (shorter test cases and written in less time than with JUnit) and detect more faults. ","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">aspect-oriented programming; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test oracle; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test framework</span></li>"
Constraint-based automatic test data generation,ieeexplore,Constraint-based automatic test data generation,"DeMilli, R. A., and A. Jefferson Offutt",939," <i>IEEE Transactions on Software Engineering</i> 17, no. 9 (1991): 900-910.",A novel technique for automatically generating test data is presented. The technique is based on mutation analysis and creates test data that approximate relative adequacy. It is a fault-based technique that uses algebraic constraints to describe test cases designed to find particular types of faults. A set of tools (collectively called Godzilla) that automatically generates constraints and solves them to create test cases for unit and module testing has been implemented. Godzilla has been integrated with the Mothra testing system and has been used as an effective way to generate test data that kill program mutants. The authors present an initial list of constraints and discuss some of the problems that have been solved to develop the complete implementation of the technique.,
Experimental results from an automatic test case generator,acm,Experimental results from an automatic test case generator,"DeMillo, Richard A., and A. Jefferson Offutt",162," <i>ACM Transactions on Software Engineering and Methodology (TOSEM)</i> 2, no. 2 (1993): 109-127.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>Constraint-based testing is a novel way of generating test data to detect specific types of common programming faults. The conditions under which faults will be detected are encoded as mathematical systems of constraints in terms of program symbols. A set of tools, collectively called Godzilla, has been implemented that automatically generates constraint systems and solves them to create test cases for use by the Mothra testing system. Experimental results from using Godzilla show that the technique can produce test data that is very close in terms of mutation adequacy to test data that is produced manually, and at substantially reduced cost. Additionally, these experiments have suggested a new procedure for unit testing, where test cases are viewed as throw-away items rather than scarce resources.</par></div> 
            

            </div>
          ",http://dl.acm.org/citation.cfm?id=151257.151258
Dynamic data flow testing of object oriented systems,acm,Dynamic data flow testing of object oriented systems,"Denaro, Giovanni, Alessandro Margara, Mauro Pezze, and Mattia Vivanti",12," In <i>Proceedings of the 37th International Conference on Software Engineering-Volume 1</i>, pp. 947-958. IEEE Press, 2015.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Data flow testing has recently attracted new interest in the context of testing object oriented systems, since data flow information is well suited to capture relations among the object states, and can thus provide useful information for testing method interactions. Unfortunately, classic data flow testing, which is based on static analysis of the source code, fails to identify many important data flow relations due to the dynamic nature of object oriented systems. In this paper, we propose a new technique to generate test cases for object oriented software. The technique exploits useful inter-procedural data flow information extracted dynamically from execution traces for object oriented systems. The technique is designed to enhance an initial test suite with test cases that exercise complex state based method interactions. The experimental results indicate that dynamic data flow testing can indeed generate test cases that exercise relevant behaviors otherwise missed by both the original test suite and by test suites that satisfy classic data flow criteria.</p></div> 
            

            </div>
          ",
Generating complex and faulty test data through model-based mutation analysis,ieeexplore,Generating complex and faulty test data through model-based mutation analysis,"Di Nardo, Daniel, Fabrizio Pastore, and Lionel Briand",8," In <i>Software Testing, Verification and Validation (ICST), 2015 IEEE 8th International Conference on</i>, pp. 1-10. IEEE, 2015.","Testing the correct behaviour of data processing systems in the presence of faulty data is extremely expensive. The data structures processed by these systems are often complex, with many data fields and multiple constraints among them. Software engineers, in charge of testing these systems, have to handcraft complex data files or databases, while ensuring compliance with the multiple constraints to prevent the generation of trivially invalid inputs. In addition, assessing test results often means analysing complex output and log data. Though many techniques have been proposed to automatically test systems based on models, little exists in the literature to support the testing of systems where the complexity is in the data consumed in input or produced in output, with complex constraints between them. In particular, such systems often need to be tested with the presence of faults in the input data, in order to assess the robustness and behaviour of the system in response to such faults. This paper presents an automated test technique that relies upon six generic mutation operators to automatically generate faulty data. The technique receives two inputs: field data and a data model, i.e. a UML class diagram annotated with stereotypes and OCL constraints. The annotated class diagram is used to tailor the behaviour of the generic mutation operators to the fault model that is assumed for the system under test and the environment in which it is deployed. Empirical results obtained with a large data acquisition system in the satellite domain show that our approach can successfully automate the generation of test suites that achieve slightly better instruction coverage than manual testing based on domain expertise.",
A controlled experiment assessing test case prioritization techniques via mutation faults,ieeexplore,A controlled experiment assessing test case prioritization techniques via mutation faults,"Do, Hyunsook, and Gregg Rothermel",71," In <i>Software Maintenance, 2005. ICSM'05. Proceedings of the 21st IEEE International Conference on</i>, pp. 411-420. IEEE, 2005.","Regression testing is an important part of software maintenance, but it can also be very expensive. To reduce this expense, software testers may prioritize their test cases so that those that are more important are run earlier in the regression testing process. Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited to hand-seeded faults, primarily due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults. We have therefore designed and performed a controlled experiment to assess the ability of prioritization techniques to improve the rate of fault detection techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. We also compare our results to those collected earlier with respect to the relationship between hand-seeded faults and mutation faults, and the implications this has for researchers performing empirical studies of prioritization.",
On the use of mutation faults in empirical assessments of test case prioritization techniques,ieeexplore,On the use of mutation faults in empirical assessments of test case prioritization techniques,"Do, Hyunsook, and Gregg Rothermel",206," <i>IEEE Transactions on Software Engineering</i> 32, no. 9 (2006): 733-752.","Regression testing is an important activity in the software life cycle, but it can also be very expensive. To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of test case prioritization techniques is to increase a test suite's rate of fault detection (how quickly, in a run of its test cases, that test suite can detect faults). Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited primarily to hand-seeded faults, largely due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults and that the use of hand-seeded faults can be problematic for the validity of empirical results focusing on fault detection. We have therefore designed and performed two controlled experiments assessing the ability of prioritization techniques to improve the rate of fault detection of test case prioritization techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. More importantly, a comparison of our results with those collected using hand-seeded faults reveals several implications for researchers performing empirical studies of test case prioritization techniques in particular and testing techniques in general","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Regression testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Regression testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case prioritization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case prioritization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.program mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">program mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical studies..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical studies.</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
An empirical study of the effect of time constraints on the cost-benefits of regression testing,acm,An empirical study of the effect of time constraints on the cost-benefits of regression testing,"Do, Hyunsook, Siavash Mirarab, Ladan Tahvildari, and Gregg Rothermel",66," In <i>Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of software engineering</i>, pp. 71-82. ACM, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Regression testing is an expensive process used to validate modified software. Test case prioritization techniques improve the cost-effectiveness of regression testing by ordering test cases such that those that are more important are run earlier in the testing process. Many prioritization techniques have been proposed and evidence shows that they can be beneficial. It has been suggested, however, that the time constraints that can be imposed on regression testing by various software development processes can strongly affect the behavior of prioritization techniques. Therefore, we conducted an experiment to assess the effects of time constraints on the costs and benefits of prioritization techniques. Our results show that time constraints can indeed play a significant role in determining both the cost-effectiveness of prioritization, and the relative cost-benefit tradeoffs among techniques, with important implications for the use of prioritization in practice.</p></div> 
            

            </div>
          ",empirical studies; regression testing; test case prioritization
An evaluation of random testing,ieeexplore,An evaluation of random testing,"Duran, Joe W., and Simeon C. Ntafos",741, <i>IEEE transactions on software engineering</i> 4 (1984): 438-444.,"Random testing of programs has usually (but not always) been viewed as a worst case of program testing. Testing strategies that take into account the program structure are generally preferred. Path testing is an often proposed ideal for structural testing. Path testing is treated here as an instance of partition testing, where by partition testing is meant any testing scheme which forces execution of at least one test case from each subset of a partition of the input domain. Simulation results are presented which suggest that random testing may often be more cost effective than partition testing schemes. Also, results of actual random testing experiments are presented which confirm the viability of random testing as a useful validation tool.",
Comparing test quality measures for assessing student-written tests,acm,Comparing test quality measures for assessing student-written tests,"Edwards, Stephen H., and Zalia Shams",9," In <i>Companion Proceedings of the 36th International Conference on Software Engineering</i>, pp. 354-363. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Many educators now include software testing activities in programming assignments, so there is a growing demand for appropriate methods of assessing the quality of student-written software tests. While tests can be hand-graded, some educators also use objective performance metrics to assess software tests. The most common measures used at present are code coverage measures—tracking how much of the student’s code (in terms of statements, branches, or some combination) is exercised by the corresponding software tests. Code coverage has limitations, however, and sometimes it overestimates the true quality of the tests. Some researchers have suggested that mutation analysis may provide a better indication of test quality, while some educators have experimented with simply running every student’s test suite against every other student’s program—an “all-pairs” strategy that gives a bit more insight into the quality of the tests. However, it is still unknown which one of these measures is more accurate, in terms of most closely predicting the true bug revealing capability of a given test suite. This paper directly compares all three methods of measuring test quality in terms of how well they predict the observed bug revealing capabilities of student-written tests when run against a naturally occurring collection of student-produced defects. Experimental results show that all-pairs testing—running each student’s tests against every other student’s solution—is the most effective predictor of the underlying bug revealing capability of a test suite. Further, no strong correlation was found between bug revealing capability and either code coverage or mutation analysis scores. </p></div> 
            

            </div>
          ",
Black-box testing using flowgraphs: an experimental assessment of effectiveness and automation potential,"<a href=""/citations?user=5pV6DQ4AAAAJ&amp;hl=en&amp;oi=sra"">SH Edwards</a> - Softw. Test., Verif. Reliab., 2000 - researchgate.net",Black-box testing using flowgraphs: an experimental assessment of effectiveness and automation potential,"Edwards, Stephen H",49," <i>Softw. Test., Verif. Reliab.</i> 10, no. 4 (2000): 249-262.","A black-box testing strategy based on Zweben et al.’s specification-based test data ade- quacy criteria is explored. The approach focuses on generating a flowgraph from a component’s specification and applying analogues of white-box strategies to it. An experimental assessment of the fault-detecting ability of test sets generated using this approach was performed for three of Zweben’s criteria using mutation analysis. By using precondition, postcondition, and invariant checking wrappers around the component under test, fault detection ratios competitive with white-box techniques were achieved. Experience with a prototype test set generator used in the experiment suggests that practical automation may be feasible.",
Test case prioritization: A family of empirical studies,ieeexplore,Test case prioritization: A family of empirical studies,"Elbaum, Sebastian, Alexey G. Malishevsky, and Gregg Rothermel",746," <i>IEEE transactions on software engineering</i> 28, no. 2 (2002): 159-182.","To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of such prioritization is to increase a test suite's rate of fault detection. Previous work reported results of studies that showed that prioritization techniques can significantly improve rate of fault detection. Those studies, however, raised several additional questions: 1) Can prioritization techniques be effective when targeted at specific modified versions; 2) what trade-offs exist between fine granularity and coarse granularity prioritization techniques; 3) can the incorporation of measures of fault proneness into prioritization techniques improve their effectiveness? To address these questions, we have performed several new studies in which we empirically compared prioritization techniques using both controlled experiments and case studies.",
Similarity-based test case prioritization using ordered sequences of program entities,Springer,Similarity-based test case prioritization using ordered sequences of program entities,"Fang, Chunrong, Zhenyu Chen, Kun Wu, and Zhihong Zhao",18," <i>Software Quality Journal</i> 22, no. 2 (2014): 335-361.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Test suites often grow very large over many releases, such that it is impractical to re-execute all test cases within limited resources. Test case prioritization rearranges test cases to improve the effectiveness of testing. Code coverage has been widely used as criteria in test case prioritization. However, the simple way may not reveal some bugs, such that the fault detection rate decreases. In this paper, we use the ordered sequences of program entities to improve the effectiveness of test case prioritization. The execution frequency profiles of test cases are collected and transformed into the ordered sequences. We propose several novel similarity-based test case prioritization techniques based on the edit distances of ordered sequences. An empirical study of five open source programs was conducted. The experimental results show that our techniques can significantly increase the fault detection rate and be effective in detecting faults in loops. Moreover, our techniques are more cost-effective than the existing techniques.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Test case prioritization&nbsp;</span><span class=""Keyword"">Similarity&nbsp;</span><span class=""Keyword"">Ordered sequence&nbsp;</span><span class=""Keyword"">Edit distance&nbsp;</span><span class=""Keyword"">Farthest-first algorithm&nbsp;</span>"
Assessing and generating test sets in terms of behavioural adequacy,Wiley Online Library,Assessing and generating test sets in terms of behavioural adequacy,"Fraser, Gordon, and Neil Walkinshaw",6," <i>Software Testing, Verification and Reliability</i> 25, no. 8 (2015): 749-780.","Identifying a finite test set that adequately captures the essential behaviour of a program such that all faults are identified is a well-established problem. This is traditionally addressed with syntactic adequacy metrics (e.g. branch coverage), but these can be impractical and may be misleading even if they are satisfied. One intuitive notion of adequacy, which has been discussed in theoretical terms over the past three decades, is the idea of behavioural coverage: If it is possible to infer an accurate model of a system from its test executions, then the test set can be deemed to be adequate. Despite its intuitive basis, it has remained almost entirely in the theoretical domain because inferred models have been expected to be exact (generally an infeasible task) and have not allowed for any pragmatic interim measures of adequacy to guide test set generation. This paper presents a practical approach to incorporate behavioural coverage. Our BESTEST approach (1) enables the use of machine learning algorithms to augment standard syntactic testing approaches and (2) shows how search-based testing techniques can be applied to generate test sets with respect to this criterion. An empirical study on a selection of Java units demonstrates that test sets with higher behavioural coverage significantly outperform current baseline test criteria in terms of detected faults.","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test adequacy; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">search-based software testing</span></li>"
Mutation-driven generation of unit tests and oracles,ieeexplore,Mutation-driven generation of unit tests and oracles,"Fraser, Gordon, and Andreas Zeller",246," <i>IEEE Transactions on Software Engineering</i> 38, no. 2 (2012): 278-292.","To assess the quality of test suites, mutation analysis seeds artificial defects (mutations) into programs; a nondetected mutation indicates a weakness in the test suite. We present an automated approach to generate unit tests that detect these mutations for object-oriented classes. This has two advantages: First, the resulting test suite is optimized toward finding defects modeled by mutation operators rather than covering code. Second, the state change caused by mutations induces oracles that precisely detect the mutants. Evaluated on 10 open source libraries, our μtest prototype generates test suites that find significantly more seeded defects than the original manually written test suites.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.search-based testing..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">search-based testing.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test oracles.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test oracles</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.assertions.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">assertions</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Does automated white-box test generation really help software testers?,acm,Does automated white-box test generation really help software testers?,"Fraser, Gordon, Matt Staats, Phil McMinn, Andrea Arcuri, and Frank Padberg",45," In <i>Proceedings of the 2013 International Symposium on Software Testing and Analysis</i>, pp. 291-301. ACM, 2013.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Automated test generation techniques can efficiently produce test data that systematically cover structural aspects of a program. In the absence of a specification, a common assumption is that these tests relieve a developer of most of the work, as the act of testing is reduced to checking the results of the tests. Although this assumption has persisted for decades, there has been no conclusive evidence to date confirming it. However, the fact that the approach has only seen a limited uptake in industry suggests the contrary, and calls into question its practical usefulness. To investigate this issue, we performed a controlled experiment comparing a total of 49 subjects split between writing tests manually and writing tests with the aid of an automated unit test generation tool, EvoSuite. We found that, on one hand, tool support leads to clear improvements in commonly applied quality metrics such as code coverage (up to 300% increase). However, on the other hand, there was no measurable improvement in the number of bugs actually found by developers. Our results not only cast some doubt on how the research community evaluates test generation tools, but also point to improvements and future work necessary before automated test generation tools will be widely adopted by practitioners. </p></div> 
            

            </div>
          ",Unit testing; automated test generation; branch coverage; empirical software engineering
Achieving scalable mutation-based generation of whole test suites,Springer,Achieving scalable mutation-based generation of whole test suites,"Fraser, Gordon, and Andrea Arcuri",34," <i>Empirical Software Engineering</i> 20, no. 3 (2015): 783-812.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Without complete formal specification, automatically generated software tests need to be manually checked in order to detect faults. This makes it desirable to produce the strongest possible test set while keeping the number of tests as small as possible. As commonly applied coverage criteria like branch coverage are potentially weak, mutation testing has been proposed as a stronger criterion. However, mutation based test generation is hampered because usually there are simply too many mutants, and too many of these are either trivially killed or equivalent. On such mutants, any effort spent on test generation would per definition be wasted. To overcome this problem, our search-based E<span class=""EmphasisTypeSmallCaps "">vo</span>S<span class=""EmphasisTypeSmallCaps "">uite</span> test generation tool integrates two novel optimizations: First, we avoid redundant test executions on mutants by monitoring state infection conditions, and second we use whole test suite generation to optimize test suites towards killing the highest number of mutants, rather than selecting individual mutants. These optimizations allowed us to apply E<span class=""EmphasisTypeSmallCaps "">vo</span>S<span class=""EmphasisTypeSmallCaps "">uite</span> to a random sample of 100 open source projects, consisting of a total of 8,963 classes and more than two million lines of code, leading to a total of 1,380,302 mutants. The experiment demonstrates that our approach scales well, making mutation testing a viable test criterion for automated test case generation tools, and allowing us to analyze the relationship of branch coverage and mutation testing in detail.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Test case generation&nbsp;</span><span class=""Keyword"">Search-based testing&nbsp;</span><span class=""Keyword"">Testing classes&nbsp;</span><span class=""Keyword"">Unit testing&nbsp;</span>"
Automated oracle data selection support,ieeexplore,Automated oracle data selection support,"Gay, Gregory, Matt Staats, Michael Whalen, and Mats PE Heimdahl",6," <i>IEEE Transactions on Software Engineering</i> 41, no. 11 (2015): 1119-1137.","The choice of test oracle-the artifact that determines whether an application under test executes correctly-can significantly impact the effectiveness of the testing process. However, despite the prevalence of tools that support test input selection, little work exists for supporting oracle creation. We propose a method of supporting test oracle creation that automatically selects the oracle data-the set of variables monitored during testing-for expected value test oracles. This approach is based on the use of mutation analysis to rank variables in terms of fault-finding effectiveness, thus automating the selection of the oracle data. Experimental results obtained by employing our method over six industrial systems (while varying test input types and the number of generated mutants) indicate that our method-when paired with test inputs generated either at random or to satisfy specific structural coverage criteria-may be a cost-effective approach for producing small, effective oracle data sets, with fault finding improvements over current industrial best practice of up to 1,435 percent observed (with typical improvements of up to 50 percent).",
The risks of coverage-directed test case generation,ieeexplore,The risks of coverage-directed test case generation,"Gay, Gregory, Matt Staats, Michael Whalen, and Mats PE Heimdahl",23," <i>IEEE Transactions on Software Engineering</i> 41, no. 8 (2015): 803-819.","A number of structural coverage criteria have been proposed to measure the adequacy of testing efforts. In the avionics and other critical systems domains, test suites satisfying structural coverage criteria are mandated by standards. With the advent of powerful automated test generation tools, it is tempting to simply generate test inputs to satisfy these structural coverage criteria. However, while techniques to produce coverage-providing tests are well established, the effectiveness of such approaches in terms of fault detection ability has not been adequately studied. In this work, we evaluate the effectiveness of test suites generated to satisfy four coverage criteria through counterexample-based test generation and a random generation approach-where tests are randomly generated until coverage is achieved-contrasted against purely random test suites of equal size. Our results yield three key conclusions. First, coverage criteria satisfaction alone can be a poor indication of fault finding effectiveness, with inconsistent results between the seven case examples (and random test suites of equal size often providing similar-or even higher-levels of fault finding). Second, the use of structural coverage as a supplement-rather than a target-for test generation can have a positive impact, with random test suites reduced to a coverage-providing subset detecting up to 13.5 percent more faults than test suites generated specifically to achieve coverage. Finally, Observable MC/DC, a criterion designed to account for program structure and the selection of the test oracle, can-in part-address the failings of traditional structural coverage criteria, allowing for the generation of test suites achieving higher levels of fault detection than random test suites of equal size. These observations point to risks inherent in the increase in test automation in critical systems, and the need for more research in how coverage criteria, test generation approaches, the test oracle used, and system structure jointly influence test effectiveness.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Software Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Software Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.System Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">System Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Comparing non-adequate test suites using coverage criteria,acm,Comparing non-adequate test suites using coverage criteria,"Gligoric, Milos, Alex Groce, Chaoqiang Zhang, Rohan Sharma, Mohammad Amin Alipour, and Darko Marinov",71," In <i>Proceedings of the 2013 International Symposium on Software Testing and Analysis</i>, pp. 302-313. ACM, 2013.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> A fundamental question in software testing research is how to compare test suites, often as a means for comparing test-generation techniques. Researchers frequently compare test suites by measuring their coverage. A coverage criterion C provides a set of test requirements and measures how many requirements a given suite satisfies. A suite that satisfies 100% of the (feasible) requirements is C-adequate. </p> <p> Previous rigorous evaluations of coverage criteria mostly focused on such adequate test suites: given criteria C and C′, are C-adequate suites (on average) more effective than C′-adequate suites? However, in many realistic cases producing adequate suites is impractical or even impossible. We present the first extensive study that evaluates coverage criteria for the common case of non-adequate test suites: given criteria C and C′, which one is better to use to compare test suites? Namely, if suites T1, T2 . . . Tn have coverage values c1, c2 . . . cn for C and c′1, c′2 . . . c′n for C′, is it better to compare suites based on c1, c2 . . . cn or based on c′1, c′ 2 . . . c′n? </p> <p> We evaluate a large set of plausible criteria, including statement and branch coverage, as well as stronger criteria used in recent studies. Two criteria perform best: branch coverage and an intra-procedural acyclic path coverage. </p></div> 
            

            </div>
          ",Coverage criteria; non-adequate test suites
Prioritizing tests for fault localization through ambiguity group reduction,acm,Prioritizing tests for fault localization through ambiguity group reduction,"Gonzalez-Sanchez, Alberto, Rui Abreu, Hans-Gerhard Gross, and Arjan JC van Gemund",36," In <i>Proceedings of the 2011 26th IEEE/ACM International Conference on Automated Software Engineering</i>, pp. 83-92. IEEE Computer Society, 2011.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">In practically all development processes, regression tests are used to detect the presence of faults after a modification. If faults are detected, a fault localization algorithm can be used to reduce the manual inspection cost. However, while using test case prioritization to enhance the rate of fault detection of the test suite (e.g., statement coverage), the diagnostic information gain per test is not optimal, which results in needless inspection cost during diagnosis. We present RAPTOR, a test prioritization algorithm for fault localization, based on reducing the similarity between statement execution patterns as the testing progresses. Unlike previous diagnostic prioritization algorithms, RAPTOR does not require false negative information, and is much less complex. Experimental results from the Software Infrastructure Repository's benchmarks show that RAPTOR is the best technique under realistic conditions, with average cost reductions of 40% with respect to the next best technique, with negligible impact on fault detection capability.</div> 
            

            </div>
          ",
Code coverage for suite evaluation by developers,acm,Code coverage for suite evaluation by developers,"Gopinath, Rahul, Carlos Jensen, and Alex Groce",39," In <i>Proceedings of the 36th International Conference on Software Engineering</i>, pp. 72-82. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> One of the key challenges of developers testing code is determining a test suite's quality -- its ability to find faults. The most common approach is to use code coverage as a measure for test suite quality, and diminishing returns in coverage or high absolute coverage as a stopping rule. In testing research, suite quality is often evaluated by a suite's ability to kill mutants (artificially seeded potential faults). Determining which criteria best predict mutation kills is critical to practical estimation of test suite quality. Previous work has only used small sets of programs, and usually compares multiple suites for a single program. Practitioners, however, seldom compare suites --- they evaluate one suite. Using suites (both manual and automatically generated) from a large set of real-world open-source projects shows that evaluation results differ from those for suite-comparison: statement (not block, branch, or path) coverage predicts mutation kills best. </p></div> 
            

            </div>
          ",evaluation of coverage criteria; statistical analysis; test frameworks
Test inspected unit or inspect unit tested code?,ieeexplore,Test inspected unit or inspect unit tested code?,"Gupta, Atul, and Pankaj Jalote",9," In <i>Empirical Software Engineering and Measurement, 2007. ESEM 2007. First International Symposium on</i>, pp. 51-60. IEEE, 2007.","Code inspection and unit testing are two popular fault- detecting techniques at unit level. Organizations where inspections are done generally supplement it with unit testing, as both are complementary. A natural question is the order in which the two techniques should be exercised as this may impact the overall effectiveness and efficiency of the verification process. In this paper, we present a controlled experiment comparing the two execution-orders, namely, code inspection followed by unit testing (CI-UT) and unit testing followed by code inspection (UT-CI), performed by a group of fresh software engineers in a company. The subjects inspected program-units by traversing a set of usage scenarios and applied unit testing by writing JUnit tests for the same. Our results showed that unit testing can be more effective, as well as more efficient, if applied after code inspection whereas the later is unaffected of the execution- order. Overall results suggest that sequence CI-UT performs better than UT-CI in time-constrained situations.",
On-demand test suite reduction,acm,Test-suite augmentation for evolving software,"Santelices, Raul, Pavan Kumar Chittimalli, Taweesup Apiwattanapong, Alessandro Orso, and Mary Jean Harrold",49," In <i>Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering</i>, pp. 218-227. IEEE Computer Society, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Most test suite reduction techniques aim to select, from a given test suite, a minimal representative subset of test cases that retains the same code coverage as the suite. Empirical studies have shown, however, that test suites reduced in this manner may lose fault detection capability. Techniques have been proposed to retain certain redundant test cases in the reduced test suite so as to reduce the loss in fault-detection capability, but these still do concede some degree of loss. Thus, these techniques may be applicable only in cases where loose demands are placed on the upper limit of loss in fault-detection capability. In this work we present an on-demand test suite reduction approach, which attempts to select a representative subset satisfying the same test requirements as an initial test suite conceding at most l% loss in fault-detection capability for at least c% of the instances in which it is applied. Our technique collects statistics about loss in fault-detection capability at the level of individual statements and models the problem of test suite reduction as an integer linear programming problem. We have evaluated our approach in the contexts of three scenarios in which it might be used. Our results show that most test suites reduced by our approach satisfy given fault detection capability demands, and that the approach compares favorably with an existing test suite reduction approach. </p></div> 
            

            </div>
          ",
A unified test case prioritization approach,acm,A unified test case prioritization approach,"Hao, Dan, Lingming Zhang, Lu Zhang, Gregg Rothermel, and Hong Mei",30," <i>ACM Transactions on Software Engineering and Methodology (TOSEM)</i> 24, no. 2 (2014): 10.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Test case prioritization techniques attempt to reorder test cases in a manner that increases the rate at which faults are detected during regression testing. Coverage-based test case prioritization techniques typically use one of two overall strategies: a <i>total strategy</i> or an <i>additional strategy</i>. These strategies prioritize test cases based on the total number of code (or code-related) elements covered per test case and the number of additional (not yet covered) code (or code-related) elements covered per test case, respectively. In this article, we present a unified test case prioritization approach that encompasses both the total and additional strategies. Our unified test case prioritization approach includes two models (<i>basic</i> and <i>extended</i>) by which a spectrum of test case prioritization techniques ranging from a purely total to a purely additional technique can be defined by specifying the value of a parameter referred to as the <i>f</i><sub><i>p</i></sub> value. To evaluate our approach, we performed an empirical study on 28 Java objects and 40 C objects, considering the impact of three internal factors (model type, choice of<i>f</i><sub><i>p</i></sub> value, and coverage type) and three external factors (coverage granularity, test case granularity, and programming/testing paradigm), all of which can be manipulated by our approach. Our results demonstrate that a wide range of techniques derived from our basic and extended models with uniform <i>f</i><sub><i>p</i></sub> values can outperform purely total techniques and are competitive with purely additional techniques. Considering the influence of each internal and external factor studied, the results demonstrate that various values of each factor have nontrivial influence on test case prioritization techniques.</p></div> 
            

            </div>
          ",http://dl.acm.org/ft_gateway.cfm?id=2685614&type=pdf
Strong higher order mutation-based test data generation,acm,Strong higher order mutation-based test data generation,"Harman, Mark, Yue Jia, and William B. Langdon",103," In <i>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering</i>, pp. 212-222. ACM, 2011.","This paper introduces SHOM, a mutation-based test data generation approach that combines Dynamic Symbolic Execution and Search Based Software Testing. SHOM targets strong mutation adequacy and is capable of killing both first and higher order mutants. We report the results of an empirical study using 17 programs, including production industrial code from ABB and Daimler and open source code as well as previously studied subjects. SHOM achieved higher strong mutation adequacy than two recent mutation-based test data generation approaches, killing between 8% and 38% of those mutants left unkilled by the best performing previous approach.",mutation testing; test data generation
Analysing the effectiveness of rule-coverage as a reduction criterion for test suites of grammar-based software,Springer,Analysing the effectiveness of rule-coverage as a reduction criterion for test suites of grammar-based software,"Hennessy, Mark, and James F. Power",13," <i>Empirical Software Engineering</i> 13, no. 4 (2008): 343-368.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">The term <em class=""EmphasisTypeItalic "">grammar-based software</em> describes software whose input can be specified by a context-free grammar. This grammar may occur explicitly in the software, in the form of an input specification to a parser generator, or implicitly, in the form of a hand-written parser. Grammar-based software includes not only programming language compilers, but also tools for program analysis, reverse engineering, software metrics and documentation generation. Hence, ensuring their completeness and correctness is a vital prerequisite for their use. In this paper we propose a strategy for the construction of test suites for grammar based software, and illustrate this strategy using the ISO C<sup> + + </sup> grammar. We use the concept of grammar-rule coverage as a pivot for the reduction of an implementation-based test suite, and demonstrate a significant decrease in the size of this suite. The effectiveness of this reduced test suite is compared to the original test suite with respect to code coverage and more importantly, fault detection. This work greatly expands upon previous work in this area and utilises large scale mutation testing to compare the effectiveness of grammar-rule coverage to that of statement coverage as a reduction criterion for test suites of grammar-based software. This work finds that when grammar rule coverage is used as the sole criterion for reducing test suites of grammar based software, the fault detection capability of that reduced test suite is greatly diminished when compared to other coverage criteria such as statement coverage.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Software testing&nbsp;</span><span class=""Keyword"">Grammar-based software&nbsp;</span><span class=""Keyword"">Test suite reduction&nbsp;</span><span class=""Keyword"">Rule coverage&nbsp;</span><span class=""Keyword"">Mutation testing&nbsp;</span>"
Why does my spreadsheet compute wrong values?,ieeexplore,Why does my spreadsheet compute wrong values?,"Hofer, Birgit, and Franz Wotawa",6," In <i>Software Reliability Engineering (ISSRE), 2014 IEEE 25th International Symposium on</i>, pp. 112-121. IEEE, 2014.","Spreadsheets are by far the most used programs that are written by end-users. They often build the basis for decisions in companies and governmental organizations and therefore they have a high impact on our daily life. Ensuring correctness of spreadsheets is thus an important task. But what happens after detecting a faulty behavior? This question has not been sufficiently answered. Therefore, we focus on fault localization techniques for spreadsheets. In this paper, we introduce a novel dependency-based approach for model-based fault localization in spreadsheets. This approach improves diagnostic accuracy while keeping computation times short, thus making the automated fault localization more appropriate for practical applications. The presented approach allows for an acceptable fault localization time of less than a second, and reduces the number of computed root cause candidates by 15 % on average, when compared with another dependency-based approach.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Fault Localization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Fault Localization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Spreadsheet Debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Spreadsheet Debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-Based Software Debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-Based Software Debugging</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
On the empirical evaluation of similarity coefficients for spreadsheets fault localization,Springer,On the empirical evaluation of similarity coefficients for spreadsheets fault localization,"Hofer, Birgit, Alexandre Perez, Rui Abreu, and Franz Wotawa",19," <i>Automated Software Engineering</i> 22, no. 1 (2015): 47-74.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Spreadsheets are by far the most prominent example of end-user programs of ample size and substantial structural complexity. They are usually not thoroughly tested so they often contain faults. Debugging spreadsheets is a hard task due to the size and structure, which is usually not directly visible to the user, i.e., the functions are hidden and only the computed values are presented. A way to locate faulty cells in spreadsheets is by adapting software debugging approaches for traditional procedural or object-oriented programming languages. One of such approaches is spectrum-based fault localization (<span class=""EmphasisTypeSmallCaps "">Sfl</span>). In this paper, we study the impact of different similarity coefficients on the accuracy of <span class=""EmphasisTypeSmallCaps "">Sfl</span> applied to the spreadsheet domain. Our empirical evaluation shows that three of the 42 studied coefficients (Ochiai, Jaccard and Sorensen-Dice) require less effort by the user while inspecting the diagnostic report, and can also be used interchangeably without a loss of accuracy. In addition, we illustrate the influence of the number of correct and incorrect output cells on the diagnostic report.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">End-user debugging&nbsp;</span><span class=""Keyword"">Spreadsheets&nbsp;</span><span class=""Keyword"">Similarity coefficients&nbsp;</span><span class=""Keyword""> Spectrum-based fault localization&nbsp;</span>"
State-based testing: Industrial evaluation of the cost-effectiveness of round-trip path and sneak-path strategies,ieeexplore,State-based testing: Industrial evaluation of the cost effectiveness of round-trip path and sneak-path testing strategies,"Torkar, Richard",3, In <i>International Symposium on Software Reliability Engineering (ISSRE)</i>. 2012.,"In the context of safety-critical software development, one important step in ensuring safe behavior is conformance testing, i.e., checking compliance between expected behavior and implementation. Round-trip path testing (RTP) is one example of conformance testing. Another essential step, however, is sneak-path testing, that is testing of how software reacts to unexpected events for a particular system state. Despite the importance of being systematic while testing, all testing activities take place, even for safety-critical software, under resource constraints. In this paper, we present an empirical evaluation of the cost-effectiveness of RTP when combined with sneak-path testing in the context of an industrial control system. Results highlight the importance of sneak-path testing since unexpected behavior is shown to be difficult to detect by other common, state-based test strategies. Results also suggest that sneak-path testing is a cost-effective supplement to RTP.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.industrial case study.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">industrial case study</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Round-trip path testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Round-trip path testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.sneak-path testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">sneak-path testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.UML.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">UML</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.state-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">state-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.cost-effectiveness.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">cost-effectiveness</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated tool support.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated tool support</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical evaluation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical evaluation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
The impact of concurrent coverage metrics on testing effectiveness,ieeexplore,The impact of concurrent coverage metrics on testing effectiveness,"Hong, Shin, Matt Staats, Jaemin Ahn, Moonzoo Kim, and Gregg Rothermel",9," In <i>Software Testing, Verification and Validation (ICST), 2013 IEEE Sixth International Conference on</i>, pp. 232-241. IEEE, 2013.","When testing multithreaded programs, the number of possible thread interactions makes exploring all interactions infeasible in practice. In response, researchers have developed concurrent coverage metrics for multithreaded programs. These metrics allow them to estimate how well they have exercised concurrent program behavior, just as branch and statement coverage metrics do for sequential program testing. However, unlike sequential coverage metrics, the effectiveness of concurrent coverage metrics in testing remains largely unexamined. In this paper, we explore the relationship between concurrent coverage and fault detection effectiveness by studying the application of eight concurrent coverage metrics in testing nine concurrent programs. Our results show that existing concurrent coverage metrics are often moderate to strong predictors of concurrent testing effectiveness, and are generally reasonable targets for test suite generation. Nevertheless, their relative effectiveness as predictors and test generation targets varies across programs, and thus additional work is needed in this area.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.concurrent program.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">concurrent program</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.coverage metric.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">coverage metric</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Are concurrency coverage metrics effective for testing: a comprehensive empirical investigation,Wiley Online Library,Are concurrency coverage metrics effective for testing: a comprehensive empirical investigation,"Hong, Shin, Matt Staats, Jaemin Ahn, Moonzoo Kim, and Gregg Rothermel",4," <i>Software Testing, Verification and Reliability</i> 25, no. 4 (2015): 334-370.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">Summary</h2><p>Testing multithreaded programs is inherently challenging, as programs can exhibit numerous thread interactions. To help engineers test these programs cost-effectively, researchers have proposed concurrency coverage metrics. These metrics are intended to be used as predictors for testing effectiveness and provide targets for test generation. The effectiveness of these metrics, however, remains largely unexamined. In this work, we explore the impact of concurrency coverage metrics on testing effectiveness and examine the relationship between coverage, fault detection, and test suite size. We study eight existing concurrency coverage metrics and six new metrics formed by combining complementary metrics. Our results indicate that the metrics are moderate to strong predictors of testing effectiveness and effective at providing test generation targets. Nevertheless, metric effectiveness varies across programs, and even combinations of complementary metrics do not consistently provide effective testing. These results highlight the need for additional work on concurrency coverage metrics. Copyright © 2014 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test coverage metric; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">concurrent program</span></li>"
Applying interface-contract mutation in regression testing of component-based software,ieeexplore,Applying interface-contract mutation in regression testing of component-based software,"Hou, Shan-Shan, Lu Zhang, Tao Xie, Hong Mei, and Jia-Su Sun",21," In <i>Software Maintenance, 2007. ICSM 2007. IEEE International Conference on</i>, pp. 174-183. IEEE, 2007.","Regression testing, which plays an important role in software maintenance, usually relies on test adequacy criteria to select and prioritize test cases. However, with the wide use and reuse of black-box components, such as reusable class libraries and COTS components, it is challenging to establish test adequacy criteria for testing software systems built on components whose source code is not available. Without source code or detailed documents, the misunderstanding between the system integrators and component providers has become a main factor of causing faults in component-based software. In this paper, we apply mutation on interface contracts, which can describe the rights and obligations between component users and providers, to simulate the faults that may occur in this way of software development. The mutation adequacy score for killing the mutants of interface contracts can serve as a test adequacy criterion. We performed an experimental study on three subject systems to evaluate the proposed approach together with four other existing criteria. The experimental results show that our adequacy criterion is helpful for both selecting good-quality test cases and scheduling test cases in an order of exposing faults quickly in regression testing of component-based software.",
Coverage is not strongly correlated with test suite effectiveness,acm,Coverage is not strongly correlated with test suite effectiveness,"Inozemtseva, Laura, and Reid Holmes",134," In <i>Proceedings of the 36th International Conference on Software Engineering</i>, pp. 435-445. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> The coverage of a test suite is often used as a proxy for its ability to detect faults. However, previous studies that investigated the correlation between code coverage and test suite effectiveness have failed to reach a consensus about the nature and strength of the relationship between these test suite characteristics. Moreover, many of the studies were done with small or synthetic programs, making it unclear whether their results generalize to larger programs, and some of the studies did not account for the confounding influence of test suite size. In addition, most of the studies were done with adequate suites, which are are rare in practice, so the results may not generalize to typical test suites. </p> <p> We have extended these studies by evaluating the relationship between test suite size, coverage, and effectiveness for large Java programs. Our study is the largest to date in the literature: we generated 31,000 test suites for five systems consisting of up to 724,000 lines of source code. We measured the statement coverage, decision coverage, and modified condition coverage of these suites and used mutation testing to evaluate their fault detection effectiveness. </p> <p> We found that there is a low to moderate correlation between coverage and effectiveness when the number of test cases in the suite is controlled for. In addition, we found that stronger forms of coverage do not provide greater insight into the effectiveness of the suite. Our results suggest that coverage, while useful for identifying under-tested parts of a program, should not be used as a quality target because it is not a good indicator of test suite effectiveness. </p></div> 
            

            </div>
          ",Coverage; test suite effectiveness; test suite quality
Augmented dynamic symbolic execution,ieeexplore,DART: directed automated random testing,"Godefroid, Patrice, Nils Klarlund, and Koushik Sen",11," In <i>ACM Sigplan Notices</i>, vol. 40, no. 6, pp. 213-223. ACM, 2005.","Dynamic symbolic execution (DSE) can efficiently explore all simple paths through a program, reliably determining whether there are any program crashes or violations of assertions or code contracts. However, if such automated oracles do not exist, the traditional approach is to present the developer a small and representative set of tests in order to let him/her determine their correctness. Customer feedback on Microsoft's Pex tool revealed that users expect different values and also more values than those produced by Pex, which threatens the applicability of DSE in a scenario without automated oracles. Indeed, even though all paths might be covered by DSE, the resulting tests are usually not sensitive enough to make a good regression test suite. In this paper, we present augmented dynamic symbolic execution, which aims to produce representative test sets by augmenting path conditions with additional conditions that enforce target criteria such as boundary or mutation adequacy, or logical coverage criteria.",
Automated test case generation for FBD programs implementing reactor protection system software,Wiley Online Library,Automated test case generation for FBD programs implementing reactor protection system software,"Jee, Eunkyoung, Donghwan Shin, Sungdeok Cha, Jang‐Soo Lee, and Doo‐Hwan Bae",15," <i>Software Testing, Verification and Reliability</i> 24, no. 8 (2014): 608-628.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">SUMMARY</h2><p>Automated and effective testing for function block diagram (FBD) programs has become an important issue, as FBD is increasingly used in implementing safety-critical systems. This work describes an automated test case generation technique for FBD programs and its associated tool—FBDTester. Given an FBD program and desired test coverage criteria, FBDTester generates test requirements and invokes the Satisfiability Modulo Theories solver iteratively to derive a set of test cases. An industrial case study using reactor protection system software shows that the automatically generated test suites detected at least 82% of the known faults, whereas manually generated test cases only detected approximately 35%. Mutation analysis revealed that the automatically generated test suites substantially outperformed manually generated ones. Although test sequence generation requires some manual effort in the current FBDTester, it is apparent that the proposed approach significantly improves the efficiency and the reliability of FBD testing. Copyright © 2014 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">automated test case generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">function block diagram; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">SMT solver; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">programmable logic controller</span></li>"
Automated unit testing of a SCADA control software: an industrial case study based on action research,ieeexplore,Automated unit testing of a SCADA control software: an industrial case study based on action research,"Jolly, Shahnewaz Amin, Vahid Garousi, and Matt M. Eskandar",15," In <i>Software Testing, Verification and Validation (ICST), 2012 IEEE Fifth International Conference on</i>, pp. 400-409. IEEE, 2012.",We report in this case-study paper our experience and success story with a practical approach and tool for unit regression testing of a SCADA (Supervisory Control and Data Acquisition) software. The tool uses a black-box specification of the units under test to automatically generate NUnit test code. We then improved the test suite by white-box and mutation testing. The approach and tool were developed in an action-research project to test a commercial large-scale SCADA system called Rocket.,"
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.action research.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">action research</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.SCADA software.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">SCADA software</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.industrical case study.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">industrical case study</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Using machine learning techniques to detect metamorphic relations for programs without test oracles,ieeexplore,Using machine learning techniques to detect metamorphic relations for programs without test oracles,"Kanewala, Upulee, and James M. Bieman",21," In <i>Software Reliability Engineering (ISSRE), 2013 IEEE 24th International Symposium on</i>, pp. 1-10. IEEE, 2013.","Much software lacks test oracles, which limits automated testing. Metamorphic testing is one proposed method for automating the testing process for programs without test oracles. Unfortunately, finding the appropriate metamorphic relations required for use in metamorphic testing remains a labor intensive task, which is generally performed by a domain expert or a programmer. In this work we present a novel approach for automatically predicting metamorphic relations using machine learning techniques. Our approach uses a set of features developed using the control flow graph of a function for predicting likely metamorphic relations. We show the effectiveness of our method using a set of real world functions often used in scientific applications.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Support vector machines.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Support vector machines</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Metamorphic testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Metamorphic testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Metamorphic relation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Metamorphic relation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Machine learning.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Machine learning</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Scientific software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Scientific software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Test oracles.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Test oracles</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Decision trees.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Decision trees</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Search-based testing of relational schema integrity constraints across multiple database management systems,ieeexplore,Search-based testing of relational schema integrity constraints across multiple database management systems,"Kapfhammer, Gregory M., Phil McMinn, and Chris J. Wright",26," In <i>Software Testing, Verification and Validation (ICST), 2013 IEEE Sixth International Conference on</i>, pp. 31-40. IEEE, 2013.","There has been much attention to testing applications that interact with database management systems, and the testing of individual database management systems themselves. However, there has been very little work devoted to testing arguably the most important artefact involving an application supported by a relational database - the underlying schema. This paper introduces a search-based technique for generating database table data with the intention of exercising the integrity constraints placed on table columns. The development of a schema is a process open to flaws like any stage of application development. Its cornerstone nature to an application means that defects need to be found early in order to prevent knock-on effects to other parts of a project and the spiralling bug-fixing costs that may be incurred. Examples of such flaws include incomplete primary keys, incorrect foreign keys, and omissions of NOT NULL declarations. Using mutation analysis, this paper presents an empirical study evaluating the effectiveness of our proposed technique and comparing it against a popular tool for generating table data, DBMonster. With competitive or faster data generation times, our method outperforms DBMonster in terms of both constraint coverage and mutation score.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.relational databases.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">relational databases</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.search-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">search-based testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
On the round trip path testing strategy,ieeexplore,On the round trip path testing strategy,"Khalil, May, and Yvan Labiche",10," In <i>Software Reliability Engineering (ISSRE), 2010 IEEE 21st International Symposium on</i>, pp. 388-397. IEEE, 2010.","A number of techniques have been proposed for state-based testing. One well-known technique (criterion) is to traverse the graph representing the state machine and generate a so-called transition tree, in an attempt to exercise round trip paths, i.e., paths that start and end in the same state without any other repeating state. Several hypotheses are made when one uses this criterion: exercising paths in the tree, which do not always trigger complete round trip paths, is equivalent to covering round-trip paths; different traversal algorithms are equivalent. In this paper we investigate whether these assumptions hold in practice, and if they do not, we investigate their consequences. Results also lead us to propose a new transition tree construction algorithm that results in higher efficiency and lower cost.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.round trip path.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">round trip path</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.state based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">state based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Investigating the effectiveness of object-oriented testing strategies using the mutation method,Wiley Online Library,Investigating the effectiveness of object‐oriented testing strategies using the mutation method,"Kim, Sun‐Woo, John A. Clark, and John A. McDermid",86," <i>Software Testing, Verification and Reliability</i> 11, no. 4 (2001): 207-225.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>The mutation method assesses test quality by examining the ability of a test set to distinguish syntactic deviations representing specific types of faults from the program under test. This paper describes an empirical study performed to evaluate the effectiveness of object-oriented (OO) test strategies using the mutation method. The test sets for the experimental system are generated according to three selected OO test strategies and their effectiveness is compared by determining how well the developed test sets kill injected mutants derived from an established mutation system Mothra and the authors' own OO-specific mutation technique which is termed Class Mutation. Copyright © 2001 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">object-oriented testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Java; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Class Mutation</span></li>"
State coverage: a structural test adequacy criterion for behavior checking,acm,State coverage: a structural test adequacy criterion for behavior checking,"Koster, Ken, and David Kao",27," In <i>The 6th Joint Meeting on European software engineering conference and the ACM SIGSOFT symposium on the foundations of software engineering: companion papers</i>, pp. 541-544. ACM, 2007.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>We propose a new language-independent, structural test adequacy criterion called state coverage. State coverage measures whether unit-level tests check the outputs and side effects of a program.</p> <p>State coverage differs in several respects from existing test adequacy criteria, such as code coverage and mutation adequacy. Unlike other coverage-based criteria, state coverage measures the extent of checks of program behavior. And unlike existing fault-based criteria such as mutation adequacy, state coverage has been designed to be readily automated and to present users with easily understood test inadequacy reports.</p> <p>An experiment showed strong positive correlations between the number of behavior checks and both state coverage and mutation adequacy.</p></div> 
            

            </div>
          ",
Empirically evaluating the quality of automatically generated and manually written test suites,ieeexplore,Empirically evaluating the quality of automatically generated and manually written test suites,"Kracht, Jeshua S., Jacob Z. Petrovic, and Kristen R. Walcott-Justice",7," In <i>Quality Software (QSIC), 2014 14th International Conference on</i>, pp. 256-265. IEEE, 2014.","The creation, execution, and maintenance of tests are some of the most expensive tasks in software development. To help reduce the cost, automated test generation tools can be used to assist and guide developers in creating test cases. Yet, the tests that automated tools produce range from simple skeletons to fully executable test suites, hence their complexity and quality vary. This paper compares the complexity and quality of test suites created by sophisticated automated test generation tools to that of developer-written test suites. The empirical study in this paper examines ten real-world programs with existing test suites and applies two state-of-the-art automated test generation tools. The study measures the resulting test suite quality in terms of code coverage and fault-finding capability. On average, manual tests covered 31.5% of the branches while the automated tools covered 31.8% of the branches. In terms of mutation score, the tests generated by automated tools had an average mutation score of 39.8% compared to the average mutation score of 42.1% for manually written tests. Even though automatically created tests often contain more lines of source code than those written by developers, this paper's empirical results reveal that test generation tools can provide value by creating high quality test suites while reducing the cost and effort needed for testing.",
Test Case Prioritization Based on Information Retrieval Concepts,ieeexplore,Test case prioritization based on information retrieval concepts,"Kwon, Jung-Hyun, In-Young Ko, Gregg Rothermel, and Matt Staats",2," In <i>Software Engineering Conference (APSEC), 2014 21st Asia-Pacific</i>, vol. 1, pp. 19-26. IEEE, 2014.","In regression testing, running all a system's test cases can require a great deal of time and resources. Test case prioritization (TCP) attempts to schedule test cases to achieve goals such as higher coverage or faster fault detection. While code coverage-based approaches are typical in TCP, recent work has explored the use of additional information to improve effectiveness. In this work, we explore the use of Information Retrieval (IR) techniques to improve the effectiveness of TCP, particularly for testing infrequently tested code. Our approach considers the frequency at which elements have been tested, in additional to traditional coverage information, balancing these factors using linear regression modeling. Our empirical study demonstrates that our approach is generally more effective than both random and traditional code coverage-based approaches, with improvements in rate of fault detection of up to 4.7%.",
Design by contract to improve software vigilance,ieeexplore,Design by contract to improve software vigilance,"Le Traon, Yves, Benoit Baudry, and J-M. Jézéquel",76," <i>IEEE Transactions on Software Engineering</i> 32, no. 8 (2006): 571-586.","Design by contract is a lightweight technique for embedding elements of formal specification (such as invariants, pre and postconditions) into an object-oriented design. When contracts are made executable, they can play the role of embedded, online oracles. Executable contracts allow components to be responsive to erroneous states and, thus, may help in detecting and locating faults. In this paper, we define vigilance as the degree to which a program is able to detect an erroneous state at runtime. Diagnosability represents the effort needed to locate a fault once it has been detected. In order to estimate the benefit of using design by contract, we formalize both notions of vigilance and diagnosability as software quality measures. The main steps of measure elaboration are given, from informal definitions of the factors to be measured to the mathematical model of the measures. As is the standard in this domain, the parameters are then fixed through actual measures, based on a mutation analysis in our case. Several measures are presented that reveal and estimate the contribution of contracts to the overall quality of a system in terms of vigilance and diagnosability","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Object-oriented design methods.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Object-oriented design methods</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.programming by contract.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">programming by contract</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.diagnostics.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">diagnostics</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.metrics..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">metrics.</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Testing Security Policies: Going Beyond Functional Testing,ieeexplore,Testing security policies: going beyond functional testing,"Le Traon, Yves, Tejeddine Mouelhi, and Benoit Baudry",83," In <i>Software Reliability, 2007. ISSRE'07. The 18th IEEE International Symposium on</i>, pp. 93-102. IEEE, 2007.","While important efforts are dedicated to system functional testing, very few works study how to test specifically security mechanisms, implementing a security policy. This paper introduces security policy testing as a specific target for testing. We propose two strategies for producing security policy test cases, depending if they are built in complement of existing functional test cases or independently from them. Indeed, any security policy is strongly connected to system functionality: testing functions includes exercising many security mechanisms. However, testing functionality does not intend at putting to the test security aspects. We thus propose test selection criteria to produce tests from a security policy. To quantify the effectiveness of a set of test cases to detect security policy flaws, we adapt mutation analysis and define security policy mutation operators. A library case study, a 3-tiers architecture, is used to obtain experimental trends. Results confirm that security must become a specific target of testing to reach a satisfying level of confidence in security mechanisms.",
Generating test cases for XML-based Web component interactions using mutation analysis,ieeexplore,Generating test cases for XML-based Web component interactions using mutation analysis,"Lee, Suet Chun, and Jeff Offutt",95," In <i>Software Reliability Engineering, 2001. ISSRE 2001. Proceedings. 12th International Symposium on</i>, pp. 200-209. IEEE, 2001.","Web software systems are built using heterogeneous software components. They interact by passing messages that exchange data and activity state information. Such heterogeneous message transfers can be structured using the eXtensible Markup Language (XML), which allows a flexible common data exchange. Parsers have been developed to check the syntax of component interactions, but there are as yet no techniques for checking the semantic correctness of the interactions. The paper presents a technique for using mutation analysis to test the semantic correctness of XML-based component interactions. The Web software interactions are specified using an Interaction Specification Model (ISM) that consists of document type definitions, messaging specifications, and a set of constraints. Test cases are XML messages that are passed between the Web software components. Classes of interaction-specific mutation operators are introduced and applied to the ISM to generate mutant interactions and test cases.",
Minimization of randomized unit test cases,ieeexplore,Minimization of randomized unit test cases,"Lei, Yong, and James H. Andrews",54," In <i>Software Reliability Engineering, 2005. ISSRE 2005. 16th IEEE International Symposium on</i>, pp. 10-pp. IEEE, 2005.","We describe a framework for randomized unit testing, and give empirical evidence that generating unit test cases randomly and then minimizing the failing test cases results in significant benefits. Randomized generation of unit test cases (sequences of method calls) has been shown to allow high coverage and to be highly effective. However, failing test cases, if found, are often very long sequences of method calls. We show that Zeller and Hildebrandt's test case minimization algorithm significantly reduces the length of these sequences. We study the resulting benefits qualitatively and quantitatively, via a case study on found open-source data structures and an experiment on lab-built data structures",
A practical approach to testing GUI systems,Springer,A practical approach to testing GUI systems,"Li, Ping, Toan Huynh, Marek Reformat, and James Miller",26," <i>Empirical Software Engineering</i> 12, no. 4 (2007): 331-357.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">GUI systems are becoming increasingly popular thanks to their ease of use when compared against traditional systems. However, GUI systems are often challenging to test due to their complexity and special features. Traditional testing methodologies are not designed to deal with the complexity of GUI systems; using these methodologies can result in increased time and expense. In our proposed strategy, a GUI system will be divided into two abstract tiers—the component tier and the system tier. On the component tier, a flow graph will be created for each GUI component. Each flow graph represents a set of relationships between the pre-conditions, event sequences and post-conditions for the corresponding component. On the system tier, the components are integrated to build up a viewpoint of the entire system. Tests on the system tier will interrogate the interactions between the components. This method for GUI testing is simple and practical; we will show the effectiveness of this approach by performing two empirical experiments and describing the results found.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">GUI testing&nbsp;</span><span class=""Keyword"">Two-tierd testing&nbsp;</span><span class=""Keyword"">Testing&nbsp;</span><span class=""Keyword"">GUI&nbsp;</span><span class=""Keyword"">GUI component&nbsp;</span><span class=""Keyword"">Complete interaction sequence&nbsp;</span><span class=""Keyword"">Event sequence&nbsp;</span>"
An approach to test data generation for killing multiple mutants,ieeexplore,An approach to test data generation for killing multiple mutants,"Liu, Ming-Hao, You-Feng Gao, Jin-Hui Shan, Jiang-Hong Liu, Lu Zhang, and Jia-Su Sun",27," In <i>Software Maintenance, 2006. ICSM'06. 22nd IEEE International Conference on</i>, pp. 113-122. IEEE, 2006.","Software testing is an important technique for assurance of software quality. Mutation testing has been identified as a powerful fault-based technique for unit testing, and there has been some research on automatic generation of test data for mutation testing. However, existing approaches to this kind of test data generation usually generate test data according to one mutant at one time. Thus, more test data that are needed for achieving a given mutation score. In this paper, we propose a new approach to generating one test data according to multiple mutants that are mutated at the same location at one time. Thus, our approach can generate smaller test suite that can achieve the same mutation testing score. To evaluate our approach, we implemented a prototype tool based on our approach and carried out some preliminary experiments. The experimental results show that our approach is more cost-effective","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.adequacy criterion.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">adequacy criterion</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test data.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test data</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">generation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Model-Based Mutation Testing of Synchronous and Asynchronous Real-Time Systems,ieeexplore,Model-Based Mutation Testing of Synchronous and Asynchronous Real-Time Systems,"Lorber, Florian",1," In <i>Software Testing, Verification and Validation (ICST), 2015 IEEE 8th International Conference on</i>, pp. 1-2. IEEE, 2015.","A lot of systems nowadays, especially in safety-critical areas, have to comply to very strict real-time requirements. Deviation from the specified time behavior can lead to severe faults. Thus the components need to be thoroughly tested to ensure a high quality standard. Model-based testing is a popular technology for automatic and systematic test-case generation, where a system-under-test is tested for conformance with a model that specifies its intended behavior. Model-based mutation testing is a specific fault-oriented variant of model- based testing. In this variant of testing, the test case generation is guided by a mutant, an intentionally altered version of the original model that specifies a common modeling error, to generate a specific test case capable of identifying that error. In the presented thesis we investigate ways to apply model-based mutation testing to real-time applications. The plan is to investigate two specification languages: timed automata and timed contracts. We already developed an algorithm and an implementation for testing deterministic timed automata and a theory and implementation for untimed contracts. In the last year of the thesis we will concentrate on determinizing timed automata restricted to the bounded case, supporting the test-case generation from networks of timed automata and adding real-time support to our contract-based testing tool. The final step of the thesis will be the evaluation on industrial case studies.",
Mutation-based test-case prioritization in software evolution,ieeexplore,Mutation-based test-case prioritization in software evolution,"Lou, Yiling, Dan Hao, and Lu Zhang",6," In <i>Software Reliability Engineering (ISSRE), 2015 IEEE 26th International Symposium on</i>, pp. 46-57. IEEE, 2015.","During software evolution, to assure the software quality, test cases for an early version tend to be reused by its latter versions. As a large number of test cases may aggregate during software evolution, it becomes necessary to schedule the execution order of test cases so that the faults in the latter version may be detected as early as possible, which is test-case prioritization in software evolution. In this paper, we proposed a novel test-case prioritization approach for software evolution, which first uses mutation faults on the difference between the early version and the latter version to simulate real faults occurred in software evolution, and then schedules the execution order of test cases based on their fault-detection capability, which is defined based on mutation faults. In particular, we present two models on calculating fault-detection capability, which are statistics-based model and probability-based model. Moreover, we conducted an experimental study and found that our approach with the statistics-based model outperforms our approach with the probability-based model and the total statement coverage-based approach, and slightly outperforms the additional statement-coverage based approach in many cases. Furthermore, compared with the total or additional statement coverage-based approach, our approach with either the statistics-based model or the probability-based model tends to be stably effective when the difference on the source code between the early version and the latter version is non-trivial.",
Dodona: automated oracle data set selection,acm,Dodona: automated oracle data set selection,"Loyola, Pablo, Matt Staats, In-Young Ko, and Gregg Rothermel",11," In <i>Proceedings of the 2014 International Symposium on Software Testing and Analysis</i>, pp. 193-203. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Software complexity has increased the need for automated software testing. Most research on automating testing, however, has focused on creating test input data. While careful selection of input data is necessary to reach faulty states in a system under test, test oracles are needed to actually detect failures. In this work, we describe Dodona, a system that supports the generation of test oracles. Dodona ranks program variables based on the interactions and dependencies observed between them during program execution. Using this ranking, Dodona proposes a set of variables to be monitored, that can be used by engineers to construct assertion-based oracles. Our empirical study of Dodona reveals that it is more effective and efficient than the current state-of-the-art approach for generating oracle data sets, and can often yield oracles that are almost as effective as oracles hand-crafted by engineers without support. </p></div> 
            

            </div>
          ",empirical studies; test generation; test oracles
On random testing of image processing applications,ieeexplore,On random testing of image processing applications,"Mayer, Johannes, and Ralph Guderlei",28," In <i>Quality Software, 2006. QSIC 2006. Sixth International Conference on</i>, pp. 85-92. IEEE, 2006.","Testing image processing applications is a non-trivial task. Complex inputs have to be generated and complex test results have to be evaluated. In the present paper, models for random generation of images are proposed and compared. The study for their comparison uses mutants of one particular implementation of an image processing operator, namely an implementation of the Euclidean distance transform. Metamorphic relations, necessary properties, and special values are furthermore identified for this distance transform to enable automatic evaluation of test results. These criteria are also compared using mutation analysis. Based on the results, general hints are given on how to choose random models and automatically evaluate test results for testing in the field of image processing","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing oracle.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing oracle</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Metamorphic Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Metamorphic Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Random Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Random Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test data selection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test data selection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test evaluation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test evaluation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
An empirical analysis and comparison of random testing techniques,acm,An empirical analysis and comparison of random testing techniques,"Mayer, Johannes, and Christoph Schneckenburger",49," In <i>Proceedings of the 2006 ACM/IEEE international symposium on Empirical software engineering</i>, pp. 105-114. ACM, 2006.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">Testing with randomly generated test inputs, namely Random Testing, is a strategy that has been applied succefully in a lot of cases. Recently, some new adaptive approaches to the random generation of test cases have been proposed. Whereas there are many comparisons of Random Testing with Partition Testing, a systematic comparison of random testing techniques is still missing. This paper presents an empirical analysis and comparison of all random testing techniques from the field of Adaptive Random Testing (ART). The ART algorithms are compared for effectiveness using the mean F-measure, obtained through simulation and mutation analysis, and the P-measure. An interesting connection between the testing effectiveness measures F-measure and P-measure is described. The spatial distribution of test cases is determined to explain the behavior of the methods and identify possible shortcomings. Besides this, both the theoretical asymptotic runtime and the empirical runtime for each method are given.</div> 
            

            </div>
          ",adaptive random testing; f-measure; p-measure; random testing; runtime; testing effectiveness
The effectiveness of test coverage criteria for relational database schema integrity constraints,acm,The effectiveness of test coverage criteria for relational database schema integrity constraints,"Mcminn, Phil, Chris J. Wright, and Gregory M. Kapfhammer",9," <i>ACM Transactions on Software Engineering and Methodology (TOSEM)</i> 25, no. 1 (2015): 8.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Despite industry advice to the contrary, there has been little work that has sought to test that a relational database's schema has correctly specified integrity constraints. These critically important constraints ensure the coherence of data in a database, defending it from manipulations that could violate requirements such as “usernames must be unique” or “the host name cannot be missing or unknown.” This article is the first to propose coverage criteria, derived from logic coverage criteria, that establish different levels of testing for the formulation of integrity constraints in a database schema. These range from simple criteria that mandate the testing of successful and unsuccessful INSERT statements into tables to more advanced criteria that test the formulation of complex integrity constraints such as multi-column PRIMARY KEYs and arbitrary CHECK constraints. Due to different vendor interpretations of the structured query language (SQL) specification with regard to how integrity constraints should actually function in practice, our criteria crucially account for the underlying semantics of the database management system (DBMS). After formally defining these coverage criteria and relating them in a subsumption hierarchy, we present two approaches for automatically generating tests that satisfy the criteria. We then describe the results of an empirical study that uses mutation analysis to investigate the fault-finding capability of data generated when our coverage criteria are applied to a wide variety of relational schemas hosted by three well-known and representative DBMSs—HyperSQL, PostgreSQL, and SQLite. In addition to revealing the complementary fault-finding capabilities of the presented criteria, the results show that mutation scores range from as low as just 12% of mutants being killed with the simplest of criteria to 96% with the most advanced.</p></div> 
            

            </div>
          ",http://dl.acm.org/ft_gateway.cfm?id=2818639&type=pdf
Leveraging existing tests in automated test generation for web applications,acm,Leveraging existing tests in automated test generation for web applications,"Milani Fard, Amin, Mehdi Mirzaaghaei, and Ali Mesbah",21," In <i>Proceedings of the 29th ACM/IEEE international conference on Automated software engineering</i>, pp. 67-78. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>To test web applications, developers currently write test cases in frameworks such as Selenium. On the other hand, most web test generation techniques rely on a crawler to explore the dynamic states of the application. The first approach requires much manual effort, but benefits from the domain knowledge of the developer writing the test cases. The second one is automated and systematic, but lacks the domain knowledge required to be as effective. We believe combining the two can be advantageous. In this paper, we propose to (1) mine the human knowledge present in the form of input values, event sequences, and assertions, in the human-written test suites, (2) combine that inferred knowledge with the power of automated crawling, and (3) extend the test suite for uncovered/unchecked portions of the web application under test. Our approach is implemented in a tool called Testilizer. An evaluation of our approach indicates that Testilizer (1) outperforms a random test generator, and (2) on average, can generate test suites with improvements of up to 150% in fault detection rate and up to 30% in code coverage, compared to the original test suite.</p></div> 
            

            </div>
          ",automated test generation; test reuse; web applications
A case study in model-based testing of specifications and implementations,Wiley Online Library,A case study in model‐based testing of specifications and implementations,"Miller, Tim, and Paul Strooper",17," <i>Software Testing, Verification and Reliability</i> 22, no. 1 (2012): 33-63.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">SUMMARY</h2><p>Despite the existence of a number of animation tools for a variety of languages, methods for employing these tools for specification testing have not been adequately explored. Similarly, despite the close correspondence between specification testing and implementation testing, the two processes are often treated independently, and relatively little investigation has been performed to explore their relationship. This paper presents the results of applying a framework and method for the systematic testing of specifications and their implementations. This framework exploits the close correspondence between specification testing and implementation testing. The framework is evaluated on a sizable case study of the <em>Global System for Mobile Communications 11.11 Standard</em>, which has been developed towards use in a commercial application. The evaluation demonstrates that the framework is of similar cost-effectiveness to the BZ-Testing-Tools framework and more cost-effective than manual testing. A mutation analysis detected more than 95% of non-equivalent specification and implementation mutants. Copyright © 2010 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">specification animation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model-based testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">testgraphs</span></li>"
Effective test generation and adequacy assessment for JavaScript-based web applications,acm,Effective test generation and adequacy assessment for JavaScript-based web applications,"Mirshokraie, Shabnam",2," In <i>Proceedings of the 2014 International Symposium on Software Testing and Analysis</i>, pp. 453-456. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Modern web applications rely heavily on JavaScript and client-side runtime manipulation of the DOM (Document Object Model) tree. However, JavaScript is loosely typed, dynamic, and challenging to analyze and test. We propose an automated technique to generate regression test cases at two complementary levels: (1) individual JavaScript functions, and (2) DOM event sequences. Moreover, to assess the quality of the test cases we propose a mutation testing technique that leverages static and dynamic program analysis to guide the mutation generation process towards parts of the code that are error-prone or likely to influence the program's output. </p></div> 
            

            </div>
          ",JavaScript; Mutation Testing; Test generation
Ask the mutants: Mutating faulty programs for fault localization,ieeexplore,Ask the mutants: Mutating faulty programs for fault localization,"Moon, Seokhyeon, Yunho Kim, Moonzoo Kim, and Shin Yoo",33," In <i>Software Testing, Verification and Validation (ICST), 2014 IEEE Seventh International Conference on</i>, pp. 153-162. IEEE, 2014.","We present MUSE (MUtation-baSEd fault localization technique), a new fault localization technique based on mutation analysis. A key idea of MUSE is to identify a faulty statement by utilizing different characteristics of two groups of mutants-one that mutates a faulty statement and the other that mutates a correct statement. We also propose a new evaluation metric for fault localization techniques based on information theory, called Locality Information Loss (LIL): it can measure the aptitude of a localization technique for automated fault repair systems as well as human debuggers. The empirical evaluation using 14 faulty versions of the five real-world programs shows that MUSE localizes a fault after reviewing 7.4 statements on average, which is about 25 times more precise than the state-of-the-art SBFL technique Op2.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.fault localization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">fault localization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Static analysis of model transformations for effective test generation,ieeexplore,Static analysis of model transformations for effective test generation,"Mottu, Jean-Marie, Sagar Sen, Massimo Tisi, and Jordi Cabot",23," In <i>Software Reliability Engineering (ISSRE), 2012 IEEE 23rd International Symposium on</i>, pp. 291-300. IEEE, 2012.","Model transformations are an integral part of several computing systems that manipulate interconnected graphs of objects called models in an input domain specified by a metamodel and a set of invariants. Test models are used to look for faults in a transformation. A test model contains a specific set of objects, their interconnections and values for their attributes. Can we automatically generate an effective set of test models using knowledge from the transformation? We present a white-box testing approach that uses static analysis to guide the automatic generation of test inputs for transformations. Our static analysis uncovers knowledge about how the input model elements are accessed by transformation operations. This information is called the input metamodel footprint due to the transformation. We transform footprint, input metamodel, its invariants, and transformation pre-conditions to a constraint satisfaction problem in Alloy. We solve the problem to generate sets of test models containing traces of the footprint. Are these test models effective? With the help of a case study transformation we evaluate the effectiveness of these test inputs. We use mutation analysis to show that the test models generated from footprints are more effective (97.62% avg. mutation score) in detecting faults than previously developed approaches based on input domain coverage criteria (89.9% avg.) and unguided generation (70.1% avg.).","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.White Box Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">White Box Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-Driven Engineering.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-Driven Engineering</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model Transformation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model Transformation Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Alloy.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Alloy</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Automatic Model Completion.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Automatic Model Completion</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
"Assessing, comparing, and combining statechart-based testing and structural testing: An experiment",ieeexplore,"Assessing, comparing, and combining statechart-based testing and structural testing: An experiment","Mouchawrab, Samar, Lionel C. Briand, and Yvan Labiche",15," In <i>Empirical Software Engineering and Measurement, 2007. ESEM 2007. First International Symposium on</i>, pp. 41-50. IEEE, 2007.","Although models have been proven to be helpful in a number of software engineering activities there is still significant resistance to model-driven development. This paper investigates one specific aspect of this larger problem. It addresses the impact of using statecharts for testing class clusters that exhibit a state-dependent behavior. More precisely, it reports on a controlled experiment that investigates their impact on testing fault-detection effectiveness. Code-based, structural testing is compared to statechart-based testing and their combination is investigated to determine whether they are complementary. Results show that there is no significant difference between the fault detection effectiveness of the two test strategies but that they are significantly more effective when combined. This implies that a cost-effective strategy would specify statechart-based test cases early on, execute them once the source code is available, and then complete them with test cases based on code coverage analysis.",
"Assessing, comparing, and combining state machine-based testing and structural testing: a series of experiments",ieeexplore,"Assessing, Comparing, and Combining State machine-Based Testing and Structural Testing: A","Mouchawrab, Samar",58," PhD diss., Carleton University Ottawa, 2010.","A large number of research works have addressed the importance of models in software engineering. However, the adoption of model-based techniques in software organizations is limited since these models are perceived to be expensive and not necessarily cost-effective. Focusing on model-based testing, this paper reports on a series of controlled experiments. It investigates the impact of state machine testing on fault detection in class clusters and its cost when compared with structural testing. Based on previous work showing this is a good compromise in terms of cost and effectiveness, this paper focuses on a specific state-based technique: the round-trip paths coverage criterion. Round-trip paths testing is compared to structural testing, and it is investigated whether they are complementary. Results show that even when a state machine models the behavior of the cluster under test as accurately as possible, no significant difference between the fault detection effectiveness of the two test strategies is observed, while the two test strategies are significantly more effective when combined by augmenting state machine testing with structural testing. A qualitative analysis also investigates the reasons why test techniques do not detect certain faults and how the cost of state machine testing can be brought down.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.state machines..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">state machines.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.State-based software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">State-based software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.structural testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">structural testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.controlled experiments.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">controlled experiments</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Diagnosing new faults using mutants and prior faults (NIER track),acm,Diagnosing new faults using mutants and prior faults (NIER track),"Murtaza, Syed Shariyar, Nazim Madhavji, Mechelle Gittens, and Zude Li",7," In <i>Proceedings of the 33rd International Conference on Software Engineering</i>, pp. 960-963. ACM, 2011.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Literature indicates that 20% of a program's code is responsible for 80% of the faults, and 50-90% of the field failures are rediscoveries of previous faults. Despite this, identification of faulty code can consume 30-40% time of error correction. Previous fault-discovery techniques focusing on field failures either require many pass-fail traces, discover only crashing failures, or identify faulty ""files"" (which are of large granularity) as origin of the source code. In our earlier work (the F007 approach), we identify faulty ""functions"" (which are of small granularity) in a field trace by using earlier resolved traces of the same release, which limits it to the known faulty functions. This paper overcomes this limitation by proposing a new ""strategy"" to identify new and old faulty functions using F007. This strategy uses failed traces of mutants (artificial faults) and failed traces of prior releases to identify faulty functions in the traces of succeeding release. Our results on two UNIX utilities (i.e., Flex and Gzip) show that faulty functions in the traces of the majority (60-85%) of failures of a new software release can be identified by reviewing only 20% of the code. If compared against prior techniques then this is a notable improvement in terms of contextual knowledge required and accuracy in the discovery of finer-grain fault origin.</p></div> 
            

            </div>
          ",decision tree; execution traces; faulty function; mutants
The influence of size and coverage on test suite effectiveness,acm,The influence of size and coverage on test suite effectiveness,"Namin, Akbar Siami, and James H. Andrews",108," In <i>Proceedings of the eighteenth international symposium on Software testing and analysis</i>, pp. 57-68. ACM, 2009.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>We study the relationship between three properties of test suites: size, structural coverage, and fault-finding effectiveness. In particular, we study the question of whether achieving high coverage leads directly to greater effectiveness, or only indirectly through forcing a test suite to be larger. Our experiments indicate that coverage is sometimes correlated with effectiveness when size is controlled for, and that using both size and coverage yields a more accurate prediction of effectiveness than size alone. This in turn suggests that both size and coverage are important to test suite effectiveness. Our experiments also indicate that no linear relationship exists among the three variables of size, coverage and effectiveness, but that a nonlinear relationship does exist.</p></div> 
            

            </div>
          ",coverage criteria; statistical analysis
An evaluation of required element testing strategies,acm,An evaluation of required element testing strategies,"Ntafos, Simeon C",72," In <i>Proceedings of the 7th international conference on Software engineering</i>, pp. 250-256. IEEE Press, 1984.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>In this paper we discuss required element testing strategies and present some experimental evaluations of their effectiveness. These strategies use data flow analysis as a basis for developing test cases. The basic strategy (required pairs) is compared with random and branch testing using mutation analysis as a measure of test set effectiveness. Extensions of the basic strategy are also studied.</par></div> 
            

            </div>
          ",
On required element testing,ieeexplore,On required element testing,"Ntafos, Simeon C",240, <i>IEEE Transactions on Software Engineering</i> 6 (1984): 795-803.,"In this paper we introduce two classes of program testing strategies that consist of specifying a set of required elements for the program and then covering those elements with appropriate test inputs. In general, a required element has a structural and a functional component and is covered by a test case if the test case causes the features specified in the structural component to be executed under the conditions specified in the functional component. Data flow analysis is used to specify the structural component and data flow interactions are used as a basis for developing the functional component. The strategies are illustrated with examples and some experimental evaluations of their effectiveness are presented.",
Generating test data from SOFL specifications,Elsevier,Specification and testing of abstract data types,"Jalote, Pankaj",123," <i>Computer Languages</i> 17, no. 1 (1992): 75-82.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Software testing can only be formalized and quantified when a solid basis for test generation can be defined. Tests are commonly generated from the source code, control flow graphs, design representations, and specifications/requirements. Formal specifications represent a significant opportunity for testing because they precisely describe <span id=""mmlsi1"" class=""mathmlsrc""><img class=""imgLazyJSB inlineImage"" height=""19"" width=""35"" alt=""Full-size image (<1 K)"" title=""Full-size image (<1 K)"" src=""http://ars.els-cdn.com/content/image/1-s2.0-S0164121299000667-si1.gif"" data-inlimgeid=""1-s2.0-S0164121299000667-si1.gif"" data-loaded=""true"" style=""display: inline;""><noscript>&lt;img height=""19"" border=""0"" style=""vertical-align:bottom"" width=""35"" alt=""Full-size image (&lt;1 K)"" title=""Full-size image (&lt;1 K)"" src=""http://origin-ars.els-cdn.com/content/image/1-s2.0-S0164121299000667-si1.gif""&gt;</noscript><!--ja:math--></span> functions the software is supposed to provide in a form that can be easily manipulated. This paper presents a new method for generating tests from formal specifications. This method is comprehensive in specification coverage, applies at several levels of abstraction, and can be highly automated. The paper applies the method to SOFL specifications, describes the technique, and demonstrates the application on a case study. A preliminary evaluation using a code-level coverage criterion (mutation testing), indicates that the method can result in very effective tests.</p>","<li id="""" class=""svKeywords""><span id="""">Formal methods</span>; </li><li id="""" class=""svKeywords""><span id="""">Specification-based testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Software testing</span></li>"
Automatic mutation test case generation via dynamic symbolic execution,ieeexplore,Automatic mutation test case generation via dynamic symbolic execution,"Papadakis, Mike, and Nicos Malevris",71," In <i>Software reliability engineering (ISSRE), 2010 IEEE 21st international symposium on</i>, pp. 121-130. IEEE, 2010.","The automatic test case generation is the principal issue of the software testing activity. Dynamic symbolic execution appears to be a promising approach to this matter as it has been shown to be quite powerful in producing the sought tests. Despite its power, it has only been effectively applied to the entry level criteria of the structural criteria hierarchy such as branch testing. In this paper an extension of this technique is proposed in order to effectively generate test data based on mutation testing. The proposed approach conjoins program transformation and dynamic symbolic execution techniques in order to successfully automate the test generation process. The propositions made in this paper have been incorporated into an automated framework for producing mutation based test cases. Its evaluation on a set of benchmark programs suggests that it is able to produce tests capable of killing most of the non equivalent introduced mutants. The same study also provides some evidence that by employing efficient heuristics it can be possible to perform mutation with reasonable resources.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutant schemata.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutant schemata</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated test case generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated test case generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.dynamic symbolic execution.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">dynamic symbolic execution</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
"Automatically performing weak mutation with the aid of symbolic execution, concolic testing and search-based testing",Springer,"Automatically Performing Weak Mutation with the Aid of: Symbolic Execution, Concolic and Search Based Testing1","Papadakis, Mike, and Nicos Malevris",33,,"<h2 class=""Heading"">Abstract</h2><p class=""Para"">Automating software testing activities can increase the quality and drastically decrease the cost of software development. Toward this direction, various automated test data generation tools have been developed. The majority of existing tools aim at structural testing, while a quite limited number aim at a higher level of testing thoroughness such as mutation. In this paper, an attempt toward automating the generation of mutation-based test cases by utilizing existing automated tools is proposed. This is achieved by reducing the killing mutants’ problem into a covering branches one. To this extent, this paper is motivated by the use of state of the art techniques and tools suitable for covering program branches when performing mutation. Tools and techniques such as symbolic execution, concolic execution, and evolutionary testing can be easily adopted toward automating the test input generation activity for the weak mutation testing criterion by simply utilizing a special form of the mutant schemata technique. The propositions made in this paper integrate three automated tools in order to illustrate and examine the method’s feasibility and effectiveness. The obtained results, based on a set of Java program units, indicate the applicability and effectiveness of the suggested technique. The results advocate that the proposed approach is able to guide existing automating tools in producing test cases according to the weak mutation testing criterion. Additionally, experimental results with the proposed mutation testing regime show that weak mutation is able to speedup the mutant execution time by at least 4.79 times when compared with strong mutation.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Weak mutation&nbsp;</span><span class=""Keyword"">Automated test case generation&nbsp;</span><span class=""Keyword"">Mutant schemata&nbsp;</span><span class=""Keyword"">Symbolic execution&nbsp;</span><span class=""Keyword"">Concolic execution&nbsp;</span><span class=""Keyword"">Search-based testing&nbsp;</span>"
Mutation based test case generation via a path selection strategy,Elsevier,Mutation based test case generation via a path selection strategy,"Papadakis, Mike, and Nicos Malevris",43," <i>Information and Software Technology</i> 54, no. 9 (2012): 915-932.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><h4 id=""absSec_1"">Context</h4><p id=""sp005"">Generally, mutation analysis has been identified as a powerful testing method. Researchers have shown that its use as a testing criterion exercises quite thoroughly the system under test while it achieves to reveal more faults than standard structural testing criteria. Despite its potential, mutation fails to be adopted in a widespread practical use and its popularity falls significantly short when compared with other structural methods. This can be attributed to the lack of thorough studies dealing with the practical problems introduced by mutation and the assessment of the effort needed when applying it. Such an incident, masks the real cost involved preventing the development of easy and effective to use strategies to circumvent this problem.</p><h4 id=""absSec_2"">Objective</h4><p id=""sp010"">In this paper, a path selection strategy for selecting test cases able to effectively kill mutants when performing weak mutation testing is presented and analysed.</p><h4 id=""absSec_3"">Method</h4><p id=""sp015"">The testing effort is highly correlated with the number of attempts the tester makes in order to generate adequate test cases. Therefore, a significant influence on the efficiency associated with a test case generation strategy greatly depends on the number of candidate paths selected in order to achieve a predefined coverage goal. The effort can thus be related to the number of infeasible paths encountered during the test case generation process.</p><h4 id=""absSec_4"">Results</h4><p id=""sp020"">An experiment, investigating well over 55 million of program paths is conducted based on a strategy that alleviates the effects of infeasible paths. Strategy details, along with a prototype implementation are reported and analysed through the experimental results obtained by its employment to a set of program units.</p><h4 id=""absSec_5"">Conclusion</h4><p id=""sp025"">The results obtained suggest that the strategy used can play an important role in making the mutation testing method more appealing and practical.</p>","<li id="""" class=""svKeywords""><span id="""">Software testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Unit testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Path testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Adequacy criterion</span>; </li><li id="""" class=""svKeywords""><span id="""">Infeasible paths</span></li>"
"Using mutants to locate ""unknown"" faults",ieeexplore,Using mutants to locat,"Papadakis, Mike, and Yves Le Traon",32, unknown,"Many fault localization techniques operate by crosscutting coverage information of passed and failed test executions. Generally, their accuracy depends on the utilized coverage elements and on the selected test cases. This paper proposes a novel fault localization method using mutation and investigates its accuracy when using classical test selection criteria such as mutation, branch and block. A controlled experiment shows that (1) the mutation based approach is quite effective at identifying ""unknown"" faulty program statements. Additionally, the experimental results reveal (2) that the mutation-based test suites are significantly more effective at supporting fault localization than block or branch-based test suites. Further, (3) evidence in support of facilitating mutation alternatives, such as mutant sampling, in order to diminish mutation overheads is also given.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.fault localization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">fault localization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation analysis</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Sampling program inputs with mutation analysis: Going beyond combinatorial interaction testing,ieeexplore,Sampling program inputs with mutation analysis: Going beyond combinatorial interaction testing,"Papadakis, Mike, Christopher Henard, and Yves Le Traon",18," In <i>Software Testing, Verification and Validation (ICST), 2014 IEEE Seventh International Conference on</i>, pp. 1-10. IEEE, 2014.","Modern systems tend to be highly configurable. Testing such systems requires selecting test cases from a large input space. Thus, there is a need to systematically sample program inputs in order to reduce the testing effort. In such cases, testing the interactions between program parameters has been identified as an effective way to deal with this problem. In these lines, Combinatorial Interaction Testing (CIT) models the program input interactions and uses this model to select test cases. Going a step further, we apply mutation analysis on the CIT input model to select program test cases. Mutation operates by injecting defects to the program input model and measures the number of defects found by the selected test cases. Experiments performed on four real programs show that measuring the number of model-based defects gives a stronger correlation to code-level faults than measuring the number of the exercised interactions. Therefore, the proposed mutation analysis approach forms a valid and more effective alternative to CIT.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Fault Detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Fault Detection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Combinatorial Interaction Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Combinatorial Interaction Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Metallaxis-FL: mutation-based fault localization,Wiley Online Library,Metallaxis‐FL: mutation‐based fault localization,"Papadakis, Mike, and Yves Le Traon",38," <i>Software Testing, Verification and Reliability</i> 25, no. 5-7 (2015): 605-628.","Fault localization methods seek to identify faulty program statements based on the information provided by the failing and passing test executions. Spectrum-based methods are among the most popular ones and assist programmers by assigning suspiciousness values on program statements according to their probability of being faulty. This paper proposes Metallaxis, a fault localization approach based on mutation analysis. The innovative part of Metallaxis is that it uses mutants and links them with the faulty program places. Thus, mutants that are killed mostly by failing tests provide a good indication about the location of a fault. Experimentation using Metallaxis suggests that it is significantly more effective than statement-based approaches. This is true even in the case where mutation cost-reduction techniques, such as mutant sampling, are facilitated. Additionally, results from a controlled experiment show that the use of mutation as a testing technique provides benefits to the fault localization process. Therefore, fault localization is significantly improved by using mutation-based tests instead of block-based or branch-based test suites. Finally, evidence in support of the methods’ scalability is also given.","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">debugging; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault localization</span></li>"
Subdomain-based test data generation,Elsevier,Subdomain-based test data generation,"Patrick, Matthew, Rob Alexander, Manuel Oriol, and John A. Clark",4, <i>Journal of Systems and Software</i> 103 (2015): 328-342.,"<h2 class=""secHeading"" id=""author-highlightsabsh0011"">Highlights</h2><p id=""spara0005""></p><dl class=""listitem"" id=""list_celist0004""><dt class=""label"">•</dt><dd><p id=""para0001"">We optimise subdomains for input regions that are more likely to reveal faults.</p></dd><dt class=""label"">•</dt><dd><p id=""para0002"">This reduces the number of test cases required to achieve a high mutation score.</p></dd><dt class=""label"">•</dt><dd><p id=""para0003"">Subdomains also reveal information about the behaviour of the program under test.</p></dd><dt class=""label"">•</dt><dd><p id=""para0004"">Information provided by subdomains helps to reduce the effort needed to create oracles.</p></dd></dl><p></p>","<li id=""key0002"" class=""svKeywords""><span id=""cetext0001"">Search based testing</span>; </li><li id=""key0003"" class=""svKeywords""><span id=""cetext0002"">Input distributions</span>; </li><li id=""key0004"" class=""svKeywords""><span id=""cetext0003"">Evolution strategy</span></li>"
"Techniques and tools for the automatic generation of optimal test data at code, model and interface level",acm,"Techniques and tools for the automatic generation of optimal test data at code, model and interface level","Pinte, Florin, Norbert Oster, and Francesca Saglietti",17," In <i>Companion of the 30th international conference on Software engineering</i>, pp. 927-928. ACM, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>This article presents two different tools automating the generation of optimized test data for unit, model-based and integration testing by maximizing the coverage and minimizing the number of test cases required. To cope with these conflicting goals, hybrid self-adaptive and multi-objective evolutionary algorithms were applied. The efficiency was demonstrated by evaluating fault detection capability by mutation testing. Thanks to the effort reduction offered, the approach is particularly suitable for the verification of complex, safety-relevant software systems.</p></div> 
            

            </div>
          ",genetic algorithms; optimal test data generation
Model-based tests for access control policies,ieeexplore,Model-based tests for access control policies,"Pretschner, Alexander, Tejeddine Mouelhi, and Yves Le Traon",71," In <i>Software Testing, Verification, and Validation, 2008 1st International Conference on</i>, pp. 338-347. IEEE, 2008.","We present a model-based approach to testing access control requirements. By using combinatorial testing, we first automatically generate test cases from and without access control policies—i.e., the model—and assess the effectiveness of the test suites by means of mutation testing. We also compare them to purely random tests. For some of the investigated strategies, non-random tests kill considerably more mutants thanthe same number of random tests. Since we rely on policies only, no information on the application is required at this stage. As a consequence, our methodology applies to arbitrary implementations of the policy decision points.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Combinatorial Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Combinatorial Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Access Control.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Access Control</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-Based Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-Based Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Efficient automated program repair through fault-recorded testing prioritization,ieeexplore,Efficient automated program repair through fault-recorded testing prioritization,"Qi, Yuhua, Xiaoguang Mao, and Yan Lei",20," In <i>Software Maintenance (ICSM), 2013 29th IEEE International Conference on</i>, pp. 180-189. IEEE, 2013.","Most techniques for automated program repair use test cases to validate the effectiveness of the produced patches. The validation process can be time-consuming especially when the object programs ship with either lots of test cases or some long-running test cases. To alleviate the cost for testing, we first introduce regression test prioritization insight into the area of automated program repair, and present a novel prioritization technique called FRTP with the goal of reducing the number of test case executions in the repair process. Unlike most existing prioritization techniques frequently requiring additional cost for gathering previous test executions information, FRTP iteratively extracts that information just from the repair process, and thus incurs trivial performance lose. We also built a tool called TrpAutoRepair, which implements our FRTP technique and has the ability of automatically repairing C programs. To evaluate TrpAutoRepair, we compared it with GenProg, a state-of-the-art tool for automated C program repair. The experiment on the 5 subject programs with 16 real-life bugs provides evidence that TrpAutoRepair performs at least as good as GenProg in term of success rate, in most cases (15/16), TrpAutoRepair can significantly improve the repair efficiency by reducing efficiently the test case executions when searching a valid patch in the repair process.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated program repair.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated program repair</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case prioritization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case prioritization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.efficiency.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">efficiency</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Combinatorial interaction regression testing: A study of test case generation and prioritization,ieeexplore,Combinatorial interaction regression testing: A study of test case generation and prioritization,"Qu, Xiao, Myra B. Cohen, and Katherine M. Woolf",105," In <i>Software Maintenance, 2007. ICSM 2007. IEEE International Conference on</i>, pp. 255-264. IEEE, 2007.","Regression testing is an expensive part of the software maintenance process. Effective regression testing techniques select and order (or prioritize) test cases between successive releases of a program. However, selection and prioritization are dependent on the quality of the initial test suite. An effective and cost efficient test generation technique is combinatorial interaction testing, CIT, which systematically samples all t-way combinations of input parameters. Research on CIT, to date, has focused on single version software systems. There has been little work that empirically assesses the use of CIT test generation as the basis for selection or prioritization. In this paper we examine the effectiveness of CIT across multiple versions of two software subjects. Our results show that CIT performs well in finding seeded faults when compared with an exhaustive test set. We examine several CIT prioritization techniques and compare them with a re-generation/prioritization technique. We find that prioritized and re-generated/prioritized CIT test suites may find faults earlier than unordered CIT test suites, although the re-generated/prioritized test suites sometimes exhibit decreased fault detection.",
Configuration-aware regression testing: an empirical study of sampling and prioritization,acm,Configuration-aware regression testing: an empirical study of sampling and prioritization,"Qu, Xiao, Myra B. Cohen, and Gregg Rothermel",148," In <i>Proceedings of the 2008 international symposium on Software testing and analysis</i>, pp. 75-86. ACM, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Configurable software lets users customize applications in many ways, and is becoming increasingly prevalent. Researchers have created techniques for testing configurable software, but to date, only a little research has addressed the problems of regression testing configurable systems as they evolve. Whereas problems such as selective retesting and test prioritization at the test case level have been extensively researched, these problems have rarely been considered at the configuration level. In this paper we address the problem of providing configuration-aware regression testing for evolving software systems. We use combinatorial interaction testing techniques to model and generate configuration samples for use in regression testing. We conduct an empirical study on a non-trivial evolving software system to measure the impact of configurations on testing effectiveness, and to compare the effectiveness of different configuration prioritization techniques on early fault detection during regression testing. Our results show that configurations can have a large impact on fault detection and that prioritization of configurations can be effective.</p></div> 
            

            </div>
          ",combinatorial interaction testing; configurable software; prioritization; regression testing
Configuration selection using code change impact analysis for regression testing,ieeexplore,Configuration selection using code change impact analysis for regression testing,"Qu, Xiao, Mithun Acharya, and Brian Robinson",11," In <i>Software Maintenance (ICSM), 2012 28th IEEE International Conference on</i>, pp. 129-138. IEEE, 2012.","Configurable systems that let users customize system behaviors are becoming increasingly prevalent. Testing a configurable system with all possible configurations is very expensive and often impractical. For a single version of a configurable system, sampling approaches exist that select a subset of configurations from the full configuration space for testing. However, when a configurable system changes and evolves, existing approaches for regression testing select all configurations that are used to test the old versions for testing the new version. As demonstrated in our experiments, this retest-all approach for regression testing configurable systems turns out to be highly redundant. To address this redundancy, we propose a configuration selection approach for regression testing. Formally, given two versions of a configurable system, S (old) and S' (new), and given a set of configurations C<sub>S</sub> for testing S, our approach selects a subset C<sub>S'</sub> of C<sub>S</sub> for regression testing S'. Our study results on two open source systems and a large industrial system show that, compared to the retest-all approach, our approach discards 15% to 60% of configurations as redundant. Our approach also saves 20% to 55% of the regression testing time, while retaining the same fault detection capability and code coverage of the retest-all approach.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Change Impact Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Change Impact Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Configurable System Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Configurable System Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Configuration Selection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Configuration Selection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Regression Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Regression Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Static Program Slicing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Static Program Slicing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Test case prioritization: An empirical study,ieeexplore,Test case prioritization: An empirical study,"Rothermel, Gregg, Roland H. Untch, Chengyun Chu, and Mary Jean Harrold",441," In <i>Software Maintenance, 1999.(ICSM'99) Proceedings. IEEE International Conference on</i>, pp. 179-188. IEEE, 1999.",Test case prioritization techniques schedule test cases for execution in an order that attempts to maximize some objective function. A variety of objective functions are applicable; one such function involves rate of fault detection-a measure of how quickly faults are detected within the testing process. An improved rate of fault detection during regression testing can provide faster feedback on a system under regression test and let debuggers begin their work earlier than might otherwise be possible. In this paper we describe several techniques for prioritizing test cases and report our empirical results measuring the effectiveness of these techniques for improving rate of fault detection. The results provide insights into the tradeoffs among various techniques for test case prioritization.,
Prioritizing test cases for regression testing,ieeexplore,Test case prioritization,"Srivastava, Praveen Ranjan",1100," <i>Journal of Theoretical and Applied Information Technology</i> 4, no. 3 (2008): 178-181.","Test case prioritization techniques schedule test cases for execution in an order that attempts to increase their effectiveness at meeting some performance goal. Various goals are possible; one involves rate of fault detection, a measure of how quickly faults are detected within the testing process. An improved rate of fault detection during testing can provide faster feedback on the system under test and let software engineers begin correcting faults earlier than might otherwise be possible. One application of prioritization techniques involves regression testing, the retesting of software following modifications; in this context, prioritization techniques can take advantage of information gathered about the previous execution of test cases to obtain test case orderings. We describe several techniques for using test execution information to prioritize test cases for regression testing, including: 1) techniques that order test cases based on their total coverage of code components; 2) techniques that order test cases based on their coverage of code components not previously covered; and 3) techniques that order test cases based on their estimated ability to reveal faults in the code components that they cover. We report the results of several experiments in which we applied these techniques to various test suites for various programs and measured the rates of fault detection achieved by the prioritized test suites, comparing those rates to the rates achieved by untreated, randomly ordered, and optimally ordered suites.",
Model-based testing of obligations,ieeexplore,Model-based testing of obligations,"Rubab, Iram, Shaukat Ali, Lionel Briand, and Yves Le Traon",2," In <i>Quality Software (QSIC), 2014 14th International Conference on</i>, pp. 1-10. IEEE, 2014.","Obligations are mandatory actions that users must perform, addressing access control requirements. To ensure that such obligations are implemented correctly, an automated and systematic testing approach is often recommended. One such approach is Model-Based Testing (MBT) that allows defining cost-effective testing strategies to support rigorous testing via automation. In this paper, we present MBT for obligations by extending the Unified Modeling Language (UML) via a profile called the Obligations Profile. Based on the profile, we define a modeling methodology utilizing the concepts of Obligations Class Diagrams (OCDs) and Obligations State Machines (OSMs), which are standard UML Class Diagrams and UML State Machines with stereotypes from the Obligations Profile. Our methodology, using OCDs and OSMs, is automatically enforced by the validation of constraints defined in the profile. To assess the completeness and applicability of the profile and methodology, we modeled 47 obligations from four different systems. The results of our case study show that we successfully modeled all the obligations and used 75% of the stereotypes that we defined in the profile. In addition, using OCDs and OSMs, we automatically generate executable test cases using a standard state machine structural coverage criterion and common test data generation strategies. The effectiveness of generated test cases is assessed using mutation analysis on two systems, using mutation operators specifically designed for obligation faults. Test case execution killed 75% of the mutants and a careful analysis further suggests that more sophisticated testing strategies must be defined to further improve testing effectiveness.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Obligations.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Obligations</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Access control policy.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Access control policy</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.UML profile.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">UML profile</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.UML class diagram.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">UML class diagram</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.UML state machines.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">UML state machines</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Evaluating test suites and adequacy criteria using simulation-based models of distributed systems,ieeexplore,Evaluating test suites and adequacy criteria using simulation-based models of distributed systems,"Rutherford, Matthew J., Antonio Carzaniga, and Alexander L. Wolf",25," <i>IEEE Transactions on Software Engineering</i> 34, no. 4 (2008): 452-470.","Test adequacy criteria provide the engineer with guidance on how to populate test suites. While adequacy criteria have long been a focus of research, existing testing methods do not address many of the fundamental characteristics of distributed systems, such as distribution topology, communication failure, and timing. Furthermore, they do not provide the engineer with a means to evaluate the relative effectiveness of different criteria, nor the relative effectiveness of adequate test suites satisfying a given criterion. This paper makes three contributions to the development and use of test adequacy criteria for distributed systems: (1) a testing method based on discrete-event simulations; (2) a fault-based analysis technique for evaluating test suites and adequacy criteria; and (3) a series of case studies that validate the method and technique. The testing method uses a discrete-event simulation as an operational specification of a system, in which the behavioral effects of distribution are explicitly represented. Adequacy criteria and test cases are then defined in terms of this simulation-based specification. The fault-based analysis involves mutation of the simulation-based specification to provide a foil against which test suites and the criteria that formed them can be evaluated. Three distributed systems were used to validate the method and technique, including DNS, the domain name system.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Test coverage of specifications.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Test coverage of specifications</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Specification.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Specification</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Assessing oracle quality with checked coverage,ieeexplore,Assessing oracle quality with checked coverage,"Schuler, David, and Andreas Zeller",34," In <i>Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on</i>, pp. 90-99. IEEE, 2011.","A known problem of traditional coverage metrics is that they do not assess oracle quality - that is, whether the computation result is actually checked against expectations. In this paper, we introduce the concept of checked coverage - the dynamic slice of covered statements that actually influence an oracle. Our experiments on seven open-source projects show that checked coverage is a sure indicator for oracle quality - and even more sensitive than mutation testing, its much more demanding alternative.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test suite quality.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test suite quality</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.coverage metrics.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">coverage metrics</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.dynamic slicing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">dynamic slicing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Checked coverage: an indicator for oracle quality,Wiley Online Library,Checked coverage: an indicator for oracle quality,"Schuler, David, and Andreas Zeller",11," <i>Software Testing, Verification and Reliability</i> 23, no. 7 (2013): 531-551.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">SUMMARY</h2><p>A known problem of traditional coverage metrics is that they do not assess <em>oracle quality</em>—that is, whether the computation result is actually checked against expectations. In this paper, we introduce the concept of <em>checked coverage</em>—the dynamic slice of covered statements that actually influence an oracle. Our experiments on seven open-source projects show that checked coverage is a sure indicator for oracle quality and even more sensitive than mutation testing. Copyright © 2013 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test suite quality; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">coverage metrics; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">dynamic slicing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing</span></li>"
Automated test data generation on the analyses of feature models: A metamorphic testing approach,ieeexplore,Automated test data generation on the analyses of feature models: A metamorphic testing approach,"Segura, Sergio, Robert M. Hierons, David Benavides, and Antonio Ruiz-Cortés",52," In <i>Software Testing, Verification and Validation (ICST), 2010 Third International Conference on</i>, pp. 35-44. IEEE, 2010.","A Feature Model (FM) is a compact representation of all the products of a software product line. The automated extraction of information from FMs is a thriving research topic involving a number of analysis operations, algorithms, paradigms and tools. Implementing these operations is far from trivial and easily leads to errors and defects in analysis solutions. Current testing methods in this context mainly rely on the ability of the tester to decide whether the output of an analysis is correct. However, this is acknowledged to be time-consuming, error-prone and in most cases infeasible due to the combinatorial complexity of the analyses. In this paper, we present a set of relations (so-called metamorphic relations) between input FMs and their set of products and a test data generator relying on them. Given an FM and its known set of products, a set of neighbour FMs together with their corresponding set of products are automatically generated and used for testing different analyses. Complex FMs representing millions of products can be efficiently created applying this process iteratively. The evaluation of our approach using mutation testing as well as real faults and tools reveals that most faults can be automatically detected within a few seconds.",
Artificial neural networks as multi-networks automated test oracle,Springer,Artificial neural networks as multi-networks automated test oracle,"Shahamiri, Seyed Reza, Wan MN Wan-Kadir, Suhaimi Ibrahim, and Siti Zaiton Mohd Hashim",15," <i>Automated Software Engineering</i> 19, no. 3 (2012): 303-334.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">One of the important issues in software testing is to provide an automated test oracle. Test oracles are reliable sources of how the software under test must operate. In particular, they are used to evaluate the actual results produced by the software. However, in order to generate an automated test oracle, it is necessary to map the input domain to the output domain automatically. In this paper, Multi-Networks Oracles based on Artificial Neural Networks are introduced to handle the mapping automatically. They are an enhanced version of previous ANN-Based Oracles. The proposed model was evaluated by a framework provided by mutation testing and applied to test two industry-sized case studies. In particular, a mutated version of each case study was provided and injected with some faults. Then, a fault-free version of it was developed as a Golden Version to evaluate the capability of the proposed oracle finding the injected faults. Meanwhile, the quality of the proposed oracle is measured by assessing its accuracy, precision, misclassification error and recall. Furthermore, the results of the proposed oracle are compared with former ANN-based Oracles. Accuracy of the proposed oracle was up to 98.93%, and the oracle detected up to 98% of the injected faults. The results of the study show the proposed oracle has better quality and applicability than the previous model.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Automated software testing&nbsp;</span><span class=""Keyword"">Software test oracle&nbsp;</span><span class=""Keyword"">Artificial neural networks&nbsp;</span><span class=""Keyword"">Mutation testing&nbsp;</span>"
Adding criteria-based tests to test driven development,ieeexplore,Adding criteria-based tests to test driven development,"Shelton, William, Nan Li, Paul Ammann, and Jeff Offutt",7," In <i>Software Testing, Verification and Validation (ICST), 2012 IEEE Fifth International Conference on</i>, pp. 878-886. IEEE, 2012.","Test driven development (TDD) is the practice of writing unit tests before writing the source. TDD practitioners typically start with example-based unit tests to verify an understanding of the software's intended functionality and to drive software design decisions. Hence, the typical role of test cases in TDD leans more towards specifying and documenting expected behavior, and less towards detecting faults. Conversely, traditional criteria-based test coverage ignores functionality in favor of tests that thoroughly exercise the software. This paper examines whether it is possible to combine both approaches. Specifically, can additional criteria based tests improve the quality of TDD test suites without disrupting the TDD development process? This paper presents the results of an observational study that generated additional criteria-based tests as part of a TDD exercise. The criterion was mutation analysis and the additional tests were designed to kill mutants not killed by the TDD tests. The additional unit tests found several software faults and other deficiencies in the software. Subsequent interviews with the programmers indicated that they welcomed the additional tests, and that the additional tests did not inhibit their productivity.",
Measuring the Diversity of a Test Set With Distance Entropy,ieeexplore,Measuring the Diversity of a Test Set With Distance Entropy,"Shi, Qingkai, Zhenyu Chen, Chunrong Fang, Yang Feng, and Baowen Xu",3," <i>IEEE Transactions on Reliability</i> 65, no. 1 (2016): 19-27.","Most existing metrics that we call white-box metrics, such as coverage metrics, require white-box information, like program structure information, and historical runtime information, to evaluate the fault detection capability of a test set. In practice, such white-box information is usually unavailable or difficult to obtain, which means they often cannot be used. In this paper, we propose a black-box metric, distance entropy, based on the diversification idea behind many published diversity-based techniques. Distance entropy provides a possible solution for test set evaluation when white-box information is not available. The empirical study illustrates that distance entropy can effectively evaluate test sets if the distance metric between tests is well defined. Meanwhile, distance entropy outperforms simple diversity metrics without increasing time complexity.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.minimum spanning tree.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">minimum spanning tree</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Fault detection capability.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Fault detection capability</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.diversity.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">diversity</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.metrics.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">metrics</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Balancing trade-offs in test-suite reduction,acm,Balancing trade-offs in test-suite reduction,"Shi, August, Alex Gyori, Milos Gligoric, Andrey Zaytsev, and Darko Marinov",29," In <i>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</i>, pp. 246-256. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Regression testing is an important activity but can get expensive for large test suites. Test-suite reduction speeds up regression testing by identifying and removing redundant tests based on a given set of requirements. Traditional research on test-suite reduction is rather diverse but most commonly shares three properties: (1) requirements are defined by a coverage criterion such as statement coverage; (2) the reduced test suite has to satisfy all the requirements as the original test suite; and (3) the quality of the reduced test suites is measured on the software version on which the reduction is performed. These properties make it hard for test engineers to decide how to use reduced test suites. We address all three properties of traditional test-suite reduction: (1) we evaluate test-suite reduction with requirements defined by killed mutants; (2) we evaluate inadequate reduction that does not require reduced test suites to satisfy all the requirements; and (3) we propose evolution-aware metrics that evaluate the quality of the reduced test suites across multiple software versions. Our evaluations allow a more thorough exploration of trade-offs in test-suite reduction, and our evolution-aware metrics show how the quality of reduced test suites can change after the version where the reduction is performed. We compare the trade-offs among various reductions on 18 projects with a total of 261,235 tests over 3,590 commits and a cumulative history spanning 35 years of development. Our results help test engineers make a more informed decision about balancing size, coverage, and fault-detection loss of reduced test suites. </p></div> 
            

            </div>
          ",Test-suite reduction; software evolution
Comparing and combining test-suite reduction and regression test selection,acm,Comparing and combining test-suite reduction and regression test selection,"Shi, August, Tifany Yung, Alex Gyori, and Darko Marinov",11," In <i>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</i>, pp. 237-247. ACM, 2015.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Regression testing is widely used to check that changes made to software do not break existing functionality, but regression test suites grow, and running them fully can become costly. Researchers have proposed test-suite reduction and regression test selection as two approaches to reduce this cost by not running some of the tests from the test suite. However, previous research has not empirically evaluated how the two approaches compare to each other, and how well a combination of these approaches performs. We present the first extensive study that compares test-suite reduction and regression test selection approaches individually, and also evaluates a combination of the two approaches. We also propose a new criterion to measure the quality of tests with respect to software changes. Our experiments on 4,793 commits from 17 open-source projects show that regression test selection runs on average fewer tests (by 40.15pp) than test-suite reduction. However, test-suite reduction can have a high loss in fault-detection capability with respect to the changes, whereas a (safe) regression test selection has no loss. The experiments also show that a combination of the two approaches runs even fewer tests (on average 5.34pp) than regression test selection, but these tests still have a loss in fault-detection capability with respect to the changes. </p></div> 
            

            </div>
          ",Regression test selection; Regression testing; Test-suite reduction
An empirical evaluation of assertions as oracles,ieeexplore,An empirical evaluation of assertions as oracles,"Shrestha, Kavir, and Matthew J. Rutherford",16," In <i>Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on</i>, pp. 110-119. IEEE, 2011.","In software testing, an oracle determines whether a test case passes or fails by comparing output from the program under test with the expected output. Since the identification of faults through testing requires that the bug is both exercised and the resulting failure is recognized, it follows that oracles are critical to the efficacy of the testing process. Despite this, there are few rigorous empirical studies of the impact of oracles on effectiveness. In this paper, we report the results of one such experiment in which we exercise seven core Java classes and two sample programs with branch-adequate, input only(i.e., no oracle) test suites and collect the failures observed by different oracles. For faults, we use synthetic bugs created by the muJava mutation testing tool. In this study we evaluate two oracles: (1) the implicit oracle (or ""null oracle"") provided by the runtime system, and (2) runtime assertions embedded in the implementation (by others) using the Java Modeling Language. The null oracle establishes a baseline measurement of the potential benefit of rigorous oracles, while the assertions represent a more rigorous approach that is sometimes used in practice. The results of our experiments are interesting. First, on a per-method basis, we observe that the null oracle catches less than 11% of the faults, leaving more than 89% uncaught. Second, we observe that the runtime assertions in our subjects are effective at catching about 53% of the faults not caught by null oracle. Finally, by analyzing the data using data mining techniques, we observe that simple, code-based metrics can be used to predict which methods are amenable to the use of assertion-based oracles with a high degree of accuracy.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.design by contract.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">design by contract</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test oracles.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test oracles</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.runtime assertion checking.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">runtime assertion checking</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical study.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical study</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
On guiding the augmentation of an automated test suite via mutation analysis,Springer,On guiding the augmentation of an automated test suite via mutation analysis,"Smith, Ben H., and Laurie Williams",39," <i>Empirical Software Engineering</i> 14, no. 3 (2009): 341-369.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Mutation testing has traditionally been used as a defect injection technique to assess the effectiveness of a test suite as represented by a “mutation score.” Recently, mutation testing tools have become more efficient, and industrial usage of mutation analysis is experiencing growth. Mutation analysis entails adding or modifying test cases until the test suite is sufficient to detect as many mutants as possible and the mutation score is satisfactory. The augmented test suite resulting from mutation analysis may reveal latent faults and provides a stronger test suite to detect future errors which might be injected. Software engineers often look for guidance on how to augment their test suite using information provided by line and/or branch coverage tools. As the use of mutation analysis grows, software engineers will want to know how the emerging technique compares with and/or complements coverage analysis for guiding the augmentation of an automated test suite. Additionally, software engineers can benefit from an enhanced understanding of efficient mutation analysis techniques. To address these needs for additional information about mutation analysis, we conducted an empirical study of the use of mutation analysis on two open source projects. Our results indicate that a focused effort on increasing mutation score leads to a corresponding increase in line and branch coverage to the point that line coverage, branch coverage and mutation score reach a maximum but leave some types of code structures uncovered. Mutation analysis guides the creation of additional “common programmer error” tests beyond those written to increase line and branch coverage. We also found that 74% of our chosen set of mutation operators is useful, on average, for producing new tests. The remaining 26% of mutation operators did not produce new test cases because their mutants were immediately detected by the initial test suite, indirectly detected by test suites we added to detect other mutants, or were not able to be detected by any test.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Line coverage&nbsp;</span><span class=""Keyword"">Fault injection&nbsp;</span><span class=""Keyword"">Empirical effectiveness&nbsp;</span><span class=""Keyword"">Test case augmentation&nbsp;</span><span class=""Keyword"">Mutation analysis&nbsp;</span><span class=""Keyword"">Mutation testing tool&nbsp;</span><span class=""Keyword"">Statement coverage&nbsp;</span><span class=""Keyword"">Test adequacy&nbsp;</span><span class=""Keyword"">Web application&nbsp;</span><span class=""Keyword"">Open source&nbsp;</span><span class=""Keyword"">Unit testing&nbsp;</span>"
Should software testers use mutation analysis to augment a test set?,Elsevier,Should software testers use mutation analysis to augment a test set?,"Smith, Ben H., and Laurie Williams",25," <i>Journal of Systems and Software</i> 82, no. 11 (2009): 1819-1832.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Mutation testing has historically been used to assess the fault-finding effectiveness of a test suite or other verification technique. Mutation analysis, rather, entails augmenting a test suite to detect all killable mutants. Concerns about the time efficiency of mutation analysis may prohibit its widespread, practical use. <em>The goal of our research is to assess the effectiveness of the mutation analysis process when used by software testers to augment a test suite to obtain higher statement coverage scores.</em> We conducted two empirical studies and have shown that mutation analysis can be used by software testers to effectively produce new test cases and to improve statement coverage scores in a feasible amount of time. Additionally, we find that our user study participants view mutation analysis as an effective but relatively expensive technique for writing new test cases. Finally, we have shown that the choice of mutation tool and operator set can play an important role in determining how efficient mutation analysis is for producing new test cases.</p>","<li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Empirical effectiveness</span>; </li><li id="""" class=""svKeywords""><span id="""">User study</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation analysis</span>; </li><li id="""" class=""svKeywords""><span id="""">Test adequacy</span>; </li><li id="""" class=""svKeywords""><span id="""">Web application</span>; </li><li id="""" class=""svKeywords""><span id="""">Open source</span>; </li><li id="""" class=""svKeywords""><span id="""">Unit testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing tool</span></li>"
Better testing through oracle selection (NIER track),acm,Better testing through oracle selection (NIER track),"Staats, Matt, Michael W. Whalen, and Mats PE Heimdahl",22," In <i>Proceedings of the 33rd International Conference on Software Engineering</i>, pp. 892-895. ACM, 2011.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>In software testing, the test oracle determines if the application under test has performed an execution correctly. In current testing practice and research, significant effort and thought is placed on selecting test inputs, with the selection of test oracles largely neglected. Here, we argue that improvements to the testing process can be made by considering the problem of <i>oracle selection</i>. In particular, we argue that selecting the test oracle and test inputs <i>together</i> to complement one another may yield improvements testing effectiveness. We illustrate this using an example and present selected results from an ongoing study demonstrating the relationship between test suite selection, oracle selection, and fault finding.</p></div> 
            

            </div>
          ",empirical studies; test oracles
"Automated oracle creation support, or: how I learned to stop worrying about fault propagation and love mutation testing",acm,"Automated oracle creation support, or: how I learned to stop worrying about fault propagation and love mutation testing","Staats, Matt, Gregory Gay, and Mats PE Heimdahl",49," In <i>Proceedings of the 34th International Conference on Software Engineering</i>, pp. 870-880. IEEE Press, 2012.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> In testing, the test oracle is the artifact that determines whether an application under test executes correctly. The choice of test oracle can significantly impact the effectiveness of the testing process. However, despite the prevalence of tools that support the selection of test inputs, little work exists for supporting oracle creation. In this work, we propose a method of supporting test oracle creation. This method automatically selects the oracle data â the set of variables monitored during testingâfor expected value test oracles. This approach is based on the use of mutation analysis to rank variables in terms of fault-finding effectiveness, thus automating the selection of the oracle data. Experiments over four industrial examples demonstrate that our method may be a cost-effective approach for producing small, effective oracle data, with fault finding improvements over current industrial best practice of up to 145.8% observed. </p></div> 
            

            </div>
          ",
Oracle-centric test case prioritization,ieeexplore,Oracle-centric test case prioritization,"Staats, Matt, Pablo Loyola, and Gregg Rothermel",24," In <i>Software Reliability Engineering (ISSRE), 2012 IEEE 23rd International Symposium on</i>, pp. 311-320. IEEE, 2012.","Recent work in testing has demonstrated the benefits of considering test oracles in the testing process. Unfortunately, this work has focused primarily on developing techniques for generating test oracles, in particular techniques based on mutation testing. While effective for test case generation, existing research has not considered the impact of test oracles in the context of regression testing tasks. Of interest here is the problem of test case prioritization, in which a set of test cases are ordered to attempt to detect faults earlier and to improve the effectiveness of testing when the entire set cannot be executed. In this work, we propose a technique for prioritizing test cases that explicitly takes into account the impact of test oracles on the effectiveness of testing. Our technique operates by first capturing the flow of information from variable assignments to test oracles for each test case, and then prioritizing to ``cover'' variables using the shortest paths possible to a test oracle. As a result, we favor test orderings in which many variables impact the test oracle's result early in test execution. Our results demonstrate improvements in rate of fault detection relative to both random and structural coverage based prioritization techniques when applied to faulty versions of three synchronous reactive systems.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.software metrics.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">software metrics</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Software testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Model Clone Detector Evaluation Using Mutation Analysis,ieeexplore,Model clone detector evaluation using mutation analysis,"Stephan, Matthew",5," In <i>Software Maintenance and Evolution (ICSME), 2014 IEEE International Conference on</i>, pp. 633-638. IEEE, 2014.","Model Clone Detection is a growing area within the field of software model maintenance. New model clone detection techniques and tools for different types of models are being created, however, there is no clear way of objectively and quantitatively evaluating and comparing them. In this paper, we provide a synopsis of our work in devising and validating an evaluation framework that uses Mutation Analysis to provide such a facility. In order to demonstrate the framework's feasibility and also walk through its steps, we implement a framework implementation for evaluating Simulink model clone detectors. This includes a taxonomy of Simulink mutations, Simulink clone report transformations, and more. We outline how the framework calculates precision and recall, and do so on multiple Simulink model clone detectors. In addition, we also discuss areas of future work, including semantic clone mutations, and developing framework implementations for other model types, like UML. Lastly, we address some lessons we learned during the Ph.D. Process, such as partitioning the work into logical, self-contained, milestones, and being open and willing to engage in other research. We hope that our framework will help cultivate further research gains in Model Clone Detection.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Simulink.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Simulink</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model Clone Detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model Clone Detection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Clone Detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Clone Detection</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Evaluating automated unit testing in sulu,ieeexplore,Evaluating automated unit testing in sulu,"Tan, Roy Patrick, and Stephen Edwards",13," In <i>Software Testing, Verification, and Validation, 2008 1st International Conference on</i>, pp. 62-71. IEEE, 2008.","Sulu is a programming language designed with automated unit testing specifically in mind. One aim of Sulu is to demonstrate how automated software testing can be more integrated into current software development processes. Sulu's runtime and tools support automated testing from end to end; automating the generation, execution, and evaluation of test suites using both code coverage and mutation analysis. To show the effectiveness of this integratedapproach, we performed an experiment to evaluate a family of test suites generated using a test case generation algorithm which exhaustively enumerates every sequence of method calls within a certain bound. The results show high code coverage,including 90\% statement coverage and high mutation coverage for the most comprehensive test suite generated.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.programming languages.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">programming languages</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test evaluation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test evaluation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.software engineering.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">software engineering</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.design by contract.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">design by contract</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Location pairs: a test coverage metric for shared-memory concurrent programs,Springer,Location pairs: a test coverage metric for shared-memory concurrent programs,"Tasiran, Serdar, M. Erkan Keremoğlu, and Kivanç Muşlu",7," <i>Empirical Software Engineering</i> 17, no. 3 (2012): 129-165.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">We present a coverage metric targeted at shared-memory concurrent programs: the Location Pairs (LP) coverage metric. The goals of this metric are (i) to measure how thoroughly a program has been tested from a concurrency standpoint, i.e., whether enough qualitatively different thread interleavings have been explored, and (ii) to guide testing towards unexplored concurrency scenarios. This metric was inspired by an access pattern known to lead to high-level concurrency errors in industrial software and in the literature. We built a monitoring tool to measure LP coverage of test programs. We used the LP metric for interactive debugging, and compared LP coverage with other concurrency coverage metrics on Java benchmarks. We demonstrated that LP coverage corresponds better to concurrency errors, is a better measure of how well a program is exercised concurrency-wise by a test set, reaches saturation later than other coverage metrics, and is viable and useful as an interactive testing and debugging tool.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Concurrency&nbsp;</span><span class=""Keyword"">Testing&nbsp;</span><span class=""Keyword"">Coverage metrics&nbsp;</span><span class=""Keyword"">Multi-threaded software&nbsp;</span><span class=""Keyword"">Shared memory&nbsp;</span>"
Full predicate coverage for testing SQL database queries,Wiley Online Library,Full predicate coverage for testing SQL database queries,"González, Pablo Javier Tuya, María José Suárez Cabal, and A. Claudio",45, <i>Software Testing Verification and Reliability</i> (2010).,"<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>In the field of database applications a considerable part of the business logic is implemented using a semi-declarative language: the Structured Query Language (SQL). Because of the different semantics of SQL compared with other procedural languages, the conventional coverage criteria for testing are not directly applicable. This paper presents a criterion specifically tailored for SQL queries (SQLFpc). It is based on Masking Modified Condition Decision Coverage (MCDC) or Full Predicate Coverage and takes into account a wide range of the syntax and semantics of SQL, including selection, joining, grouping, aggregations, subqueries, case expressions and null values. The criterion assesses the coverage of the test data in relation to the query that is executed and it is expressed as a set of rules that are automatically generated and efficiently evaluated against a test database. The use of the criterion is illustrated in a case study, which includes complex queries. Copyright © 2010 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">database testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">MCDC; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">full predicate coverage; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">SQL</span></li>"
Constraint based structural testing criteria,Elsevier,Constraint based structural testing criteria,"Vergilio, Silvia Regina, José Carlos Maldonado, Mario Jino, and Inali Wisniewski Soares",15," <i>Journal of Systems and Software</i> 79, no. 6 (2006): 756-771.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Structural criteria generally divide the input domain of the program under test and require the execution of at least one point from each derived sub-domain without addressing the most relevant question: “Which points from each sub-domain should be selected?”. This question is related to data-sensitive faults which lead to one of the drawbacks of the testing activity. The constraints and conditions used by fault-based data generation techniques describe faults related to the boundaries of these sub-domains. Our conjecture is that we would improve the efficacy of the adequate test case sets by associating those constraints and conditions to the elements required by a criterion. With this goal, this work presents Constraint Based Criteria (CBC) that associate a constraint <em>C</em> to an element <em>E</em>, required by a structural criterion. CBC allow to combine the fundamentals of different testing generation techniques with structural testing, increasing the probability of revealing faults described by <em>C</em>. We also discuss complexity, inclusion relation and automation aspects of CBC. Results from three experiments of CBC evaluation using the factors cost, efficacy and strength provide evidence that our objectives have been achieved. We also present some results from the evaluation of random test sets.</p>","<li id="""" class=""svKeywords""><span id="""">Data flow based criteria</span>; </li><li id="""" class=""svKeywords""><span id="""">Constraint based testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation analysis</span></li>"
Search-based data-flow test generation,ieeexplore,Search-based data-flow test generation,"Vivanti, Mattia, Andre Mis, Alessandra Gorla, and Gordon Fraser",26," In <i>Software Reliability Engineering (ISSRE), 2013 IEEE 24th International Symposium on</i>, pp. 370-379. IEEE, 2013.","Coverage criteria based on data-flow have long been discussed in the literature, yet to date they are still of surprising little practical relevance. This is in part because 1) manually writing a unit test for a data-flow aspect is more challenging than writing a unit test that simply covers a branch or statement, 2) there is a lack of tools to support data-flow testing, and 3) there is a lack of empirical evidence on how well data-flow testing scales in practice. To overcome these problems, we present 1) a search-based technique to automatically generate unit tests for data-flow criteria, 2) an implementation of this technique in the Evosuite test generation tool, and 3) a large empirical study applying this tool to the SF100 corpus of 100 open source Java projects. On average, the number of coverage objectives is three times as high as for branch coverage. However, the level of coverage achieved by Evosuite is comparable to other criteria, and the increase in size is only 15%, leading to higher mutation scores. These results counter the common assumption that data-flow testing does not scale, and should help to re-establish data-flow testing as a viable alternative in practice.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.data-flow coverage.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">data-flow coverage</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.search based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">search based testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Planner based error recovery testing,ieeexplore,Planner based error recovery testing,"von Mayrhauser, Anneliese, Michael Scheetz, Eric Dahlman, and Adele E. Howe",6," In <i>Software Reliability Engineering, 2000. ISSRE 2000. Proceedings. 11th International Symposium on</i>, pp. 186-195. IEEE, 2000.","Error recovery testing is an important part of software testing, especially for safety-critical systems. We show how an AI planning system and the concepts of mutation testing can be combined to generate error recovery tests for software. We identify a set of mutation operations on the representation that the planner uses when generating test cases. These mutations cause error recovery test cases to be generated. The paper applies these concepts to the testing of a large tape storage system.",
Correlating context-awareness and mutation analysis for pervasive computing systems,ieeexplore,Correlating context-awareness and mutation analysis for pervasive computing systems,"Wang, Huai, Ke Zhai, and T. H. Tse",6," In <i>Quality Software (QSIC), 2010 10th International Conference on</i>, pp. 151-160. IEEE, 2010.","Pervasive computing systems often use middleware as a means to communicate with the changing environment. However, the interactions with the context-aware middleware as well as the interactions among applications sharing the same middleware may introduce faults that are difficult to reveal by existing testing techniques. Our previous work proposed the notion of context diversity as a metric to measure the degree of changes in test inputs for pervasive software. In this paper, we present a case study on how much context diversity for test cases relates to fault-based mutants in pervasive software. Our empirical results show that conventional mutation operators can generate sufficient candidate mutants to support test effectiveness evaluation of pervasive software, and test cases with higher context diversity values tend to have higher mean mutation scores. On the other hand, for test cases sharing the same context diversity, their mutation scores can vary significantly in terms of standard derivations","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.pervasive computing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">pervasive computing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.context diversity.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">context diversity</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation analysis</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Experience report: how is dynamic symbolic execution different from manual testing? a study on KLEE,acm,Experience report: How is dynamic symbolic execution different from manual testing? a study on klee,"Wang, Xiaoyin, Lingming Zhang, and Philip Tanofsky",9," In <i>Proceedings of the 2015 International Symposium on Software Testing and Analysis</i>, pp. 199-210. ACM, 2015.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Software testing has been the major approach to software quality assurance for decades, but it typically involves intensive manual efforts. To reduce manual efforts, researchers have proposed numerous approaches to automate test-case generation, which is one of the most time-consuming tasks in software testing. One most recent achievement in the area is Dynamic Symbolic Execution (DSE), and tools based on DSE, such as KLEE, have been reported to generate test suites achieving higher code coverage than manually developed test suites. However, besides the competitive code coverage, there have been few studies to compare DSE-based test suites with manually developed test suites more thoroughly on various metrics to understand the detailed differences between the two testing methodologies. In this paper, we revisit the experimental study on the KLEE tool and GNU CoreUtils programs, and compare KLEE-based test suites with manually developed test suites on various aspects. We further carried out a qualitative study to investigates the reasons behind the differences in statistical results. The results of our studies show that while KLEE-based test suites are able to generate test cases with higher code coverage, they are relatively less effective on covering hard-to-cover code and killing mutants. Furthermore, our qualitative study reveals that KLEE-based test suites have advantages in exploring error-handling code and exhausting options, but are less effective on generating valid string inputs and exploring meaningful program behaviors. </p></div> 
            

            </div>
          ",Dynamic Symbolic Execution; Empirical Study; Manual Testing
A specification-based adaptive test case generation strategy for open operating system standards,ieeexplore,A specification-based adaptive test case generation strategy for open operating system standards,"Watanabe, Aki, and Ken Sakamura",8," In <i>Software Engineering, 1996., Proceedings of the 18th International Conference on</i>, pp. 81-89. IEEE, 1996.","The paper presents a specification based adaptive test case generation (SBATCG) method for integration testing in an open operating system standards environment. In the SBATCG method, templates describing abstract state transitions are derived from a model based specification, and the templates are refined to the internal structure of each implementation. We adopt the Z notation, one of the most widely used formal specification languages. We conducted mutation analysis to study the fault exposure abilities of the SBATCG method and that of a strategy based only on a specification. In our experiment, we used a Z version of the ITRON2 real time multi task operating system specification and two commercially available ITRON2 implementations. The results of this equipment show that the SBATCG method can achieve a higher fault detecting ability than can the strategy using only a specification.",
Automatically generating test data from a Boolean specification,ieeexplore,Automatically generating test data from a Boolean specification,"Weyuker, Elaine, Tarak Goradia, and Ashutosh Singh",298," <i>IEEE Transactions on Software Engineering</i> 20, no. 5 (1994): 353-363.","This paper presents a family of strategies for automatically generating test data for any implementation intended to satisfy a given specification that is a Boolean formula. The fault detection effectiveness of these strategies is investigated both analytically and empirically, and the costs, assessed in terms of test set size, are compared.",
Observable modified condition/decision coverage,acm,Observable modified condition/decision coverage,"Whalen, Michael, Gregory Gay, Dongjiang You, Mats PE Heimdahl, and Matt Staats",30," In <i>Proceedings of the 2013 International Conference on Software Engineering</i>, pp. 102-111. IEEE Press, 2013.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> In many critical systems domains, test suite adequacy is currently measured using structural coverage metrics over the source code. Of particular interest is the modified condition/decision coverage (MC/DC) criterion required for, e.g., critical avionics systems. In previous investigations we have found that the efficacy of such test suites is highly dependent on the structure of the program under test and the choice of variables monitored by the oracle. MC/DC adequate tests would frequently exercise faulty code, but the effects of the faults would not propagate to the monitored oracle variables. </p> <p> In this report, we combine the MC/DC coverage metric with a notion of observability that helps ensure that the result of a fault encountered when covering a structural obligation propagates to a monitored variable; we term this new coverage criterion Observable MC/DC (OMC/DC). We hypothesize this path requirement will make structural coverage metrics 1.) more effective at revealing faults, 2.) more robust to changes in program structure, and 3.) more robust to the choice of variables monitored. We assess the efficacy and sensitivity to program structure of OMC/DC as compared to masking MC/DC using four subsystems from the civil avionics domain and the control logic of a microwave. We have found that test suites satisfying OMC/DC are significantly more effective than test suites satisfying MC/DC, revealing up to 88% more faults, and are less sensitive to program structure and the choice of monitored variables. </p></div> 
            

            </div>
          ",
Testing and validating machine learning classifiers by metamorphic testing,Elsevier,Testing and validating machine learning classifiers by metamorphic testing,"Xie, Xiaoyuan, Joshua WK Ho, Christian Murphy, Gail Kaiser, Baowen Xu, and Tsong Yueh Chen",57," <i>Journal of Systems and Software</i> 84, no. 4 (2011): 544-558.","<h4 id=""absSec_1"">Abstract</h4><p id=""spar0005"">Machine learning algorithms have provided core functionality to many application domains – such as bioinformatics, computational linguistics, etc. However, it is difficult to detect faults in such applications because often there is no “test oracle” to verify the correctness of the computed outputs. To help address the software quality, in this paper we present a technique for testing the implementations of machine learning classification algorithms which support such applications. Our approach is based on the technique “metamorphic testing”, which has been shown to be effective to alleviate the oracle problem. Also presented include a case study on a real-world machine learning application framework, and a discussion of how programmers implementing machine learning algorithms can avoid the common pitfalls discovered in our study. We also conduct mutation analysis and cross-validation, which reveal that our method has high effectiveness in killing mutants, and that observing expected cross-validation result alone is not sufficiently effective to detect faults in a supervised classification program. The effectiveness of metamorphic testing is further confirmed by the detection of real faults in a popular open-source classification program.</p>","<li id="""" class=""svKeywords""><span id="""">Metamorphic testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Machine learning</span>; </li><li id="""" class=""svKeywords""><span id="""">Test oracle</span>; </li><li id="""" class=""svKeywords""><span id="""">Oracle problem</span>; </li><li id="""" class=""svKeywords""><span id="""">Validation</span>; </li><li id="""" class=""svKeywords""><span id="""">Verification</span></li>"
Prioritizing state-based aspect tests,ieeexplore,Prioritizing state-based aspect tests,"Xu, Dianxiang, and Junhua Ding",13," In <i>Software Testing, Verification and Validation (ICST), 2010 Third International Conference on</i>, pp. 265-274. IEEE, 2010.","In aspect-oriented programming, aspects are essentially incremental modifications to their base classes. Therefore aspect-oriented programs can be tested in an incremental fashion – we can first test the base classes and then test the base classes and aspects as a whole. This paper demonstrates that, in this incremental testing paradigm, we can prioritize aspect tests so as to report failure earlier. We explore test prioritization for testing aspect-oriented programs against their state models with transition coverage and round-trip coverage. Aspect tests are generated from woven state models obtained by composing aspect models into their base class models. We prioritize aspect tests by identifying the extent to which an aspect modifies its base classes. The modification is measured by the number of new and changed components in state transitions (start state, event, precondition, postcondition, end state). Transitions with more changes have higher priorities for test generation. We evaluate the impact of aspect test prioritization through mutation analysis of two AspectJ programs, where all aspects and their base classes can be modeled by finite state machines. We create aspect mutants of each AspectJ program according to a comprehensive AspectJ fault model. Then we test each mutant with the test suites generated without prioritization and with prioritization, respectively. Our experiment results show that prioritization of aspect tests has accelerated failure report.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test prioritization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test prioritization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.aspect-oriented programming.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">aspect-oriented programming</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.model-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">model-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.finite state machine.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">finite state machine</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Testing aspect-oriented programs with finite state machines,Wiley Online Library,Testing aspect‐oriented programs with finite state machines,"Xu, Dianxiang, Omar El‐Ariss, Weifeng Xu, and Linzhang Wang",10," <i>Software Testing, Verification and Reliability</i> 22, no. 4 (2012): 267-293.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">SUMMARY</h2><p>Aspect-oriented programming yields new types of programming faults due to the introduction of new constructs for dealing with crosscutting concerns. To reveal aspect faults, this paper presents a framework for testing whether or not aspect-oriented programs conform to their state models. It supports two families of strategies (i.e. structure-oriented and property-oriented) for automated generation of aspect tests from aspect-oriented state models. A structure-oriented testing strategy derives tests and test code from an aspect-oriented state model to meet a given structural coverage criterion, such as state coverage, transition coverage, or round trip. A property-oriented testing strategy generates test code from the counterexamples of model checking. Two such strategies are checking an aspect-oriented state model against trap properties and checking mutants of aspect models against system properties. Mutation analysis of aspect-oriented programs is used to evaluate the effectiveness of these testing strategies. The experiments demonstrate that testing aspect-oriented programs against their state models can detect many aspect faults. The comparative evaluations also reveal that the structure-oriented and property-oriented testing strategies complement each other—some aspect faults were detected by the structure-oriented strategies, but not by the property-oriented strategies and vice versa. Copyright © 2010 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">aspect-oriented programming; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model-based testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">finite state machines; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model checking; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">coverage criteria</span></li>"
Test case purification for improving fault localization,acm,Test case purification for improving fault localization,"Xuan, Jifeng, and Martin Monperrus",44," In <i>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</i>, pp. 52-63. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Finding and fixing bugs are time-consuming activities in software development. Spectrum-based fault localization aims to identify the faulty position in source code based on the execution trace of test cases. Failing test cases and their assertions form test oracles for the failing behavior of the system under analysis. In this paper, we propose a novel concept of spectrum driven test case purification for improving fault localization. The goal of test case purification is to separate existing test cases into small fractions (called purified test cases) and to enhance the test oracles to further localize faults. Combining with an original fault localization technique (e.g., Tarantula), test case purification results in better ranking the program statements. Our experiments on 1800 faults in six open-source Java programs show that test case purification can effectively improve existing fault localization techniques. </p></div> 
            

            </div>
          ",Test case purification; dynamic program slicing; spectrum-based fault localization; test case atomization
Test data regeneration: generating new test data from existing test data,Wiley Online Library,Test data regeneration: generating new test data from existing test data,"Yoo, Shin, and Mark Harman",42," <i>Software Testing, Verification and Reliability</i> 22, no. 3 (2012): 171-201.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">SUMMARY</h2><p>Existing automated test data generation techniques tend to start from scratch, implicitly assuming that no pre-existing test data are available. However, this assumption may not always hold, and where it does not, there may be a missed opportunity; perhaps the pre-existing test cases could be used to assist the automated generation of additional test cases. This paper introduces search-based test data regeneration, a technique that can generate additional test data from existing test data using a meta-heuristic search algorithm. The proposed technique is compared to a widely studied test data generation approach in terms of both efficiency and effectiveness. The empirical evaluation shows that test data regeneration can be up to 2 orders of magnitude more efficient than existing test data generation techniques, while achieving comparable effectiveness in terms of structural coverage and mutation score. Copyright © 2010 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test data generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">search-based software testing</span></li>"
Effective test case selection for component customization and its application to Enterprise JavaBeans,Wiley Online Library,Effective test case selection for component customization and its application to Enterprise JavaBeans,"Yoon, Hoijin, and Byoungju Choi",11," <i>Software Testing, Verification and Reliability</i> 14, no. 1 (2004): 45-70.","Component users need to customize components they obtain from providers, because providers usually develop components for general use. Although the customization is accomplished by modifying the interface of a component, faults from customization appear when the implementation part of a component and the interfaces interact. The implementation part is a black-box, whose source code is not available to a component user, while the interface is a white-box, whose source code is available for customization. Therefore, customization faults should be tested using both the black-box part and the white-box part of a component. This paper proposes a new technique to test customization faults using software fault injection and mutation testing, and the technique is tailored to Enterprise JavaBeans. Test cases are selected by injecting faults not into the entire interface but into specific parts of the component's interface. The specific parts that are chosen control the effectiveness of the test cases. An empirical study to evaluate the technique is reported. ","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test case effectiveness; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">component-based software development; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">composition; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Enterprise JavaBeans</span></li>"
Efficient Observability-based Test Generation by Dynamic Symbolic Execution,ieeexplore,Efficient observability-based test generation by dynamic symbolic execution,"You, Dongjiang, Sanjai Rayadurgam, Michael Whalen, Mats PE Heimdahl, and Gregory Gay",2," In <i>Software Reliability Engineering (ISSRE), 2015 IEEE 26th International Symposium on</i>, pp. 228-238. IEEE, 2015.","Structural coverage metrics have been widely used to measure test suite adequacy as well as to generate test cases. In previous investigations, we have found that the fault-finding effectiveness of tests satisfying structural coverage criteria is highly dependent on program syntax - even if the faulty code is exercised, its effect may not be observable at the output. To address these problems, observability-based coverage metrics have been defined. Specifically, Observable MC/DC (OMC/DC) is a criterion that appears to be both more effective at detecting faults and more robust to program restructuring than MC/DC. Traditional counterexample-based test generation for OMC/DC, however, can be infeasible on large systems. In this study, we propose an incremental test generation approach that combines the notion of observability with dynamic symbolic execution. We evaluated the efficiency and effectiveness of our approach using seven systems from the avionics and medical device domains. Our results show that the incremental approach requires much lower generation time, while achieving even higher fault finding effectiveness compared with regular OMC/DC generation.",
A search-based framework for automatic testing of MATLAB/Simulink models,Elsevier,A search-based framework for automatic testing of MATLAB/Simulink models,"Zhan, Yuan, and John A. Clark",44," <i>Journal of Systems and Software</i> 81, no. 2 (2008): 262-285.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Search-based test-data generation has proved successful for code-level testing but almost no search-based work has been carried out at higher levels of abstraction. In this paper the application of such approaches at the higher levels of abstraction offered by <em>MATLAB/Simulink</em> models is investigated and a wide-ranging framework for test-data generation and management is presented. Model-level analogues of code-level structural coverage criteria are presented and search-based approaches to achieving them are described. The paper also describes the first search-based approach to the generation of mutant-killing test data, addressing a fundamental limitation of mutation testing. Some problems remain whatever the level of abstraction considered. In particular, complexity introduced by the presence of persistent state when generating test sequences is as much a challenge at the <em>Simulink</em> model level as it has been found to be at the code level. The framework addresses this problem. Finally, a flexible approach to test sub-set extraction is presented, allowing testing resources to be deployed effectively and efficiently.</p>","<li id="""" class=""svKeywords""><span id=""""><em>MATLAB/Simulink</em></span>; </li><li id="""" class=""svKeywords""><span id="""">Test-data generation</span>; </li><li id="""" class=""svKeywords""><span id="""">Automation</span>; </li><li id="""" class=""svKeywords""><span id="""">Structural coverage</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">State problem</span>; </li><li id="""" class=""svKeywords""><span id="""">Tracing and deducing</span>; </li><li id="""" class=""svKeywords""><span id="""">Test-set reduction</span></li>"
Assertions are strongly correlated with test suite effectiveness,acm,Assertions are strongly correlated with test suite effectiveness,"Zhang, Yucheng, and Ali Mesbah",11," In <i>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</i>, pp. 214-224. ACM, 2015.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Code coverage is a popular test adequacy criterion in practice. Code coverage, however, remains controversial as there is a lack of coherent empirical evidence for its relation with test suite effectiveness. More recently, test suite size has been shown to be highly correlated with effectiveness. However, previous studies treat test methods as the smallest unit of interest, and ignore potential factors influencing this relationship. We propose to go beyond test suite size, by investigating test assertions inside test methods. We empirically evaluate the relationship between a test suite’s effectiveness and the (1) number of assertions, (2) assertion coverage, and (3) different types of assertions. We compose 6,700 test suites in total, using 24,000 assertions of five real-world Java projects. We find that the number of assertions in a test suite strongly correlates with its effectiveness, and this factor directly influences the relationship between test suite size and effectiveness. Our results also indicate that assertion coverage is strongly correlated with effectiveness and different types of assertions can influence the effectiveness of their containing test suites. </p></div> 
            

            </div>
          ",Test suite effectiveness; assertions; coverage
Bridging the gap between the total and additional test-case prioritization strategies,acm,Bridging the gap between the total and additional test-case prioritization strategies,"Zhang, Lingming, Dan Hao, Lu Zhang, Gregg Rothermel, and Hong Mei",69," In <i>Proceedings of the 2013 International Conference on Software Engineering</i>, pp. 192-201. IEEE Press, 2013.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> In recent years, researchers have intensively investigated various topics in test-case prioritization, which aims to re-order test cases to increase the rate of fault detection during regression testing. The total and additional prioritization strategies, which prioritize based on total numbers of elements covered per test, and numbers of additional (not-yet-covered) elements covered per test, are two widely-adopted generic strategies used for such prioritization. This paper proposes a basic model and an extended model that unify the total strategy and the additional strategy. Our models yield a spectrum of generic strategies ranging between the total and additional strategies, depending on a parameter referred to as the p value. We also propose four heuristics to obtain differentiated p values for different methods under test. We performed an empirical study on 19 versions of four Java programs to explore our results. Our results demonstrate that wide ranges of strategies in our basic and extended models with uniform p values can significantly outperform both the total and additional strategies. In addition, our results also demonstrate that using differentiated p values for both the basic and extended models with method coverage can even outperform the additional strategy using statement coverage. </p></div> 
            

            </div>
          ",
Taming coincidental correctness: Coverage refinement with context patterns to improve fault localization,ieeexplore,Taming coincidental correctness: Coverage refinement with context patterns to improve fault localization,"Wang, Xinming, Shing-Chi Cheung, Wing Kwong Chan, and Zhenyu Zhang",119," In <i>Software Engineering, 2009. ICSE 2009. IEEE 31st International Conference on</i>, pp. 45-55. IEEE, 2009.","Recent techniques for fault localization leverage code coverage to address the high cost problem of debugging. These techniques exploit the correlations between program failures and the coverage of program entities as the clue in locating faults. Experimental evidence shows that the effectiveness of these techniques can be affected adversely by coincidental correctness, which occurs when a fault is executed but no failure is detected. In this paper, we propose an approach to address this problem. We refine code coverage of test runs using control- and data-flow patterns prescribed by different fault types. We conjecture that this extra information, which we call context patterns, can strengthen the correlations between program failures and the coverage of faulty program entities, making it easier for fault localization techniques to locate the faults. To evaluate the proposed approach, we have conducted a mutation analysis on three real world programs and cross-validated the results with real faults. The experimental results consistently show that coverage refinement is effective in easing the coincidental correctness problem in fault localization techniques.",
Time-aware test-case prioritization using integer linear programming,acm,Time-aware test-case prioritization using integer linear programming,"Zhang, Lu, Shan-Shan Hou, Chao Guo, Tao Xie, and Hong Mei",106," In <i>Proceedings of the eighteenth international symposium on Software testing and analysis</i>, pp. 213-224. ACM, 2009.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Techniques for test-case prioritization re-order test cases to increase their rate of fault detection. When there is a fixed time budget that does not allow the execution of all the test cases, time-aware techniques for test-case prioritization may achieve a better rate of fault detection than traditional techniques for test-case prioritization. In this paper, we propose a novel approach to time-aware test-case prioritization using integer linear programming. To evaluate our approach, we performed experiments on two subject programs involving four techniques for our approach, two techniques for an approach to time-aware test-case prioritization based on genetic algorithms, and four traditional techniques for test-case prioritization. The empirical results indicate that two of our techniques outperform all the other techniques for the two subjects under the scenarios of both general and version-specific prioritization. The empirical results also indicate that some traditional techniques with lower analysis time cost for test-case prioritization may still perform competitively when the time budget is not quite tight.</p></div> 
            

            </div>
          ",integer linear programming; test-case prioritization
Test generation via dynamic symbolic execution for mutation testing,ieeexplore,Test generation via dynamic symbolic execution for mutation testing,"Zhang, Lingming, Tao Xie, Lu Zhang, Nikolai Tillmann, Jonathan De Halleux, and Hong Mei",67," In <i>Software Maintenance (ICSM), 2010 IEEE International Conference on</i>, pp. 1-10. IEEE, 2010.","Mutation testing has been used to assess and improve the quality of test inputs. Generating test inputs to achieve high mutant-killing ratios is important in mutation testing. However, existing test-generation techniques do not provide effective support for killing mutants in mutation testing. In this paper, we propose a general test-generation approach, called PexMutator, for mutation testing using Dynamic Symbolic Execution (DSE), a recent effective test-generation technique. Based on a set of transformation rules, PexMutator transforms a program under test to an instrumented meta-program that contains mutant-killing constraints. Then PexMutator uses DSE to generate test inputs for the meta-program. The mutant-killing constraints introduced via instrumentation guide DSE to generate test inputs to kill mutants automatically. We have implemented our approach as an extension for Pex, an automatic structural testing tool developed at Microsoft Research. Our preliminary experimental study shows that our approach is able to strongly kill more than 80% of all the mutants for the five studied subjects. In addition, PexMutator is able to outperform Pex, a state-of-the-art test-generation tool, in terms of strong mutant killing while achieving the same block coverage.",
An empirical study of junit test-suite reduction,ieeexplore,An empirical study of junit test-suite reduction,"Zhang, Lingming, Darko Marinov, Lu Zhang, and Sarfraz Khurshid",29," In <i>Software Reliability Engineering (ISSRE), 2011 IEEE 22nd International Symposium on</i>, pp. 170-179. IEEE, 2011.","As test suites grow larger during software evolution, regression testing becomes expensive. To reduce the cost of regression testing, test-suite reduction aims to select a minimal subset of the original test suite that can still satisfy all the test requirements. While traditional test-suite reduction techniques were intensively studied on C programs with specially generated test suites, there are limited studies for test-suite reduction on programs with real-world test suites. In this paper, we investigate test-suite reduction techniques on Java programs with real-world JUnit test suites. We implemented four representative test-suite reduction techniques for JUnit test suites. We performed an empirical study on 19 versions of four real-world Java programs, ranging from 1.89 KLoC to 80.44 KLoC. Our study investigates both the benefits and the costs of test-suite reduction. The results show that the four traditional test-suite reduction techniques can effectively reduce these JUnit test suites without substantially reducing their fault-detection capability. Based on the results, we provide a guideline for achieving cost-effective JUnit test suite reduction.",
Search-based inference of polynomial metamorphic relations,acm,Search-based inference of polynomial metamorphic relations,"Zhang, Jie, Junjie Chen, Dan Hao, Yingfei Xiong, Bing Xie, Lu Zhang, and Hong Mei",18," In <i>Proceedings of the 29th ACM/IEEE international conference on Automated software engineering</i>, pp. 701-712. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Metamorphic testing (MT) is an effective methodology for testing those so-called ``non-testable'' programs (e.g., scientific programs), where it is sometimes very difficult for testers to know whether the outputs are correct. In metamorphic testing, metamorphic relations (MRs) (which specify how particular changes to the input of the program under test would change the output) play an essential role. However, testers may typically have to obtain MRs manually.</p> <p>In this paper, we propose a search-based approach to automatic inference of polynomial MRs for a program under test. In particular, we use a set of parameters to represent a particular class of MRs, which we refer to as polynomial MRs, and turn the problem of inferring MRs into a problem of searching for suitable values of the parameters. We then dynamically analyze multiple executions of the program, and use particle swarm optimization to solve the search problem. To improve the quality of inferred MRs, we further use MR filtering to remove some inferred MRs.</p> <p>We also conducted three empirical studies to evaluate our approach using four scientific libraries (including 189 scientific functions). From our empirical results, our approach is able to infer many high-quality MRs in acceptable time (i.e., from 9.87 seconds to 1231.16 seconds), which are effective in detecting faults with no false detection.</p></div> 
            

            </div>
          ",invariant inference; metamorphic testing; particle swarm optimization
JDAMA: Java database application mutation analyser,Wiley Online Library,JDAMA: Java database application mutation analyser,"Zhou, Chixiang, and Phyllis Frankl",20," <i>Software Testing, Verification and Reliability</i> 21, no. 3 (2011): 241-263.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Database application programs are ubiquitous; hence, good techniques for testing them are needed. Several approaches to testing database applications have been proposed recently, including test generation techniques and adequacy criteria. Tuya <em>et al.</em> proposed mutation-based adequacy criteria for database queries and developed a set of mutation operators for Structured Query Language <span class=""monospace "">SELECT</span> statements. This paper extends that approach by integrating it with analysis and instrumentation of the application bytecode. The design and implementation of a tool, Java Database Application Mutation Analyser (JDAMA), are described. JDAMA instruments application bytecode so as to compare the results of queries executed by the application under test to the results of mutants of those queries. JDAMA can be used to support mutation testing for Java database applications. A second, potentially more useful application of JDAMA is to support experiments evaluating testing techniques for database applications, in which query mutation is used to seed faults into subject applications. The paper illustrates these uses of JDAMA with experiments comparing two approaches to test generation and experiments evaluating coverage criteria. Copyright © 2011 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">database application testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">empirical evaluation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Java</span></li>"
Procedures for reducing the size of coverage-based test sets,,,,,TCS,"This paper addresses the problem of reducing the size of test sets for regression testing and test output inspection. Since regression testing requires the execution of some, and in the worst case, all test cases, reducing the number of tests can have a large benefit. Additionally, testers generally have to examine the output of each test case, both during initial and regression testing. Since this is done by hand, reducing the number of outputs that need to be examined can reduce the cost of testing. We observe that for mutation-based test sets, the order in which the test cases are executed impacts the size of the test sets. This paper presents several strategies for selecting a smaller number of test cases by reordering the test tests. We illustrate our technique using a proof-of-concept empirically study using mutation testing, achieving approximately a 33\% reduction in size, and a corresponding reduction in the cost of regression testing, with a cost of only one extra run of the test case set. We suggest that these results should be extendable to apply to any test strategy that includes a quantifiable measure of test case effectiveness, such as data flow testing and branch testing, and try it with statement coverage with positive results.",
