,search_title,database,result_title,authors,citation,venue,abstract,keywords
-1,Effect of Test Set Minimization on Fault Detection Effectiveness,acm,Effect of test set minimization on fault detection effectiveness,"Wong, W. Eric, Joseph R. Horgan, Saul London, and Aditya P. Mathur",383," In <i>Proceedings of the 17th international conference on Software engineering</i>, pp. 41-50. ACM, 1995.","
  <div class=""tabbody"">
              <div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"">
                  An abstract is not available.
              </div>
                      

</div>
            ",
-1,Test Set Size Minimization and Fault Detection Effectiveness: A Case Study in a Space Application,ieeexplore,Test set size minimization and fault detection effectiveness: A case study in a space application,"Wong, W. Eric, Joseph R. Horgan, Aditya P. Mathur, and Alberto Pasquini",117," <i>Journal of Systems and Software</i> 48, no. 2 (1999): 79-89.","An important question in software testing is whether it is reasonable to apply coverage based criteria as a filter to reduce the size of a test set. An empirical study was conducted using a test set minimization technique to explore the effect of reducing the size of a test set, while keeping block coverage constant, on the fault detection strength of the resulting minimized test set. Two types of test sets were examined. For those with respect to a fixed size, no test case screening was conducted during the generation, whereas for those with respect to a fixed coverage, each subsequent test case had to improve the overall coverage in order to be included. The study reveals that no matter how a test set is generated (with or without any test case screening) block minimized test sets have a size/effectiveness advantage, in terms of a significant reduction in test set size but with almost the same fault detection effectiveness, over the original non-minimized test sets.",
-1,Fault Detection Effectiveness of Mutation and Data Flow Testing,Springer,Fault detection effectiveness of mutation and data flow testing,"Wong, W. Eric, and Aditya P. Mathur",67," <i>Software Quality Journal</i> 4, no. 1 (1995): 69-83.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">We report results from an experiment to compare the fault detection effectiveness of mutation, its variants and the all-uses data flow criteria. Adequate test sets were generated randomly, as opposed to by human testers as in some previous studies. We view our results in the light of those from earlier studies comparing mutation with path-oriented testing strategies. We identify and discuss factors that one might consider while evaluating an adequacy criterion for use in practice. Results from our experiments strengthen a hypothesis that an adequacy criterion based on one of the two variants of mutation has superior fault detection effectiveness than that of the all-uses criterion.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">effectiveness&nbsp;</span><span class=""Keyword"">data flow&nbsp;</span><span class=""Keyword"">mutation&nbsp;</span><span class=""Keyword"">constrained mutation&nbsp;</span>"
-1,Reducing the Cost of Mutation Testing: An Empirical Study,Elsevier,Reducing the cost of mutation testing: An empirical study,"Wong, W. Eric, and Aditya P. Mathur",180," <i>Journal of Systems and Software</i> 31, no. 3 (1995): 185-196.",,
-1,Mutation TestingAn Evolving Technique,ieeexplore,Mutation testing-an evolving technique,"Woodward, Martin R",26," In <i>Software Testing for Critical Systems, IEE Colloquium on</i>, pp. 3-1. IET, 1990.","The paper provides a brief review of the program testing technique known as mutation testing, an error-based testing technique. A large number of simple changes (mutations) are made to program one at a time. Test data then has to be found which distinguishes the mutated versions from the original version. An underlying assumption of mutation testing is that experienced programmers write nearly correct programs. Hence small perturbations of the original program are expected to cause an observable difference to the program's performance. Mutation testing as originally developed was considered by many as somewhat bizarre and costly to perform. Subsequently a less demanding form known as weak mutation testing was proposed and the original technique was renamed strong mutation testing. More recently firm mutation has been introduced as an intermediate approach. The author discusses these types of mutation testing. As an example of the wide applicability of the mutation approach, its use in testing algebraic specifications is considered.",
-1,OBJTEST: An Experimental Testing Tool for Algebraic Specifications,ieeexplore,OBJTEST: an experimental testing tool for algebraic specifications,"Woodward, M. R",5," In <i>Automating Formal Methods for Computer Assisted Prototying, IEE Colloquium on</i>, pp. 2-pp. IET, 1992.","Algebraic specifications involve the development of 'axioms' or equations to model the behaviour of systems. The technique is one example of a formal method of specification. By using the equations to drive a process of term-rewriting, test expressions can be evaluated, thus providing an execution facility. Such animation certainly helps in checking typographical and notational errors. However, there is still a need for thorough testing of algebraic specifications to uncover more subtle errors. The author describes in outline, a prototype testing tool for algebraic specifications, OBJTEST, built around the ObjEx system. The two principal facets of the tool are the automatic generation of 'exhaustive' sets of test expressions from a specification, followed by the use of these test expressions in mutation testing of the given specification.",
-1,Errors in Algebraic Specifications and an Experimental Mutation Testing Tool,"MR Woodward - Software Engineering Journal, 1993 - IET",Errors in algebraic specifications and an experimental mutation testing tool,"Woodward, Martin R",53," <i>Software Engineering Journal</i> 8, no. 4 (1993): 211-224.","There is an increasing trend towards more formality in the development of specifications of software systems in order to reduce the likelihood of errors as early as possible in the development process. The algebraic approach to specification, with its equational form, leads to the added advantage of executability via the process of term rewriting. Nevertheless, erroneous algebraic specifications can still be developed. As evidence of possible errors, the algebraic specifications produced by students have been analysed and the results are presented. The paper describes OBJTEST, a prototype testing system for algebraic specifications. The two principal facets of the system are the user-guided automatic generation of sets of test expressions from a specification, and then the use of these test expressions in mutation testing of the given specification. Some preliminary experience with the system is reported.",
-1,Mutation TestingIts Origin and Evolution,Elsevier,Mutation testing—its origin and evolution,"Woodward, Martin R",70," <i>Information and Software Technology</i> 35, no. 3 (1993): 163-169.",,<span>software testing</span>
-1,From Weak to Strong Dead or Alive? An Analysis of Some Mutationtesting Issues,ieeexplore,"From weak to strong, dead or alive? an analysis of some mutation testing issues","Woodward, M. R., and K. Halewood",131," In <i>Software Testing, Verification, and Analysis, 1988., Proceedings of the Second Workshop on</i>, pp. 152-158. IEEE, 1988.","The authors argue that strong mutation testing and weak mutation testing are in fact extreme ends of a spectrum of mutation approaches. The term firm mutation is introduced to represent the middle ground in this spectrum. The authors also argue, by means of a number of small examples, that there is a potential problem concerning the criterion for deciding whether a mutant is dead or live. A variety of solutions are suggested. Practical considerations for a firm-mutation testing system, with greater user control over the nature of result comparison, are discussed. Such a system is currently under development as part of an interpretive development environment.",
？,Mutation Analysis of Parameterized Unit Tests,ieeexplore,Mutation analysis of parameterized unit tests,"Xie, Tao, Nikolai Tillmann, Jonathan de Halleux, and Wolfram Schulte",8," In <i>Software Testing, Verification and Validation Workshops, 2009. ICSTW'09. International Conference on</i>, pp. 177-181. IEEE, 2009.","Recently parameterized unit testing has emerged as a promising and effective methodology to allow the separation of (1) specifying external, black-box behavior (e.g., assumptions and assertions) by developers and (2) generating and selecting internal, white-box test inputs (i.e., high-code-covering test inputs) by tools. A parameterized unit test (PUT) is simply a test method that takes parameters, specifies assumptions on the parameters, calls the code under test, and specifies assertions. The test effectiveness of PUTs highly depends on the way that they are written by developers. For example, if stronger assumptions are specified, only a smaller scope of test inputs than intended are generated by tools, leading to false negatives in terms of fault detection. If weaker assertions are specified, erroneous states induced by the test execution do not necessarily cause assertion violations, leading to false negatives. Detecting these false negatives is challenging since the insufficiently written PUTs would just pass. In this paper, we propose a novel mutation analysis approach for analyzing PUTs written by developers and identifying likely locations in PUTs for improvement. The proposed approach is a first step towards helping developers write better PUTs in practice.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.parameterized unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">parameterized unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test generation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Testing Web Services by XML Perturbation,ieeexplore,Testing web services by XML perturbation,"Xu, Wuzhi, Jeff Offutt, and Juan Luo",151," In <i>Software Reliability Engineering, 2005. ISSRE 2005. 16th IEEE International Symposium on</i>, pp. 10-pp. IEEE, 2005.","The eXtensible Markup Language (XML) is widely used to transmit data across the Internet. XML schemas are used to defile the syntax of XML messages. XML-based applications can receive messages from arbitrary applications, as long as they follow the protocol defined by the schema. A receiving application must either validate XML messages, process the data in the XML message without validation, or modify the XML message to ensure that it conforms to the XML schema. A problem for developers is how well the application performs the validation, data processing, and, when necessary, transformation. This paper describes and gives examples of a method to generate tests for XML-based communication by modifying and then instantiating XML schemas. The modified schemas are based on precisely defined schema primitive perturbation operators",
-1,Mutation-Based Inter-Class Testing,ieeexplore,Mutation-based inter-class testing,"Yoon, Hoijin, Byoungju Choi, and Jin-Ok Jeon",15," In <i>Software Engineering Conference, 1998. Proceedings. 1998 Asia Pacific</i>, pp. 174-181. IEEE, 1998.","Faults and failures due to interaction are the bane of testers. Since their subtlety makes them difficult to recognize and even more difficult to reveal by testing, it is important to specify interaction between classes systematically. In this paper, we propose mutation-based inter-class testing technique. Our inter-class testing technique consists of two procedures: test item identification procedure and test case selection procedure. For the test item identification procedure, we develop the Inheritance-Call graph (ICgraph) to identify the taxonomy of interaction of public methods between classes. For the test case selection procedure, we design a new criterion, state-based mutation testing criterion (SMTC), by applying mutation analysis to the state diagram representing class behavior. Mutation analysis is a well-known method for measuring test case adequacy which involves the mutation of a program by the introduction of small syntactic change in the program. The implementation of our proposed technique on a sample program shows that our technique leads to a set of test cases which detect errors in inter-class relation.",
？,Search-Based Mutation Testing for Simulink Models,acm,Search-based mutation testing for simulink models,"Zhan, Yuan, and John A. Clark",56," In <i>Proceedings of the 7th annual conference on Genetic and evolutionary computation</i>, pp. 1061-1068. ACM, 2005.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">The efficient and effective generation of test-data from high-level models is of crucial importance in advanced modern software engineering. Empirical studies have shown that mutation testing is highly effective. This paper describes how search-based automatic test-data generation methods can be used to find mutation adequate test-sets for <i>Matlab/Simulink</i> models.</div> 
            

            </div>
          ",Matlab/Simulink; automation; heuristic search; mutation testing; simulated annealing; test-data generation
-1,Lightweight State Based Mutation Testing for Security,ieeexplore,Lightweight State Based Mutation Testing for Security,"Zhang, Songtao, Thomas Dean, and Scott Knight",7," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 223-232. IEEE, 2007.","State based protocols are protocols in which the handling of one message depends on the contents of previous messages. Testing such protocols, for security or for other purposes usually means specifying the state space of the protocol in some manner. This paper introduces a novel method of using an existing client to explore the state space. The messages exchanged between the client and test system are captured and mutated. To send the mutated test messages, the previous messages must be resent. Constraints expressed in an extended version of the Semantic Constraint Language are used to automatically derive the data dependencies between the messages.",
-1,Mutation Testing for Java Database Applications,ieeexplore,Mutation testing for java database applications,"Zhou, Chixiang, and Phyllis Frankl",39," In <i>Software Testing Verification and Validation, 2009. ICST'09. International Conference on</i>, pp. 396-405. IEEE, 2009.","Database application programs are ubiquitous, so good techniques for testing them are needed. Recently, several research groups have proposed new approaches to generating tests for database applications and for assessing test data adequacy. This paper describes a mutation testing tool, JDAMA (Java Database Application Mutation Analyzer), for Java programs that interact with a database via the JDBC interface. Our approach extends the mutation testing approach for SQL by Tuya et al, by integrating it with analysis and instrumentation of the application bytecode. JDAMA's use is illustrated through a small study which uses mutation scores to compare two test generation techniques for database applications.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.database application.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">database application</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,System Level Mutation Analysis Applied to a State-Based Language,ieeexplore,System level mutation analysis applied to a state-based language,"Olsson, Thomas, and Per Runeson",8," In <i>Engineering of Computer Based Systems, 2001. ECBS 2001. Proceedings. Eighth Annual IEEE International Conference and Workshop on the</i>, pp. 222-228. IEEE, 2001.","One of the great challenges within software testing is to know if a test suite covers a program sufficiently. Mutation analysis is presented as an approach to address that challenge. Faulty versions, or mutants, are created, and whether the test suite is able to discover the defects is investigated. The technique is mostly applied to the unit level testing of software programs. Mutation analysis is applied to integration and system level testing in addition to unit level testing. A state based specification and description language, SDL, is used. The specific structural information is used to employ mutation analysis at different abstraction levels.",
-1,Model-Based Tests for Access Control Policies,ieeexplore,Model-Based Tests for Access Control Policies,"Mouelhi, Tejeddine, and Yves Le Traon",71,,"We present a model-based approach to testing access control requirements. By using combinatorial testing, we first automatically generate test cases from and without access control policies—i.e., the model—and assess the effectiveness of the test suites by means of mutation testing. We also compare them to purely random tests. For some of the investigated strategies, non-random tests kill considerably more mutants thanthe same number of random tests. Since we rely on policies only, no information on the application is required at this stage. As a consequence, our methodology applies to arbitrary implementations of the policy decision points.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Combinatorial Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Combinatorial Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Access Control.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Access Control</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-Based Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-Based Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Generating Test Cases for XML-Based Web Component Interactions Using Mutation Analysis,ieeexplore,Generating test cases for XML-based Web component interactions using mutation analysis,"Lee, Suet Chun, and Jeff Offutt",96," In <i>Software Reliability Engineering, 2001. ISSRE 2001. Proceedings. 12th International Symposium on</i>, pp. 200-209. IEEE, 2001.","Web software systems are built using heterogeneous software components. They interact by passing messages that exchange data and activity state information. Such heterogeneous message transfers can be structured using the eXtensible Markup Language (XML), which allows a flexible common data exchange. Parsers have been developed to check the syntax of component interactions, but there are as yet no techniques for checking the semantic correctness of the interactions. The paper presents a technique for using mutation analysis to test the semantic correctness of XML-based component interactions. The Web software interactions are specified using an Interaction Specification Model (ISM) that consists of document type definitions, messaging specifications, and a set of constraints. Test cases are XML messages that are passed between the Web software components. Classes of interaction-specific mutation operators are introduced and applied to the ISM to generate mutant interactions and test cases.",
-1,Testing the Semantics of W3C XML Schema,ieeexplore,Testing the semantics of W3C XML schema,"Li, Jian Bing, and James Miller",48," In <i>Computer Software and Applications Conference, 2005. COMPSAC 2005. 29th Annual International</i>, vol. 1, pp. 443-448. IEEE, 2005.","The XML schema language is becoming the preferred means of defining and validating highly structured XML instance documents. We have extended the conventional mutation method to be applicable for W3C XML schemas. In this paper a technique for using mutation analysis to test the semantic correctness of W3C XML schemas is presented. We introduce a mutation analysis model and a set of W3C XML schema (XSD) mutation operators that can be used to detect faults involving name-spaces, user-defined types, and inheritance. Preliminary evaluation of our technique shows that it is effectiveness to test the semantics of W3C XML schema documents.",
-1,Fault Diagnosis of Computer Programs,student report,,,,,,
-1,The Status of Research on Program Mutation,"RJ Lipton, FG Sayward - Digest for the Workshop on Software Testing and Test  …, 1978",The status of research on program mutation,"Lipton, Richard J., and Fred G. Sayward",44," In <i>Digest for the Workshop on Software Testing and Test Documentation</i>, pp. 355-373. 1978.",,
0,An Approach to Test Data Generation for Killing Multiple Mutants,ieeexplore,An approach to test data generation for killing multiple mutants,"Liu, Ming-Hao, You-Feng Gao, Jin-Hui Shan, Jiang-Hong Liu, Lu Zhang, and Jia-Su Sun",27," In <i>Software Maintenance, 2006. ICSM'06. 22nd IEEE International Conference on</i>, pp. 113-122. IEEE, 2006.","Software testing is an important technique for assurance of software quality. Mutation testing has been identified as a powerful fault-based technique for unit testing, and there has been some research on automatic generation of test data for mutation testing. However, existing approaches to this kind of test data generation usually generate test data according to one mutant at one time. Thus, more test data that are needed for achieving a given mutation score. In this paper, we propose a new approach to generating one test data according to multiple mutants that are mutated at the same location at one time. Thus, our approach can generate smaller test suite that can achieve the same mutation testing score. To evaluate our approach, we implemented a prototype tool based on our approach and carried out some preliminary experiments. The experimental results show that our approach is more cost-effective","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.adequacy criterion.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">adequacy criterion</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test data.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test data</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">generation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,The Weak Mutation Hypothesis,acm,Historical contingency and the evolution of a key innovation in an experimental population of Escherichia coli,"Blount, Zachary D., Christina Z. Borland, and Richard E. Lenski",41," <i>Proceedings of the National Academy of Sciences</i> 105, no. 23 (2008): 7899-7906.","
  <div class=""tabbody"">
              <div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"">
                  An abstract is not available.
              </div>
                      

</div>
            ",
？,A Fault Model and Mutation Testing of Access Control Policies,acm,A fault model and mutation testing of access control policies,"Martin, Evan, and Tao Xie",131," In <i>Proceedings of the 16th international conference on World Wide Web</i>, pp. 667-676. ACM, 2007.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>To increase confidence in the correctness of specified policies, policy developers can conduct policy testing by supplying typical test inputs (requests) and subsequently checking test outputs (responses) against expected ones. Unfortunately, manual testing is tedious and few tools exist for automated testing of access control policies. We present a fault model for access control policies and a framework to explore it. The framework includes mutation operators used to implement the fault model, mutant generation, equivalent-mutant detection, and mutant-killing determination. This framework allows us to investigate our fault model, evaluate coverage criteria for test generation and selection, and determine a relationship between structural coverage and fault-detection effectiveness. We have implemented the framework and applied it to various policies written in XACML. Our experimental results offer valuable insights into choosing mutation operators in mutation testing and choosing coverage criteria in test generation and selection.</p></div> 
            

            </div>
          ",access control policies; fault model; mutation testing; test generation
-1,Performance Effectiveness and Reliability Issues in Software Testing,ieeexplore,"Performance, effectiveness, and reliability issues in software testing","Mathur, Aditya P",139," In <i>Computer Software and Applications Conference, 1991. COMPSAC'91., Proceedings of the Fifteenth Annual International</i>, pp. 604-605. IEEE, 1991.",The author has identified two problems that need to be overcome in order that some of the powerful testing techniques be used in practice: performance and effectiveness. The testing methods referred to are dataflow and mutation testing.,
-1,CS 406 Software Engineering I,JR Abrial - 2010 - books.google.com,Replication's role in software engineering,"Brooks, Andrew, Marc Roper, Murray Wood, John Daly, and James Miller",1197," In <i>Guide to advanced empirical software engineering</i>, pp. 365-379. Springer London, 2008.",,
-1,Mutant Unification for Improved Vectorization,"<a href=""/citations?user=DdQMeHoAAAAJ&amp;hl=en&amp;oi=sra"">AP Mathur</a>, EW Krauser - Purdue University, West Lafayette, Indiana, Technique  …, 1988",Mutant unification for improved vectorization,"Mathur, Aditya P., and Edward W. Krauser",31," <i>Purdue University, West Lafayette, Indiana, Technique Report SERC-TR-14-P</i> (1988).",not available,
-1,An Empirical Comparison of Mutation and Data Flow Based Test Adequacy Criteria,Wiley Online Library,Toward the determination of sufficient mutant operators for C,"Barbosa, Ellen Francine, José Carlos Maldonado, and Auri Marcelo Rizzo Vincenzi",128," <i>Software Testing, Verification and Reliability</i> 11, no. 2 (2001): 113-136.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Evaluation of the adequacy of a test set consisting of one or more test cases is a problem oftes encountered in software testing environments. Two test adequacy criiteria are considered, namely the data flow based all-uses criterion and a mutation based criterion. An empirical study was conducted to compare the ‘difficulty’ of satisfying the two criteria and their costs. Similar studies conducted in the past are discussed in the light of this study. A discussion is also presented of how and why the results of this study, when viewed in conjunction with the results of earlier comparisons of testing methods, are useful to a software test team.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mutation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Data flow; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">All-uses; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Test adequacy criteria</span></li>"
-1,An Empirical Comparison of Mutation and Data Flow Based Test Adequacy Criteria,Wiley Online Library,Toward the determination of sufficient mutant operators for C,"Barbosa, Ellen Francine, José Carlos Maldonado, and Auri Marcelo Rizzo Vincenzi",128," <i>Software Testing, Verification and Reliability</i> 11, no. 2 (2001): 113-136.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Evaluation of the adequacy of a test set consisting of one or more test cases is a problem oftes encountered in software testing environments. Two test adequacy criiteria are considered, namely the data flow based all-uses criterion and a mutation based criterion. An empirical study was conducted to compare the ‘difficulty’ of satisfying the two criteria and their costs. Similar studies conducted in the past are discussed in the light of this study. A discussion is also presented of how and why the results of this study, when viewed in conjunction with the results of earlier comparisons of testing methods, are useful to a software test team.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mutation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Data flow; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">All-uses; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Test adequacy criteria</span></li>"
-1,-1,Wiley Online Library,An empirical comparison of data flow and mutation‐based test adequacy criteria,"Mathur, Aditya P., and W. Eric Wong",128," <i>Software Testing, Verification and Reliability</i> 4, no. 1 (1994): 9-31.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Evaluation of the adequacy of a test set consisting of one or more test cases is a problem oftes encountered in software testing environments. Two test adequacy criiteria are considered, namely the data flow based all-uses criterion and a mutation based criterion. An empirical study was conducted to compare the ‘difficulty’ of satisfying the two criteria and their costs. Similar studies conducted in the past are discussed in the light of this study. A discussion is also presented of how and why the results of this study, when viewed in conjunction with the results of earlier comparisons of testing methods, are useful to a software test team.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mutation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Data flow; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">All-uses; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Test adequacy criteria</span></li>"
-1,How Strong is Weak Mutation?,acm,Weak mutation is probably strong mutation,"Horgan, J. Robert, and Aditya P. Mathur",47," <i>Purdue University, West Lafayette, Indiana, Technical Report SERC-TR-83-P</i> (1990).","
  <div class=""tabbody"">
              <div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"">
                  An abstract is not available.
              </div>
                      

</div>
            ",
-1,An Experimental Mutation System for Java,acm,An experimental mutation system for Java,"Offutt, Jeff, Yu-Seung Ma, and Yong-Rae Kwon",72," <i>ACM SIGSOFT Software Engineering Notes</i> 29, no. 5 (2004): 1-4.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">Mutation is a powerful but complicated and computationally expensive testing method. Mutation is also a valuable experimental research technique that has been used in many studies. Mutation has been experimentally compared with other test criteria, and also used to support experimental comparisons of other test criteria, by using mutants as a method to create faults. In effect, mutation is often used as a ""gold standard"" for experimental evaluations of test methods. This paper presents a publicly available mutation system for Java that supports both traditional statement-level mutants and newer inter-class mutants. MUJAVA can be freely downloaded and installed with relative ease under both Unix and Windows. MUJAVA is offered as a free service to the community and we hope that it will promote the use of mutation analysis for experimental research in software testing.</div> 
            

            </div>
          ",http://dl.acm.org/citation.cfm?id=1022494.1022537
-1,Detecting Equivalent Mutants and the Feasible Path Problem,ieeexplore,Detecting equivalent mutants and the feasible path problem,"Ofutt, A., and Jie Pan",77," <i>The Journal of Software Testing, Verification, and Reliability</i> 7, no. 3 (1997): 165-192.","Mutation testing is a technique for testing software units that has great potential for improving the quality of testing, and thereby increasing our ability to assure the high reliability of critical software. The paper presents a technique that uses mathematical constraints to automatically detect equivalent mutant programs. The paper also describes how the approach is used for the feasible path problem. The paper describes how test criteria are formalized as mathematical constraint systems, how equivalent mutants are represented as infeasible constraints, and how infeasible constraints are detected. A proof of concept implementation has been developed to demonstrate this technique, and experimental results from using this tool are presented. Limitations of the system and the method are described, and proposals for improvements are made.",
-1,Automatically Detecting Equivalent Mutants and Infeasible Paths,Wiley Online Library,Automatically detecting equivalent mutants and infeasible paths,"Offutt, A. Jefferson, and Jie Pan",256," <i>Software testing, verification and reliability</i> 7, no. 3 (1997): 165-192.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Mutation testing is a technique for testing software units that has great potential for improving the quality of testing, and thereby increasing the ability to assure the high reliability of critical software. It will be shown that recent advances in mutation research have brought a practical mutation testing system closer to reality. One recent advance is a partial solution to the problem of automatically detecting equivalent mutant programs. Equivalent mutants are currently detected by hand, which makes it very expensive and time-consuming. The problem of detecting equivalent mutants is a specific instance of a more general problem, commonly called the <em>feasible path problem</em>, which says that for certain structural testing criteria some of the test requirements are infeasible in the sense that the semantics of the program imply that no test case satisfies the test requirements. Equivalent mutants, unreachable statements in path testing techniques, and infeasible DU-pairs in data flow testing are all instances of the feasible path problem. This paper presents a technique that uses mathematical constraints, originally developed for test data generation, to detect some equivalent mutants and infeasible paths automatically. © 1997 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">constraints; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">feasible path analysis</span></li>"
-1,An Experimental Evaluation of Data Flow and Mutation Testing,"<a href=""/citations?user=fAeRp3kAAAAJ&amp;hl=en&amp;oi=sra"">AJ Offutt</a>, J Pan, K Tewary, T Zhang - Softw., Pract. Exper., 1996 - cs.drexel.edu",An experimental evaluation of data flow and mutation testing,"Offutt, A. Jefferson, Jie Pan, Kanupriya Tewary, and Tong Zhang",188," <i>Softw., Pract. Exper.</i> 26, no. 2 (1996): 165-176.",,
-1,Mutation Testing of Software Using a MIMD Computer,,Mutation Testing of Software Using a MIMD Computer,"Pargas, Roy P., Scott V. Fichter, and Prashant K. Khambekar",53,,,
-1,An Experimental Evaluation of Selective Mutation,acm,An experimental evaluation of selective mutation,"Offutt, A. Jefferson, Gregg Rothermel, and Christian Zapf",267," In <i>Proceedings of the 15th international conference on Software Engineering</i>, pp. 100-107. IEEE Computer Society Press, 1993.","
  <div class=""tabbody"">
              <div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"">
                  An abstract is not available.
              </div>
                      

</div>
            ",
-1,Mutation Operators for Ada,"<a href=""/citations?user=fAeRp3kAAAAJ&amp;hl=en&amp;oi=sra"">AJ Offutt</a>, <a href=""/citations?user=rCGvoJ8AAAAJ&amp;hl=en&amp;oi=sra"">J Voas</a>, J Payne - 1996 - cs.gmu.edu",The rigorous generation of Java mutation operators using HAZOP,"Kim, Sunwoo, John Clark, and John McDermid",93," <i>Informe técnico, The University of York</i> (1999).",,
-1,Generating Test Cases for Web Services Using Data Perturbation,acm,Exploring perturbation based testing for web services,"De Almeida, Lourival F. Junior, and Silvia R. Vergilio",231," In <i>Web Services, 2006. ICWS'06. International Conference on</i>, pp. 717-726. IEEE, 2006.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">Web services have the potential to dramatically reduce the complexities and costs of software integration projects. The most obvious and perhaps most significant difference between Web services and traditional applications is that Web services use a common communication infrastructure, XML and SOAP, to communicate through the Internet. The method of communication introduces complexities to the problems of verifying and validating Web services that do not exist in traditional software. This paper presents a new approach to testing Web services based on <b>data perturbation.</b> Existing XML messages are modified based on rules defined on the message grammars, and then used as tests. Data perturbation uses two methods to test Web services: data value perturbation and interaction perturbation. Data value perturbation modifies values according to the data type. Interaction perturbation classifies the communication messages into two categories: RPC communication and data communication. At present, this method is restricted to peer-to-peer interactions. The paper presents preliminary empirical evidence of its usefulness.</div> 
            

            </div>
          ",http://dl.acm.org/citation.cfm?id=1022494.1022529
-1,Software Technology Maturation,acm,A critique of diffusion theory as a managerial framework for understanding adoption of software engineering innovations,"Bayer, Judy, and Nancy Melone",212," <i>Journal of Systems and Software</i> 9, no. 2 (1989): 161-166.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">It is commonly thought that 10 years is needed for technology to pass from its initial conception into wide-spread use. In the process of gathering data to argue the need for a technology improvement program, we investigated the technology maturation process for three environments supporting software development. Our hypothesis was that more than 10 years was needed; our guess was that the period would be more on the order of 15 years; and we found that it takes on the order of 18 years for systems such as these to nature. Technology maturation time lines for the three systems are presented and some comments are provided on what facilitates and inhibits software technology maturation.</div> 
            

            </div>
          ",http://dl.acm.org/citation.cfm?id=1010925.1010927
？,Towards a Mutation-Based Automatic Framework for Evaluating Code Clone Detection Tools ,acm,A mutation/injection-based automatic framework for evaluating code clone detection tools,"Roy, Chanchal K., and James R. Cordy",16," In <i>Software Testing, Verification and Validation Workshops, 2009. ICSTW'09. International Conference on</i>, pp. 157-166. IEEE, 2009.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>In the last decade, a great many code clone detection tools have been proposed. Such a large number of tools calls for a quantitative comparison, and there have been several attempts to empirically evaluate and compare many of the state-of-the-art tools. However, a recent study shows that there are several factors that could influence the the validity of the results of such comparisons. In order to overcome the effects of such factors (at least in part), in this student poster paper we outline a mutation-based controlled frame-work for evaluating clone detection tools using edit-based mutation operators that model cloning actions. While the framework is not yet completely implemented and as yet we do not have experimental data, we anticipate that such a framework will provide a useful contribution to the community by providing a more solid objective foundation for tool evaluation.</p></div> 
            

            </div>
          ",clone detection techniques; evaluation; framework; maintenance; mutation analysis; software engineering
？,A Mutation/Injection-Based Automatic Framework for Evaluating Code Clone Detection Tools,ieeexplore,A mutation/injection-based automatic framework for evaluating code clone detection tools,"Roy, Chanchal K., and James R. Cordy",108," In <i>Software Testing, Verification and Validation Workshops, 2009. ICSTW'09. International Conference on</i>, pp. 157-166. IEEE, 2009.","In recent years many methods and tools for software clone detection have been proposed. While some work has been done on assessing and comparing performance of these tools, very little empirical evaluation has been done. In particular, accuracy measures such as precision and recall have only been roughly estimated, due both to problems in creating a validated clone benchmark against which toolscan be compared, and to the manual effort required to hand check large numbers of candidate clones. In this paper we propose an automated method for empirically evaluating clone detection tools that leverages mutation-based techniques to overcome these limitations by automatically synthesizing large numbers of known clones based on an editing theory of clone creation. Our framework is effective in measuring recall and precision of clone detection tools for various types of fine-grained clones in real systems without manual intervention.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.clone detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">clone detection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical evaluation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical evaluation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,CUTE: A Concolic Unit Testing Engine for C,acm,Combining unit-level symbolic execution and system-level concrete execution for testing NASA software,"Pǎsǎreanu, Corina S., Peter C. Mehlitz, David H. Bushnell, Karen Gundy-Burlet, Michael Lowry, Suzette Person, and Mark Pape",1504," In <i>Proceedings of the 2008 international symposium on Software testing and analysis</i>, pp. 15-26. ACM, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">In <i>unit testing</i>, a program is decomposed into units which are collections of functions. A part of unit can be tested by generating inputs for a single entry function. The entry function may contain pointer arguments, in which case the inputs to the unit are <i>memory graphs</i>. The paper addresses the problem of automating unit testing with memory graphs as inputs. The approach used builds on previous work combining <i>symbolic</i> and <i>concrete execution</i>, and more specifically, using such a combination to <i>generate test inputs</i> to explore all feasible execution paths. The current work develops a method to represent and track constraints that capture the behavior of a symbolic execution of a unit with memory graphs as inputs. Moreover, an efficient constraint solver is proposed to facilitate incremental generation of such test inputs. Finally, CUTE, a tool implementing the method is described together with the results of applying CUTE to real-world examples of C code.</div> 
            

            </div>
          ",concolic testing; data structure testing; explicit path model-checking; random testing; testing C programs; unit testing
-1,Functional Verification of RTL Designs Driven by Mutation Testing Metrics,ieeexplore,Functional verification of RTL designs driven by Mutation Testing metrics,"Serrestou, Youssef, and Vincent Beroulle Chantal Robach",27," In <i>Digital System Design Architectures, Methods and Tools, 2007. DSD 2007. 10th Euromicro Conference on</i>, pp. 222-227. IEEE, 2007.","The level of confidence in a VHDL description directly depends on the quality of its verification. This quality can be evaluated by mutation-based test, but the improvement of this quality requires tremendous efforts. In this paper, we propose a new approach that both qualifies and improves the functional verification process. First, we qualify test cases thanks to the mutation testing metrics: faults are injected in the design under verification (DUV) (making DUV's mutants) to check the capacity of test cases to detect theses mutants. Then, a heuristic is used to automatically improve IPs validation data. Experimental results obtained on RTL descriptions from ITC'99 benchmark show how efficient is our approach.",
-1,Impact of Hardware Emulation on the Verification Quality Improvement,ieeexplore,Impact of hardware emulation on the verification quality improvement,"Serrestou, Youssef, Vincent Beroulle, and Chantal Robach",3," In <i>Very Large Scale Integration, 2007. VLSI-SoC 2007. IFIP International Conference on</i>, pp. 218-223. IEEE, 2007.","Software simulation remains the most used method for VHDL RTL functional verification. The functional verification process essentially consists of two parts. The first one is the functional qualification; the second one is the qualification- driven stimuli generation. Currently, the qualification and the generation tasks are iterative processes based on VHDL simulation which is dramatically time consuming. The simulation time increases with the circuits’ size and the required level of quality. In our previous works, we have proposed some approaches based on the mutation testing technique to evaluate and to improve functional validation quality. Now, to reduce this simulation time, we propose in this paper a new approach based on FPGA emulation. So, an hardware-software platform called “Meta-Mutant Testbench” is used to emulate mutants. Experimental results for some ITC’99 benchmark circuits show that our mutation emulator is about 20 times faster than classical software simulators; this speedup increases with the circuits’ size.",
-1,MUSIC: Mutation-Based SQL Injection Vulnerability Checking,ieeexplore,MUSIC: Mutation-based SQL injection vulnerability checking,"Shahriar, Hossain, and Mohammad Zulkernine",80," In <i>Quality Software, 2008. QSIC'08. The Eighth International Conference on</i>, pp. 77-86. IEEE, 2008.","SQL injection is one of the most prominent vulnerabilities for web-based applications. Exploitation of SQL injection vulnerabilities (SQLIV) through successful attacks might result in severe consequences such as authentication bypassing, leaking of private information etc. Therefore, testing an application for SQLIV is an important step for ensuring its quality. However, it is challenging as the sources of SQLIV vary widely, which include the lack of effective input filters in applications, insecure coding by programmers, inappropriate usage of APIs for manipulating databases etc. Moreover, existing testing approaches do not address the issue of generating adequate test data sets that can detect SQLIV. In this work, we present a mutation-based testing approach for SQLIV testing. We propose nine mutation operators that inject SQLIV in application source code. The operators result in mutants, which can be killed only with test data containing SQL injection attacks. By this approach, we force the generation of an adequate test data set containing effective test cases capable of revealing SQLIV. We implement a MUtation-based SQL Injection vulnerabilities Checking (testing) tool (MUSIC) that automatically generates mutants for the applications written in Java Server Pages (JSP) and performs mutation analysis. We validate the proposed operators with five open source web-based applications written in JSP. We show that the proposed operators are effective for testing SQLIV.",
？,Mutation-Based Testing of Buffer Overflow Vulnerabilities,ieeexplore,Mutation-based testing of buffer overflow vulnerabilities,"Shahriar, Hossain, and Mohammad Zulkernine",28," In <i>Computer Software and Applications, 2008. COMPSAC'08. 32nd Annual IEEE International</i>, pp. 979-984. IEEE, 2008.","Buffer overflow (BOF) is one of the major vulnerabilities that leads to non-secure software.Testing an implementation for BOF vulnerabilities is challenging as the underlying reasons of buffer overflow vary widely. Moreover, the existing vulnerability testing approaches do not address the issue of generating adequate test data sets for testing BOF vulnerabilities. In this work, we apply the idea of mutation-based testing technique to generate adequate test data set for BOF vulnerabilities. Our work addresses those BOF vulnerabilities, which are related to an implementation language and its associated libraries. We apply the concept for ANSI Clanguage and its associated libraries. We propose 12 mutation operators to force the generation of adequate test data set for BOF vulnerabilities. The proposed operators are validated by using four open source programs. The results indicate that the proposed operators are effective for testing BOF vulnerabilities.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Vulnerabilities.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Vulnerabilities</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Buffer overflow.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Buffer overflow</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation-based testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
?,Mutation-Based Testing of Format String Bugs,ieeexplore,Mutation-based testing of format string bugs,"Shahriar, Hossain, and Mohammad Zulkernine",16," In <i>High Assurance Systems Engineering Symposium, 2008. HASE 2008. 11th IEEE</i>, pp. 229-238. IEEE, 2008.","Format String Bugs (FSBs) make an implementation vulnerable to numerous types of malicious attacks. Testing an implementation against FSBs can avoid consequences due to exploits of FSBs such as denial of services, corruption of application states, etc. Obtaining an adequate test data set is essential for testing of FSBs. An adequate test data set contains effective test cases that can reveal FSBs. Unfortunately, traditional techniques do not address the issue of adequate testing of an application for FSB. Moreover, the application of source code mutation has not been applied for testing FSB. In this work, we apply the idea of mutation-based testing technique to generate an adequate test data set for testing FSBs. Our work addresses FSBs related to ANSI C libraries. We propose eight mutation operators to force the generation of adequate test dataset. A prototype mutation-based testing tool named MUFORMAT is developed to generate mutants automatically and perform mutation analysis. The proposed operators are validated by using four open source programs having FSBs. The results indicate that the proposed operators are effective for testing FSBs.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Test data adequacy.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Test data adequacy</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Format String Bugs.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Format String Bugs</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation-based Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation-based Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,MUTEC: Mutation-Based Testing of Cross Site Scripting,acm,Mutec: Mutation-based testing of cross site scripting,"Shahriar, Hossain, and Mohammad Zulkernine",52," In <i>Proceedings of the 2009 ICSE Workshop on Software Engineering for Secure Systems</i>, pp. 47-53. IEEE Computer Society, 2009.","


 ",dynamic HTML content; mutation-based testing technique; cross site scripting; malicious attack; XSS vulnerability; Web-application; PHP; JavaScript code
-1,Fault Coverage of Protocol Test Methods,ieeexplore,FAULT COVERAGE or PROTOCOL TEST METHODS,"Mls, E",53,,"The authors present an estimation of fault coverage of four protocol test sequences generation techniques (T-, U-, D-, and W-methods) using Monte Carlo simulation on a simple protocol machine. The ability of a test sequence to decide whether a protocol implementation conforms to its specification heavily relies upon the range of faults that it can capture. This study shows that a test sequence produced by T-method has a poor fault detection capability whereas test sequences produced by U-, D- and W-methods have fault coverage comparable to each other and superior to that for T-method on several classes of randomly generated machines used.",
-1,A Transformational Language for Mutant Description,Elsevier,A transformational language for mutant description,"Simão, Adenilso, José Carlos Maldonado, and Roberto da Silva Bigonha",9," <i>Computer Languages, Systems &amp; Structures</i> 35, no. 3 (2009): 322-339.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Mutation testing has been used to assess the quality of test case suites by analyzing the ability in distinguishing the artifact under testing from a set of alternative artifacts, the so-called mutants. The mutants are generated from the artifact under testing by applying a set of mutant operators, which produce artifacts with simple syntactical differences. The mutant operators are usually based on typical errors that occur during the software development and can be related to a fault model. In this paper, we propose a language—named <span id=""mmlsi6"" class=""mathmlsrc""><span class=""formulatext stixSupport mathImg"" data-mathurl=""/science?_ob=MathURL&amp;_method=retrieve&amp;_eid=1-s2.0-S1477842408000420&amp;_mathId=si6.gif&amp;_user=111111111&amp;_pii=S1477842408000420&amp;_rdoc=1&amp;_issn=14778424&amp;md5=c9b4a6103852f83e76d344501aacec3e"" title=""Click to view the MathML source"">MuDeL</span><span class=""mathContainer hidden""><span class=""mathCode""><math altimg=""si6.gif"" overflow=""scroll""><mi mathvariant=""script"">M</mi><mi>u</mi><mi mathvariant=""script"">D</mi><mi>e</mi><mi mathvariant=""script"">L</mi></math></span><!--mathContainer--></span><!--Loading Mathjax--></span> (MUtant DEfinition Language)—for the definition of mutant operators, aiming not only at automating the mutant generation, but also at providing precision and formality to the operator definition. The proposed language is based on concepts from transformational and logical programming paradigms, as well as from context-free grammar theory. Denotational semantics formal framework is employed to define the semantics of the <span id=""mmlsi7"" class=""mathmlsrc""><span class=""formulatext stixSupport mathImg"" data-mathurl=""/science?_ob=MathURL&amp;_method=retrieve&amp;_eid=1-s2.0-S1477842408000420&amp;_mathId=si7.gif&amp;_user=111111111&amp;_pii=S1477842408000420&amp;_rdoc=1&amp;_issn=14778424&amp;md5=b46c1012c5c7374c28a5054fbd10ae46"" title=""Click to view the MathML source"">MuDeL</span><span class=""mathContainer hidden""><span class=""mathCode""><math altimg=""si7.gif"" overflow=""scroll""><mi mathvariant=""script"">M</mi><mi>u</mi><mi mathvariant=""script"">D</mi><mi>e</mi><mi mathvariant=""script"">L</mi></math></span><!--mathContainer--></span><!--Loading Mathjax--></span> language. We also describe a system—named <tt>mudelgen</tt>—developed to support the use of this language. An executable representation of the denotational semantics of the language is used to check the correctness of the implementation of <tt>mudelgen</tt>. At the very end, a mutant generator module is produced, which can be incorporated into a specific mutant tool/environment.</p>","<li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Transformation languages</span>; </li><li id="""" class=""svKeywords""><span id="""">Logical languages</span>; </li><li id="""" class=""svKeywords""><span id="""">Software testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Prototyping</span></li>"
-1,An Empirical Evaluation of the MuJava Mutation Operators,ieeexplore,An empirical evaluation of the MuJava mutation operators,"Smith, Ben H., and Laurie Williams",54," In <i>Testing: academic and industrial conference practice and research techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 193-202. IEEE, 2007.","Mutation testing is used to assess the fault-finding effectiveness of a test suite. Information provided by mutation testing can also be used to guide the creation of additional valuable tests and/or to reveal faults in the implementation code. However, concerns about the time efficiency of mutation testing may prohibit its widespread, practical use. We conducted an empirical study using the MuClipse automated mutation testing plug-in for Eclipse on the back end of a small web-based application. The first objective of our study was to categorize the behavior of the mutants generated by selected mutation operators during successive attempts to kill the mutants. The results of this categorization can be used to inform developers in their mutant operator selection to improve the efficiency and effectiveness of their mutation testing. The second outcome of our study identified patterns in the implementation code that remained untested after attempting to kill all mutants.",
0,On Guiding the Augmentation of an Automated Test Suite via Mutation Analysis,Springer,On guiding the augmentation of an automated test suite via mutation analysis,"Smith, Ben H., and Laurie Williams",39," <i>Empirical Software Engineering</i> 14, no. 3 (2009): 341-369.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Mutation testing has traditionally been used as a defect injection technique to assess the effectiveness of a test suite as represented by a “mutation score.” Recently, mutation testing tools have become more efficient, and industrial usage of mutation analysis is experiencing growth. Mutation analysis entails adding or modifying test cases until the test suite is sufficient to detect as many mutants as possible and the mutation score is satisfactory. The augmented test suite resulting from mutation analysis may reveal latent faults and provides a stronger test suite to detect future errors which might be injected. Software engineers often look for guidance on how to augment their test suite using information provided by line and/or branch coverage tools. As the use of mutation analysis grows, software engineers will want to know how the emerging technique compares with and/or complements coverage analysis for guiding the augmentation of an automated test suite. Additionally, software engineers can benefit from an enhanced understanding of efficient mutation analysis techniques. To address these needs for additional information about mutation analysis, we conducted an empirical study of the use of mutation analysis on two open source projects. Our results indicate that a focused effort on increasing mutation score leads to a corresponding increase in line and branch coverage to the point that line coverage, branch coverage and mutation score reach a maximum but leave some types of code structures uncovered. Mutation analysis guides the creation of additional “common programmer error” tests beyond those written to increase line and branch coverage. We also found that 74% of our chosen set of mutation operators is useful, on average, for producing new tests. The remaining 26% of mutation operators did not produce new test cases because their mutants were immediately detected by the initial test suite, indirectly detected by test suites we added to detect other mutants, or were not able to be detected by any test.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Line coverage&nbsp;</span><span class=""Keyword"">Fault injection&nbsp;</span><span class=""Keyword"">Empirical effectiveness&nbsp;</span><span class=""Keyword"">Test case augmentation&nbsp;</span><span class=""Keyword"">Mutation analysis&nbsp;</span><span class=""Keyword"">Mutation testing tool&nbsp;</span><span class=""Keyword"">Statement coverage&nbsp;</span><span class=""Keyword"">Test adequacy&nbsp;</span><span class=""Keyword"">Web application&nbsp;</span><span class=""Keyword"">Open source&nbsp;</span><span class=""Keyword"">Unit testing&nbsp;</span>"
?,Mutation Testing Applied to Validate SDL Specifications,,Mutation testing applied to validate SDL specifications,"Sugeta, Tatiana, José Carlos Maldonado, and W. Eric Wong",47," In <i>IFIP International Conference on Testing of Communicating Systems</i>, pp. 193-208. Springer Berlin Heidelberg, 2004.",,
?,TDS: A Tool for Testing Distributed Component-Based Applications,,Tds: a tool for testing distributed component-based applications,"Ghosh, Sudipto, Priya Govindarajan, and Aditya P. Mathur",7," In <i>Mutation testing for the new century</i>, pp. 103-112. Springer US, 2001.",,
-1,Interface Mutation to Assess the Adequacy of Tests for Components and Systems,ieeexplore,Interface Mutation to Assess the Adequacy of Tests for Componentsand Systems,"Ghosh, S., and A. P. Mathur",13," In <i>Proceedings of the 34th International Conference on Technology of Object-Oriented Languages and Systems (TOOLS’00)</i>, p. 37.",Interface Mutation (IM) is proposed as an adequacy criterion to assess the adequacy of test sets developed to test components and systems. IM uses the description of a component's interface to generate interface mutants. Tests are assessed on their ability to distinguish interface mutants. Experiments conducted to evaluate the goodness of IM are reported. Analysis of experimental data suggests that test sets adequate with respect to IM are effective in revealing errors in components. The effort required to develop the tests is lower compared to the effort required to develop test sets adequate with respect to the traditional code coverage criteria based on control flow.,
-1,Interface Mutation,ieeexplore,Interface mutation test adequacy criterion: An empirical evaluation,"Delamaro, Márcio Eduardo, José Carlos Maldonado, Alberto Pasquini, and Aditya P. Mathur",262," <i>Empirical Software Engineering</i> 6, no. 2 (2001): 111-142.","The need for test adequacy criteria is widely recognized. Several criteria have been proposed for the assessment of adequacy of tests at the unit level. However, there remains a lack of criteria for the assessment of the adequacy of tests generated during integration testing. We present a mutation based interprocedural criterion, named Interface Mutation (IM), suitable for use during integration testing. A case study to evaluate the proposed criterion is reported. In the study, the UNIX sort utility was seeded with errors and Interface Mutation evaluated by measuring the cost of its application and its error revealing effectiveness. Alternative IM criteria using different sets of Interface Mutation operators were also evaluated. While comparing the error revealing effectiveness of these Interface Mutation-based test sets with same size randomly generated test sets, we observed that in most cases Interface Mutation based test sets are superior. The results suggest that Interface Mutation offers a viable test adequacy criteria for use at the integration level.",
-1,An Integrated System for Program Testing Using Weak Mutation and Data Flow Analysis,acm,An integrated system for program testing using weak mutation and data flow analysis,"Girgis, Moheb R., and Martin R. Woodward",75," In <i>Proceedings of the 8th international conference on Software engineering</i>, pp. 313-319. IEEE Computer Society Press, 1985.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>The idea of weak mutation testing is to construct test data which would force program components such as expressions and variable references to produce a wrong 'result' if they were to contain certain types of error, for example, off-by-a-constant or wrong-variable. The idea of data flow driven testing is to construct test data which forces the execution of different interactions between variable definitions and references in a program.</par>
<par>This paper describes a tool for FORTRAN 77 programs which has been developed to help a user apply the weak mutation and data flow testing techniques. The tool instruments a given source program and collects a program execution history. It is then able to report on the completeness of the test data with respect to weak mutation and a family of data flow path selection criteria. Some preliminary experiments with use of the tool are described.</par>
</div> 
            

            </div>
          ",
-1,DART: Directed Automated Random Testing,acm,DART: Directed Automated Random Testing,"Sen, Koushik",2088," In <i>Haifa Verification Conference</i>, vol. 6405, p. 4. 2009.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) <i>automated</i> extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs <i>random</i> testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to <i>direct</i> systematically the execution along alternative program paths. Together, these three techniques constitute <i>Directed Automated Random Testing</i>, or <i>DART</i> for short. The main strength of DART is thus that testing can be performed <i>completely automatically</i> on any program that compiles -- there is no need to write any test driver or harness code. During testing, DART detects standard errors such as program crashes, assertion violations, and non-termination. Preliminary experiments to unit test several examples of C programs are very encouraging.</div> 
            

            </div>
          ",automated test generation; interfaces; program verification; random testing; software testing
?,Program Testing by Specification Mutation,Elsevier,Program testing by specification mutation,"Budd, Timothy A., and Ajei S. Gopal",70," <i>Computer languages</i> 10, no. 1 (1985): 63-73.",,<span>Testing</span>
-1,The Impact of Equivalent Mutants,ieeexplore,The impact of equivalent mutants,"Grün, Bernhard JM, David Schuler, and Andreas Zeller",97," In <i>Software Testing, Verification and Validation Workshops, 2009. ICSTW'09. International Conference on</i>, pp. 192-199. IEEE, 2009.","If a mutation is not killed by a test suite, this usuallymeans that the test suite is not adequate. However, itmay also be that the mutant keeps the program’s seman-tics unchanged—and thus cannot be detected by any test.We found such equivalent mutants to be surprisingly com-mon: In an experiment on the JAXEN XPATH query engine,8/20 = 40% of all mutations turned out to be equivalent.Worse, checking the equivalency took us 15 minutes for asingle mutation. Equivalent mutants thus make it impossi-ble to automatically assess test suites by means of mutationtesting. To identify equivalent mutants, we are currently investi-gating the impact of a mutation on the execution: the morea mutation alters the execution, the higher the chance of itbeing non-equivalent. First experiments assessing the im-pact on code coverage are promising.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.code coverage.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">code coverage</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.equivalent mutants.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">equivalent mutants</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Testing Programs with the Aid of a Compiler,ieeexplore,Testing programs with the aid of a compiler,"Hamlet, Richard G",479, <i>IEEE Transactions on Software engineering</i> 4 (1977): 279-290.,"if finite input-output specifications are added to the syntax of programs, these specifications can be verified at compile time. Programs which carry adequate tests with them in this way should be resistant to maintenance errors. If the specifications are independent of program details they are easy to give, and unlikely to contain errors in common with the program. Furthermore, certain finite specifications are maximal in that they exercise the control and expression structure of a program as well as any tests can.",
？,The Relationship between Program Dependence and Mutation Analysis,Springer,The relationship between program dependence and mutation analysis,"Harman, Mark, Rob Hierons, and Sebastian Danicic",44," In <i>Mutation testing for the new century</i>, pp. 5-13. Springer US, 2001.","
                          <h2 class=""Heading"">Abstract</h2>
                          <div class=""Para"">This paper presents some connections between dependence anal­ysis and mutation testing. Specifically, dependence analysis can be applied to two problems in mutation testing, captured by the questions:
            <div class=""OrderedList""><ol><li class=""ListItem""><span class=""ItemNumber"">1.</span><div class=""ItemContent"">
                                  <p class=""Para"">How do we avoid the creation of equivalent mutants?</p>
                                </div><div class=""ClearBoth"">&nbsp;</div></li><li class=""ListItem""><span class=""ItemNumber"">2.</span><div class=""ItemContent"">
                                  <p class=""Para"">How do we generate test data that kills non-equivalent mu­tants?</p>
                                </div><div class=""ClearBoth"">&nbsp;</div></li></ol></div>
                          </div>
                          <p class=""Para"">The theoretical connections described here suggest ways in which a dependence analysis tool might be used, in combination with existing tools for mutation testing, for test-data generation and equivalent-mutant detection.</p>
                          <p class=""Para"">In this paper the variable orientated, fine grained dependence framework of Jackson and Rollins is used to achieve these two goals. Yhis framework of dependence analysis appears to be better suited to mutation testing than the more traditional, Program Dependence Graph (PDG) approach, used in slicing and other forms of program analysis.</p>
                          <p class=""Para"">The relationship between dependence analysis and muataion testing is used to defined an augmented mutation testing process, with starts and ends with dependence analysis phases. The pre-analysis removes a class of equivalent mutants from further analysis, while the post-analysis phase is used to simplify the human effort required ti study the few mutants that evade the automated phases of the process.</p>
                        ","
                          <h3 class=""Heading"">Keywords</h3>
                          <span class=""Keyword"">Slicing</span>
                          <span class=""Keyword"">Dependence Analysis</span>
                          <span class=""Keyword"">Test Data Generation</span>
                          <span class=""Keyword"">Equivalent Mutant Detection</span>
                        "
-1,Using Program Slicing to Assist in the Detection of Equivalent Mutants,Wiley Online Library,Using program slicing to assist in the detection of equivalent mutants,"Hierons, Rob, Mark Harman, and Sebastian Danicic",196," <i>Software Testing, Verification and Reliability</i> 9, no. 4 (1999): 233-262.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>While mutation testing has proved to be an effective way of finding software faults, currently it is only applied to relatively small programs. One of the main reasons for this is the human analysis required in detecting equivalent mutants. Here program slicing is used to simplify this problem. Progam slicing is also used to reduce the number of equivalent mutants produced. Copyright © 1999 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">program slicing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">equivalent mutants; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">stubborn mutants</span></li>"
-1,Mutation Testing from Probabilistic Finite State Machines,ieeexplore,Mutation testing from probabilistic finite state machines,"Hierons, Robert M., and Mercedes G. Merayo",26," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 141-150. IEEE, 2007.","Mutation testing traditionally involves mutating a program in order to produce a set of mutants and using these mutants in order to either estimate the effectiveness of a test suite or to drive test generation. Recently, however, this approach has been applied to specifications such as those written as finite state machines. This paper extends mutation testing to finite state machine models in which transitions have associated probabilities. The paper describes several ways of mutating a probabilistic finite state machine (PFSM) and shows how test sequences that distinguish between a PFSM and its mutants can be generated. Testing then involves applying each test sequence multiple times, observing the resultant output sequences and using results from statistical sampling theory in order to compare the observed frequency of each output sequence with that expected.",
1,Mutation Testing from Probabilistic and Stochastic Finite State Machines,Elsevier,Mutation testing from probabilistic and stochastic finite state machines,"Hierons, Robert M., and Mercedes G. Merayo",37," <i>Journal of Systems and Software</i> 82, no. 11 (2009): 1804-1818.",,<span>Mutation testing</span>
-1,Weak Mutation is Probably Strong Mutation,"JR Horgan, <a href=""/citations?user=DdQMeHoAAAAJ&amp;hl=en&amp;oi=sra"">AP Mathur</a> - Purdue University, West Lafayette, Indiana, Technical  …, 1990",Weak mutation is probably strong mutation,"Horgan, J. Robert, and Aditya P. Mathur",36," <i>Purdue University, West Lafayette, Indiana, Technical Report SERC-TR-83-P</i> (1990).",,
-1,Applying Interface-Contract Mutation in Regression Testing of Component-Based Software,ieeexplore,Applying interface-contract mutation in regression testing of component-based software,"Hou, Shan-Shan, Lu Zhang, Tao Xie, Hong Mei, and Jia-Su Sun",21," In <i>Software Maintenance, 2007. ICSM 2007. IEEE International Conference on</i>, pp. 174-183. IEEE, 2007.","Regression testing, which plays an important role in software maintenance, usually relies on test adequacy criteria to select and prioritize test cases. However, with the wide use and reuse of black-box components, such as reusable class libraries and COTS components, it is challenging to establish test adequacy criteria for testing software systems built on components whose source code is not available. Without source code or detailed documents, the misunderstanding between the system integrators and component providers has become a main factor of causing faults in component-based software. In this paper, we apply mutation on interface contracts, which can describe the rights and obligations between component users and providers, to simulate the faults that may occur in this way of software development. The mutation adequacy score for killing the mutants of interface contracts can serve as a test adequacy criterion. We performed an experimental study on three subject systems to evaluate the proposed approach together with four other existing criteria. The experimental results show that our adequacy criterion is helpful for both selecting good-quality test cases and scheduling test cases in an order of exposing faults quickly in regression testing of component-based software.",
-1,Weak Mutation Testing and Completeness of Test Sets,ieeexplore,Weak mutation testing and completeness of test sets,"Howden, William E",491, <i>IEEE Transactions on Software Engineering</i> 4 (1982): 371-379.,"Different approaches to the generation of test data are described. Error-based approaches depend on the definition of classes of commonly occurring program errors. They generate tests which are specifically designed to determine if particular classes of errors occur in a program. An error-based method called weak mutation testing is described. In this method, tests are constructed which are guaranteed to force program statements which contain certain classes of errors to act incorrectly during the execution of the program over those tests. The method is systematic, and a tool can be built to help the user apply the method. It is extensible in the sense that it can be extended to cover additional classes of errors. Its relationship to other software testing methods is discussed. Examples are included.",
-1,Systematic Structural Testing of Firewall Policies,ieeexplore,Systematic structural testing of firewall policies,"Hwang, JeeHyun, Tao Xie, Fei Chen, and Alex X. Liu",22," <i>IEEE Transactions on Network and Service Management</i> 9, no. 1 (2012): 1-11.","Firewalls are the mainstay of enterprise security and the most widely adopted technology for protecting private networks. As the quality of protection provided by a firewall directly depends on the quality of its policy (i.e., configuration), ensuring the correctness of security policies is important and yet difficult.To help ensure the correctness of a firewall policy, we propose a systematic structural testing approach for firewall policies. We define structural coverage (based on coverage criteria of rules, predicates, and clauses) on the policy under test. Considering achieving higher structural coverage effectively, we develop three automated packet generation techniques: the random packet generation, the one based on local constraint solving (considering individual rules locally in a policy), and the most sophisticated one based on global constraint solving (considering multiple rules globally in a policy).We have conducted an experiment on a set of real policies and a set of faulty policies to detect faults with generated packet sets. Generally, our experimental results show that a packet set with higher structural coverage has higher fault detection capability (i.e., detecting more injected faults). Our experimental results show that a reduced packet set (maintaining the same level of structural coverage with the corresponding original packet set) maintains similar fault detection capability with the original set.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Firwall Policy.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Firwall Policy</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Structural Coverage.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Structural Coverage</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Test Generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Test Generation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Parallel Firm Mutation of Java Programs,,Towards measurement of testability of concurrent object-oriented programs using fault insertion: a preliminary investigation,"Ghosh, Sudipto",12," In <i>Source Code Analysis and Manipulation, 2002. Proceedings. Second IEEE International Workshop on</i>, pp. 17-25. IEEE, 2002.",,
-1,A Novel Method of Mutation Clustering Based on Domain Analysis,"C Ji, <a href=""/citations?user=HQWxCnkAAAAJ&amp;hl=en&amp;oi=sra"">Z Chen</a>, B Xu, Z Zhao - SEKE, 2009 - researchgate.net",A Novel Method of Mutation Clustering Based on Domain Analysis,"Ji, Changbin, Zhenyu Chen, Baowen Xu, and Zhihong Zhao",40," In <i>SEKE</i>, vol. 9, pp. 422-425. 2009.",,
-1,Mutation Testing Repository,ieeexplore,Efficient multi-objective higher order mutation testing with genetic programming,"Langdon, William B., Mark Harman, and Yue Jia",793," <i>Journal of systems and Software</i> 83, no. 12 (2010): 2416-2430.","Mutation Testing is a fault-based software testing technique that has been widely studied for over three decades. The literature on Mutation Testing has contributed a set of approaches, tools, developments, and empirical results. This paper provides a comprehensive analysis and survey of Mutation Testing. The paper also presents the results of several development trend analyses. These analyses provide evidence that Mutation Testing techniques and tools are reaching a state of maturity and applicability, while the topic of Mutation Testing itself is the subject of increasing interest.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.survey..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">survey.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Constructing Subtle Faults Using Higher Order Mutation Testing,ieeexplore,Constructing subtle faults using higher order mutation testing,"Jia, Yue, and Mark Harman",125," In <i>Source Code Analysis and Manipulation, 2008 Eighth IEEE International Working Conference on</i>, pp. 249-258. IEEE, 2008.","Traditional mutation testing considers only first order mutants, created by the injection of a single fault. Often these first order mutants denote trivial faults that are easily killed. This paper investigates Higher Order Mutants (HOMs). It introduces the concept of a subsuming HOM; one that is harder to kill than the first order mutants from which it is constructed. By definition, subsuming HOMs denote subtle fault combinations. The paper reports the results of an empirical study into subsuming HOMs, using six benchmark programs. This is the largest study of mutation testing to date. To overcome the exponential explosion in the number of mutants considered, the paper introduces a search based approach to the identification of subsuming HOMs. Results are presented for a greedy algorithm, a genetic algorithm and a hill climbing algorithm.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.coupling hypothesis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">coupling hypothesis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.search based software engineering.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">search based software engineering</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,MILU: A Customizable Runtime-Optimized Higher Order Mutation Testing Tool for the Full C Language,ieeexplore,"MILU: A customizable, runtime-optimized higher order mutation testing tool for the full C language","Jia, Yue, and Mark Harman",104," In <i>Practice and Research Techniques, 2008. TAIC PART'08. Testing: Academic &amp; Industrial Conference</i>, pp. 94-98. IEEE, 2008.","This paper introduces MILU, a C mutation testing tool designed for both first order and higher order mutation testing. All previous mutation testing tools apply all possible mutation operators to the program under test. By contrast, MILU allows customization of the set of mutation operators to be applied. To reduce runtime cost, MILU uses a novel 'test harness' technique to embed mutants and their associated test sets into a single-invocation procedure.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing tool.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing tool</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.MILU.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">MILU</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Mutation Testing of Protocol Messages Based on Extended TTCN-3,ieeexplore,Mutation testing of protocol messages based on extended TTCN-3,"Jing, Chuanming, Zhiliang Wang, Xingang Shi, Xia Yin, and Jianping Wu",16," In <i>Advanced Information Networking and Applications, 2008. AINA 2008. 22nd International Conference on</i>, pp. 667-674. IEEE, 2008.","The critical requirement on reliability, fault-tolerance and security of network devices highlights the necessity of protocol robustness testing. Mutation testing of protocol messages is an important part of robustness testing, but related theory and practices are not well developed. This paper builds a NFSM model for mutation testing of protocol messages and proposes two types of Normal-Verification Sequence to enhance verdict mechanism. For single-field mutation testing of protocol messages, we propose the concept of compound anomalous test case to further simplify test sequences. As a standard test specification language, TTCN-3 reveals strong excellence in conformance testing, so we apply TTCN-3 to mutation testing and extend it according to test requirements. Using our method we test OSPFv2 sufficiently with a test system based on extended TTCN-3. The results indicate that our method has good capability of error-finding.",
-1,Formal Analysis of Coupling Hypothesis for Logical Faults,Springer,Formal analysis of coupling hypothesis for logical faults,"Kapoor, Kalpesh",14," <i>Innovations in Systems and Software Engineering</i> 2, no. 2 (2006): 80-87.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Fault-based testing focuses on detecting faults in a software. Test data is typically generated considering the presence of a single fault at a time, under the assumption of coupling hypothesis. Fault-based testing approach, in particular mutation testing, assumes that the coupling hypothesis holds. According to the hypothesis, a test set that can detect presence of single faults in an implementation, is also likely to detect presence of multiple faults. In this paper it is formally shown that the hypothesis is guaranteed to hold for a large number of logical fault classes.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Software testing&nbsp;</span><span class=""Keyword"">Fault-based testing&nbsp;</span><span class=""Keyword"">Logical fault&nbsp;</span><span class=""Keyword"">Boolean specification&nbsp;</span><span class=""Keyword"">Mutation testing&nbsp;</span>"
-1,MUGAMMA: Mutation Analysis of Deployed Software to Increase Confidence Assist Evolution,ieeexplore,Mugamma: Mutation analysis of deployed software to increase confidence and assist evolution,"Kim, Sang-Woon, Mary Jean Harrold, and Yong-Rae Kwon",15," In <i>Mutation Analysis, 2006. Second Workshop on</i>, pp. 10-10. IEEE, 2006.","This paper presents a novel approach to unit testing that lets users of deployed software assist in performing mutation testing of the software. Our technique, MUGAMMA, provisions a software system so that when it executes in the field, it will determine whether users' executions would have killed mutants (without actually executing the mutants), and if so, captures the state information about those executions. In the absence of bug reports, knowledge of executions that would have killed mutants provides additional confidence in the system over that gained by the testing performed before deployment. Captured information about the state before and after execution of units (e.g., methods) can be used to construct test cases for use in unit testing when changes are made to the software. The paper also describes our prototype MuGamma implementation along with a case study that demonstrates its potential efficacy.",
-1,Assessing Test Set Adequacy for Object Oriented Programs Using Class Mutation,28 JAIIO: Symposium on Software Technology,Assessing Test Set Adequacy for ObjectOriented Programs Using,"Kim, Sun-woo, John A. Clark, and John A. Mcdermid",29," In <i>Class Mutation, 28 JAIIO: Symposium on Software Technology (SoST99</i>. 1999.",The object-oriented paradigm has seen widespread acceptance by the software development community but the testing of programs written in object oriented languages is less well developed than the testing of programs written in conventional ones. This paper introduces Class Mutation which is a form of OO-directed selective mutation testing that provides a means of assessing how good developed test sets are for OO programs. Experimental results are given for the application of three particular mutation operators for the Java language to assess test sets developed to satisfy a conventional criterion. ,
-1,The Rigorous Generation of Java Mutation Operators Using HAZOP,"S Kim, <a href=""/citations?user=xu3n6owAAAAJ&amp;hl=en&amp;oi=sra"">J Clark</a>, J McDermid - Informe técnico, The  …, 1999 - pdfs.semanticscholar.org",The rigorous generation of Java mutation operators using HAZOP,"Kim, Sunwoo, John Clark, and John McDermid",101," <i>Informe técnico, The University of York</i> (1999).",,
-1,Class Mutation: Mutation Testing for Object-Oriented Programs,Proc. Net. ObjectDays. 2000.,Class mutation: Mutation testing for object-oriented programs,"Kim, Sunwoo, John A. Clark, and John A. McDermid",151," In <i>Proc. Net. ObjectDays</i>, pp. 9-12. 2000.",,
0,Investigating the Effectiveness of Object-Oriented Testing Strategies Using theMutation Method,Wiley Online Library,Investigating the effectiveness of object‐oriented testing strategies using the mutation method,"Kim, Sun‐Woo, John A. Clark, and John A. McDermid",86," <i>Software Testing, Verification and Reliability</i> 11, no. 4 (2001): 207-225.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>The mutation method assesses test quality by examining the ability of a test set to distinguish syntactic deviations representing specific types of faults from the program under test. This paper describes an empirical study performed to evaluate the effectiveness of object-oriented (OO) test strategies using the mutation method. The test sets for the experimental system are generated according to three selected OO test strategies and their effectiveness is compared by determining how well the developed test sets kill injected mutants derived from an established mutation system Mothra and the authors' own OO-specific mutation technique which is termed Class Mutation. Copyright © 2001 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">object-oriented testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Java; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Class Mutation</span></li>"
-1,A Fortran Language System for Mutation-Based Software Testing,Wiley Online Library,A fortran language system for mutation‐based software testing,"King, Kim N., and A. Jefferson Offutt",397," <i>Software: Practice and Experience</i> 21, no. 7 (1991): 685-718.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Mutation analysis is a powerful technique for testing software systems. The Mothra software testing project uses mutation analysis as the basis for an integrated software testing environment. Mutation analysis requires executing many slightly differing versions of the same program to evaluate the quality of the data used to test the program. The current version of Mothra includes a complete language system that translates a program to be tested into intermediate code so that it and its mutated versions can be executed by an interpreter.</p><p>In this paper, we discuss some of the unique requirements of a language system used in a mutation-based testing environment. We then describe how these requirements affected the design and implementation of the Fortran 77 version of the Mothra system. We also describe the intermediate language used by Mothra and the features of the language system that are needed for software testing. The appendices contain a full description of the intermediate language and the mutation operators used by Mothra.</p><p>The design and implementation techniques that were developed for Mothra are applicable for constructing not just software testing systems, but any type of program analysis system or language system for a special-purpose application. In particular, we discuss decisions made and techniques developed by the Mothra team that can be useful in such applications as debuggers, program measurement tools, software development environments and other types of program analysis systems.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Fortran; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Intermediate code; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Interpreters; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mothra; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Software testing</span></li>"
-1,High Performance Software Testing on SIMD Machines,ieeexplore,High performance software testing on SIMD machines,"Krauser, Edward W., Aditya P. Mathur, and Vernon J. Rego",67," <i>IEEE Transactions on Software Engineering</i> 17, no. 5 (1991): 403-423.","A method for high-performance, software testing, called mutant unification, is described. The method is designed to support program mutation on parallel machines based on the single instruction multiple data stream (SIMD) paradigm. Several parameters that affect the performance of unification have been identified and their effect on the time to completion of a mutation test cycle and speedup has been studied. Program mutation analysis provides an effective means for determining the reliability of large software systems and a systematic method for measuring the adequacy of test data. However, it is likely that testing large software systems using mutation is computation bound and prohibitive on traditional sequential machines. Current, implementations of mutation tools are unacceptably slow and are only suitable for testing relatively small programs. The proposed unification method provides a practical alternative to the current approaches. The method also opens up a new application domain for SIMD machines.",
-1,High Performance Software Testing on SIMD Machines,ieeexplore,High performance software testing on SIMD machines,"Krauser, Edward W., Aditya P. Mathur, and Vernon J. Rego",67," <i>IEEE Transactions on Software Engineering</i> 17, no. 5 (1991): 403-423.","A method for high-performance, software testing, called mutant unification, is described. The method is designed to support program mutation on parallel machines based on the single instruction multiple data stream (SIMD) paradigm. Several parameters that affect the performance of unification have been identified and their effect on the time to completion of a mutation test cycle and speedup has been studied. Program mutation analysis provides an effective means for determining the reliability of large software systems and a systematic method for measuring the adequacy of test data. However, it is likely that testing large software systems using mutation is computation bound and prohibitive on traditional sequential machines. Current, implementations of mutation tools are unacceptably slow and are only suitable for testing relatively small programs. The proposed unification method provides a practical alternative to the current approaches. The method also opens up a new application domain for SIMD machines.",
-1,Multi Objective Higher Order Mutation Testing with Genetic Programming,ieeexplore,Multi objective higher order mutation testing with genetic programming,"Langdon, William B., Mark Harman, and Yue Jia",30," In <i>Testing: Academic and Industrial Conference-Practice and Research Techniques, 2009. TAIC PART'09.</i>, pp. 21-29. IEEE, 2009.","In academic empirical studies, mutation testing has been demonstrated to be a powerful technique for fault finding.However, it remains very expensive and the few valuable traditional mutants that resemble real faults are mixed in with many others that denote unrealistic faults.These twin problems of expense and realism have been a significant barrier to industrial uptake of mutation testing.Genetic programming is used to search the space of complex faults (higher order mutants). The space is much larger than the traditional first order mutation space of simple faults.However, the use of a search based approach makes this scalable, seeking only those mutants that challenge the tester,while the consideration of complex faults addresses the problem of fault realism; it is known that 90% of real faults are complex (i.e. higher order).We show that we are able to find examples that pose challenges totesting in the higher order space that cannot be represented in thefirst order space.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.tcas.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">tcas</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Pareto optimality.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Pareto optimality</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.higher order mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">higher order mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.genetic programming.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">genetic programming</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.triangle.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">triangle</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.schedule.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">schedule</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Multi Objective Mutation Testing with Genetic Programming,,A niched Pareto genetic algorithm for multiobjective optimization,"Horn, Jeffrey, Nicholas Nafpliotis, and David E. Goldberg",3416," In <i>Evolutionary Computation, 1994. IEEE World Congress on Computational Intelligence., Proceedings of the First IEEE Conference on</i>, pp. 82-87. Ieee, 1994.",,
-1,Design by Contract to Improve Software Vigilance,ieeexplore,Design by contract to improve software vigilance,"Le Traon, Yves, Benoit Baudry, and J-M. Jézéquel",76," <i>IEEE Transactions on Software Engineering</i> 32, no. 8 (2006): 571-586.","Design by contract is a lightweight technique for embedding elements of formal specification (such as invariants, pre and postconditions) into an object-oriented design. When contracts are made executable, they can play the role of embedded, online oracles. Executable contracts allow components to be responsive to erroneous states and, thus, may help in detecting and locating faults. In this paper, we define vigilance as the degree to which a program is able to detect an erroneous state at runtime. Diagnosability represents the effort needed to locate a fault once it has been detected. In order to estimate the benefit of using design by contract, we formalize both notions of vigilance and diagnosability as software quality measures. The main steps of measure elaboration are given, from informal definitions of the factors to be measured to the mathematical model of the measures. As is the standard in this domain, the parameters are then fixed through actual measures, based on a mutation analysis in our case. Several measures are presented that reveal and estimate the contribution of contracts to the overall quality of a system in terms of vigilance and diagnosability","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Object-oriented design methods.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Object-oriented design methods</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.programming by contract.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">programming by contract</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.diagnostics.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">diagnostics</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.metrics..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">metrics.</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Testing Security Policies: Going Beyond Functional Testing,ieeexplore,Testing security policies: going beyond functional testing,"Le Traon, Yves, Tejeddine Mouelhi, and Benoit Baudry",83," In <i>Software Reliability, 2007. ISSRE'07. The 18th IEEE International Symposium on</i>, pp. 93-102. IEEE, 2007.","While important efforts are dedicated to system functional testing, very few works study how to test specifically security mechanisms, implementing a security policy. This paper introduces security policy testing as a specific target for testing. We propose two strategies for producing security policy test cases, depending if they are built in complement of existing functional test cases or independently from them. Indeed, any security policy is strongly connected to system functionality: testing functions includes exercising many security mechanisms. However, testing functionality does not intend at putting to the test security aspects. We thus propose test selection criteria to produce tests from a security policy. To quantify the effectiveness of a set of test cases to detect security policy flaws, we adapt mutation analysis and define security policy mutation operators. A library case study, a 3-tiers architecture, is used to obtain experimental trends. Results confirm that security must become a specific target of testing to reach a satisfying level of confidence in security mechanisms.",
-1,Automatic Mutation Testing and Simulation on OWL-S Specified Web Services,ieeexplore,Automatic mutation testing and simulation on OWL-S specified web services,"Lee, Shufang, Xiaoying Bai, and Yinong Chen",40," In <i>Simulation Symposium, 2008. ANSS 2008. 41st Annual</i>, pp. 149-156. IEEE, 2008.","Web Ontology Language for Services (OWL-S) is a standard XML-based language for specifying workflows and integration semantics among Web services (WS), which form composite WS. This paper analyzes the fault patterns of OWL-S specified composite WS and their workflows, proposes an ontology-based mutation analysis method, and applies specification-based mutation techniques for composite WS simulation and testing. Four categories of OWL-S mutant operators are specified, including data mutation, condition mutation, control flow mutation, and data flow mutation. Finally, the paper studies the ontology-based input mutation technique using a BookFinder service as a case study, which shows that ontology-based mutation provides viable test adequacy criteria for testing OWL-S specified composite WS.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Simulation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Simulation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Ontology.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Ontology</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.OWL-S.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">OWL-S</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Web services.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Web services</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,MuJava: An Automated Class Mutation System,Wiley Online Library,MuJava: An automated class mutation system,"Ma, Yu‐Seung, Jeff Offutt, and Yong Rae Kwon",578," <i>Software Testing, Verification and Reliability</i> 15, no. 2 (2005): 97-133.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Several module and class testing techniques have been applied to object-oriented (OO) programs, but researchers have only recently begun developing test criteria that evaluate the use of key OO features such as inheritance, polymorphism, and encapsulation. Mutation testing is a powerful testing technique for generating software tests and evaluating the quality of software. However, the cost of mutation testing has traditionally been so high that it cannot be applied without full automated tool support. This paper presents a method to reduce the execution cost of mutation testing for OO programs by using two key technologies, mutant schemata generation (MSG) and bytecode translation. This method adapts the existing MSG method for mutants that change the program behaviour and uses bytecode translation for mutants that change the program structure. A key advantage is in performance: only two compilations are required and both the compilation and execution time for each is greatly reduced. A mutation tool based on the MSG/bytecode translation method has been built and used to measure the speedup over the separate compilation approach. Experimental results show that the MSG/bytecode translation method is about five times faster than separate compilation. Copyright © 2004 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">object-oriented programs; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing</span></li>"
-1,MuJava: A Mutation System for Java,acm,MuJava: a mutation system for Java,"Ma, Yu-Seung, Jeff Offutt, and Yong-Rae Kwon",132," In <i>Proceedings of the 28th international conference on Software engineering</i>, pp. 827-830. ACM, 2006.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">Mutation testing is a valuable experimental research technique that has been used in many studies. It has been experimentally compared with other test criteria, and also used to support experimental comparisons of other test criteria, by using mutants as a method to create faults. In effect, mutation is often used as a ``gold standard'' for experimental evaluations of test methods. Although mutation testing is powerful, it is a complicated and computationally expensive testing method. Therefore, automated tool support is indispensable for conducting mutation testing. This demo presents a publicly available mutation system for Java that supports both method-level mutants and class-level mutants. M<sc>u</sc>J<sc>ava</sc> can be freely downloaded and installed with relative ease under both Unix and Windows. M<sc>u</sc>J<sc>ava</sc> is offered as a free service to the community and we hope that it will promote the use of mutation analysis for experimental research in software testing.</div> 
            

            </div>
          ",java; mutation system; mutation testing
-1,Search-Based Software Test Data Generation: A Survey,Wiley Online Library,Search‐based software test data generation: a survey,"McMinn, Phil",1186," <i>Software testing, Verification and reliability</i> 14, no. 2 (2004): 105-156.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>The use of metaheuristic search techniques for the automatic generation of test data has been a burgeoning interest for many researchers in recent years. Previous attempts to automate the test generation process have been limited, having been constrained by the size and complexity of software, and the basic fact that, in general, test data generation is an undecidable problem. Metaheuristic search techniques offer much promise in regard to these problems. Metaheuristic search techniques are high-level frameworks, which utilize heuristics to seek solutions for combinatorial problems at a reasonable computational cost. To date, metaheuristic search techniques have been applied to automate test data generation for structural and functional testing; the testing of grey-box properties, for example safety constraints; and also non-functional properties, such as worst-case execution time. This paper surveys some of the work undertaken in this field, discussing possible new future directions of research for each of its different individual areas. Copyright © 2004 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">search-based software engineering; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">automated software test data generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">evolutionary testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">metaheuristic search; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">evolutionary algorithms; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">simulated annealing</span></li>"
-1,Jester and Pester,"I Moore - http:/<b>jester</b>. sourceforge. net, 2001",The Fantastic Secret of Owen Jester,"Bush, Elizabeth",3," <i>Bulletin of the Center for Children's Books</i> 64, no. 2 (2010): 59-60.",,
-1,A Generic Metamodel For Security Policies Mutation,,,,,,,
-1,,ieeexplore,Domain-Specific multi-modeling of security concerns in service-oriented architectures,"Gallino, Juan Pedro Silva, Miguel de Miguel, Javier F. Briones, and Alejandro Alonso",26," In <i>International Workshop on Web Services and Formal Methods</i>, pp. 128-142. Springer Berlin Heidelberg, 2011.",analysis of Security Policies test cases. We propose a metamodel that provides a generic representation of security policies access control models and define a set of mutation operators at this generic level. We use Kermeta to build the metamodel and implement the mutation operators. We also illustrate our approach with two successful instantiation of this metamodel: we defined policies with RBAC and OrBAC and mutated these policies.,
-1,Mutation Analysis for Security Tests Qualification,ieeexplore,Mutation analysis for security tests qualification,"Mouelhi, Tejeddine, Yves Le Traon, and Benoit Baudry",29," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 233-242. IEEE, 2007.","In this paper, we study how mutation analysis can be adapted to qualify test cases aiming at testing a security policy. The objective is to make test cases efficient to reveal erroneous implementations of a security policy. The notion of security policy testing is studied and mutation operators are defined in relation with the security rules. To make the approach applicable in practice we discuss and empirically rank the security mutation operators from the most to the least difficult to kill. The empirical study is a library software, which is implemented with a typical 3-tier architecture.",
-1,Efficiency of Mutation Operators and Selective Mutation Strategies: An Empirical Study,"ES Mresa, L Bottaci - Software Testing Verification and Reliability, 1999 - hull.ac.uk",Efficiency of mutation operators and selective mutation strategies: An empirical study,"Mresa, Elfurjani S., and Leonardo Bottaci",112," <i>Software Testing Verification and Reliability</i> 9, no. 4 (1999): 205-232.",,
-1,Finding Sufficient Mutation Operators via Variable Reduction,"<a href=""/citations?user=7XR_zpwAAAAJ&amp;hl=en&amp;oi=sra"">AS Namin</a>, JH Andrews - Proceedings of the 2nd Workshop on  …, 2006 - depts.ttu.edu",Finding sufficient mutation operators via variable reduction,"Namin, A. Siami, and James H. Andrews",32," In <i>Proceedings of the 2nd Workshop on Mutation Analysis (MUTATION’06)</i>, p. 5. 2006.",,
-1,On Sufficiency of Mutants,ieeexplore,Non-photochemical quenching. A response to excess light energy,"Müller, Patricia, Xiao-Ping Li, and Krishna K. Niyogi",22," <i>Plant physiology</i> 125, no. 4 (2001): 1558-1566.","Mutation is the practice of automatically generating possibly faulty variants of a program, for the purpose of assessing the adequacy of a test suite or comparing testing techniques. The cost of mutation often makes its application infeasible. The cost of mutation is usually assessed in terms of the number of mutants, and consequently the number of ""mutation operators"" that produce them. We address this problem by finding a smaller subset of mutation operators, called ""sufficient"", that can model the behaviour of the full set. To do this, we provide an experimental procedure and adapt statistical techniques proposed for variable reduction, model selection and nonlinear regression. Our preliminary results reveal interesting information about mutation operators.",
-1,Sufficient Mutation Operators for Measuring Test Effectiveness,acm,Sufficient mutation operators for measuring test effectiveness,"Siami Namin, Akbar, James H. Andrews, and Duncan J. Murdoch",130," In <i>Proceedings of the 30th international conference on Software engineering</i>, pp. 351-360. ACM, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Mutants are automatically-generated, possibly faulty variants of programs. The mutation adequacy ratio of a test suite is the ratio of non-equivalent mutants it is able to identify to the total number of non-equivalent mutants. This ratio can be used as a measure of test effectiveness. However, it can be expensive to calculate, due to the large number of different mutation operators that have been proposed for generating the mutants.</p> <p>In this paper, we address the problem of finding a small set of mutation operators which is still sufficient for measuring test effectiveness. We do this by defining a statistical analysis procedure that allows us to identify such a set, together with an associated linear model that predicts mutation adequacy with high accuracy. We confirm the validity of our procedure through cross-validation and the application of other, alternative statistical analyses.</p></div> 
            

            </div>
          ",mutation analysis; testing effectiveness
-1,Mutation-Based Testing Criteria for Timeliness,ieeexplore,Mutation-based testing criteria for timeliness,"Nilsson, Robert, Jeff Offutt, and Sten F. Andler",22," In <i>Computer Software and Applications Conference, 2004. COMPSAC 2004. Proceedings of the 28th Annual International</i>, pp. 306-311. IEEE, 2004.","Temporal correctness is crucial to the dependability of real-time systems. Few methods exist to test for temporal correctness and most existing methods are ad-hoc. A problem with testing real-time applications is the dependency on the execution time and execution order of individual tasks. Thus, the response times for the tasks may be non-deterministic with respect to inputs. Conventional test coverage criteria ignore task interleaving and tinting and, thus do not help determine which execution orders need to be exercised to test for temporal correctness. This paper presents test criteria based on mutation to test timeliness. We also show how previously proposed methods in specification based testing, can be applied to testing real-time systems",
?,Test Case Generation for Mutation-Based Testing of Timeliness,Elsevier,Test case generation for mutation-based testing of timeliness,"Nilsson, Robert, Jeff Offutt, and Jonas Mellin",40," <i>Electronic Notes in Theoretical Computer Science</i> 164, no. 4 (2006): 97-114.","Temporal correctness is crucial for real-time systems. Few methods exist to test temporal correctness and most methods used in practice are ad-hoc. A problem with testing real-time applications is the response-time dependency on the execution order of concurrent tasks. Execution order in turn depends on execution environment properties such as scheduling protocols, use of mutual exclusive resources as well as the point in time when stimuli is injected. Model based mutation testing has previously been proposed to determine the execution orders that need to be verified to increase confidence in timeliness. An effective way to automatically generate such test cases for dynamic real-time systems is still needed. This paper presents a method using heuristic-driven simulation to generate test cases.",<span>Real-time Systems</span>
0,Procedures for Reducing the Size of Coverage-Based Test Sets,"<a href=""/citations?user=92zEWQUAAAAJ&amp;hl=en&amp;oi=sra"">J Pan</a>, LT Center - Proceedings of International Conference on Testing  …, 1995 - cs.gmu.edu",Procedures for reducing the size of coverage-based test sets,"Pan, Jie, and Loudon Tech Center",167, In <i>Proceedings of International Conference on Testing Computer Software</i>. 1995.,,
-1,The Coupling Effect: Fact or Fiction,acm,The coupling effect: fact or fiction,"Offutt, A",118," In <i>ACM SIGSOFT Software Engineering Notes</i>, vol. 14, no. 8, pp. 131-140. ACM, 1989.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>Fault-based testing strategies test software by focusing on specific, common types of errors. The <italic>coupling effect</italic> states that test data sets that detect simple types of faults are sensitive enough to detect more complex types of faults. This paper describes empirical investigations into the coupling effect over a specific domain of software faults. All the results from this investigation support the validity of the coupling effect. The major conclusion from this investigation is that by explicitly testing for simple faults, we are also implicitly testing for more complicated faults. This gives us confidence that fault-based testing is an effective means of testing software.</par>
</div> 
            

            </div>
          ",ACM SIGSOFT Software Engineering Notes
-1,Investigations of the Software Testing Coupling Effect,acm,Investigations of the software testing coupling effect,"Offutt, A. Jefferson",344," <i>ACM Transactions on Software Engineering and Methodology (TOSEM)</i> 1, no. 1 (1992): 5-20.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>Fault-based testing strategies test software by focusing on specific, common types of faults. The <italic>coupling effect</italic> hypothesizes that test data sets that detect simple types of faults are sensitive enough to detect more complex types of faults. This paper describes empirical investigations into the coupling effect over a specific class of software faults. All of the results from this investigation support the validity of the coupling effect. The major conclusion from this investigation is the fact that by explicitly testing for simple faults, we are also implicitly testing for more complicated faults, giving us confidence that fault-based testing is an effective way to test software.</par></div> 
            

            </div>
          ",http://dl.acm.org/citation.cfm?id=125489.125473
-1,Mutation Testing Implements Grammar-Based Testing ,ieeexplore,Mutation testing implements grammar-based testing,"Offutt, Jeff, Paul Ammann, and Lisa Liu",39," In <i>Mutation Analysis, 2006. Second Workshop on</i>, pp. 12-12. IEEE, 2006.","This paper presents an abstract view of mutation analysis. Mutation was originally thought of as making changes to program source, but similar kinds of changes have been applied to other artifacts, including program specifications, XML, and input languages. This paper argues that mutation analysis is actually a way to modify any software artifact based on its syntactic description, and is in the same family of test generation methods that create inputs from syntactic descriptions. The essential characteristic of mutation is that a syntactic description such as a grammar is used to create tests. We call this abstract view grammar-based testing, and view it as an interface, which mutation analysis implements. This shift in view allows mutation to be defined in a general way, yielding three benefits. First, it provides a simpler way to understand mutation. Second, it makes it easier to develop future applications of mutation analysis, such as finite state machines and use case collaboration diagrams. The third benefit, which due to space limitations is not explored in this paper, is ensuring that existing techniques are complete according to the criteria defined here.",
-1,Using Compiler Optimization Techniques to Detect Equivalent Mutants,Wiley Online Library,Using compiler optimization techniques to detect equivalent mutants,"Offutt, A. Jefferson, and W. Michael Craft",146," <i>Software Testing, Verification and Reliability</i> 4, no. 3 (1994): 131-154.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Mutation analysis is a software testing technique that requires the tester to generate test data that will find specific, well-defined errors. Mutation testing executes many slightly differing versions, called <em>mutants</em>, of the same program to evaluate the quality of the data used to test the program. Although these mutants are generated and executed efficiently by automated methods, many of the mutants are functionally <em>equivalent</em> to the original program and are not useful for testing. Recognizing and eliminating equivalent mutants is currently done by hand, a time-consuming and arduous task. This problem is currently a major obstacle to the practical application of mutation testing.</p><p>This paper presents extensions to previous work in detecting equivalent mutants; specifically, algorithms for determining several classes of equivalent mutants are presented, an implementation of these algorithms is discussed, and results from using this implementation are presented. These algorithms are based on data flow analysis and six compiler optimization techniques. Each of these techniques is described together with how they are used to detect equivalent mutants. The design of the tool and some experimental results using it are also presented.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Compiler optimizations; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Experimental software engineering</span></li>"
?,The Dynamic Domain Reduction Approach for Test Data Generation: Design and Algorithms,"<a href=""/citations?user=fAeRp3kAAAAJ&amp;hl=en&amp;oi=sra"">AJ Offutt</a>, Z Jin, J Pan - George Mason University, Fairfax, Virginia, Technical  …, 1994",The dynamic domain reduction approach for test data generation: Design and algorithms,"Offutt, A. Jefferson, Zhenyi Jin, and Jie Pan",14," <i>George Mason University, Fairfax, Virginia, Technical Report ISSE-TR-94-110</i> (1994).",,
-1,A Fortran 77 Interpreter for Mutation Analysis,acm,A Fortran 77 interpreter for mutation analysis,"Offutt VI, A. J., and Kim N. King",35," In <i>ACM SIGPLAN Notices</i>, vol. 22, no. 7, pp. 177-188. ACM, 1987.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">Mutation analysis is a powerful technique for testing software systems. In the Mothra project, conducted at Georgia Tech's Software Engineering Research Center, mutation analysis is used as a basis for building an integrated software testing environment. Mutation analysis requires the execution of many slightly differing versions of the same program to evaluate the quality of the data used to test the program. In the current version of the Mothra system, a program to be tested is translated to intermediate code, where it and its mutated versions are executed by an interpreter.In this paper, we discuss some of the unique requirements of an interpreter used in a mutation-based testing environment. We then describe how these requirements affected the design and implementation of the Fortran 77 version of the Mothra interpreter. Other topics covered include the architecture of the interpreter and many of the design elements that it incorporates. We also describe the intermediate language used by Mothra and the features of the interpreter that are needed for software testing.</div> 
            

            </div>
          ",ACM SIGPLAN Notices
-1,An Experimental Determination of Sufficient Mutant Operators,acm,An experimental determination of sufficient mutant operators,"Offutt, A. Jefferson, Ammei Lee, Gregg Rothermel, Roland H. Untch, and Christian Zapf",574," <i>ACM Transactions on Software Engineering and Methodology (TOSEM)</i> 5, no. 2 (1996): 99-118.","
  <div class=""tabbody"">
              <div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"">
                  An abstract is not available.
              </div>
                      

</div>
            ",http://dl.acm.org/citation.cfm?id=227607.227610
-1,An Empirical Evaluation of Weak Mutation,ieeexplore,An empirical evaluation of weak mutation,"Offutt, A. Jefferson, and Stephen D. Lee",194," <i>IEEE Transactions on Software Engineering</i> 20, no. 5 (1994): 337-344.","Mutation testing is a fault-based technique for unit-level software testing. Weak mutation was proposed as a way to reduce the expense of mutation testing. Unfortunately, weak mutation is also expected to provide a weaker test of the software than mutation testing does. This paper presents results from an implementation of weak mutation, which we used to evaluate the effectiveness versus the efficiency of weak mutation. Additionally, we examined several options in an attempt to find the most appropriate way to implement weak mutation. Our results indicate that weak mutation can be applied in a manner that is almost as effective as mutation testing, and with significant computational savings.",
?,A Bayes Sequential Statistical Procedure for Approving Software Products,"M Sahinoglu, <a href=""/citations?user=MkC5kHcAAAAJ&amp;hl=en&amp;oi=sra"">EH Spafford</a> - Proceedings of the IFIP Conference on Approving  …, 1990",A bayes sequential statistical procedure for approving software products,"Sahinoglu, Mehmet, and Eugene H. Spafford",21," In <i>Proceedings of the IFIP Conference on Approving Software Products (ASP’90)</i>, pp. 43-56. 1990.",,
-1,Efficient Mutation Testing by Checking Invariant Violations,acm,Efficient mutation testing by checking invariant violations,"Schuler, David, Valentin Dallmeier, and Andreas Zeller",122," In <i>Proceedings of the eighteenth international symposium on Software testing and analysis</i>, pp. 69-80. ACM, 2009.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p><i>Mutation testing</i> measures the adequacy of a test suite by seeding artificial defects (mutations) into a program. If a mutation is not detected by the test suite, this usually means that the test suite is not adequate. However, it may also be that the mutant keeps the program's semantics unchanged-and thus cannot be detected by any test. Such <i>equivalent mutants</i> have to be eliminated manually, which is tedious.</p> <p>We assess the impact of mutations by checking dynamic invariants. In an evaluation of our JAVALANCHE framework on seven industrial-size programs, we found that mutations that violate invariants are significantly more likely to be detectable by a test suite. As a consequence, mutations with impact on invariants should be focused upon when improving test suites. With less than 3% of equivalent mutants, our approach provides an efficient, precise, and fully automatic measure of the adequacy of a test suite.</p></div> 
            

            </div>
          ",dynamic invariants; mutation testing
-1,Fault-Based Interface Testing between Real-Time Operating System and Application,ieeexplore,Fault-Based Interface Testing Between Real-Time Operating System and Application,"Sung, Ahyoung, Jina Jang, and Byoungju Choi",3," In <i>Mutation Analysis, 2006. Second Workshop on</i>, pp. 8-8. IEEE, 2006.","Testing interfaces of an embedded system is important since the heterogeneous layers such as hardware, OS and application are tightly coupled. We propose the mutation operators in three respects, 'When?', 'Where?' and 'How?' in order to inject a fault into RTOS program when testing interface between RTOS and application. Injecting a fault without affecting the RTOS in run-time environment is the core of proposed mutation operators. We apply the mutation operators to interface testing during the integration of RTOS and application in the industrial programmable logic controller.",
-1,An Experimental Study on Software Structural Testing: Deterministic versus Random Input Generation,ieeexplore,An experimental study on software structural testing: deterministic versus random input generation,"Thevenod-Fosse, Pascale, Helene Waeselynck, and Yves Crouzet",79," In <i>Fault-Tolerant Computing, 1991. FTCS-21. Digest of Papers., Twenty-First International Symposium</i>, pp. 410-417. IEEE, 1991.","The fault revealing power of different test patterns derived from ten structural test criteria currently referred to in unit testing is investigated. Experiments performed on four programs that are pieces of a real-life software system from the nuclear field are reported. Three test input generation techniques are studied: (1) deterministic choice, (2) random selection based on an input probability distribution determined according to the adopted structural test criterion, and (3) random selection from a uniform distribution on the input domain. Mutation analysis is used to assess the test set efficiency with respect to error detection. The experimental results involve a total of 2914 mutants. They show that structural statistical testing, which exhibits the highest mutation scores, leaving alive only six from 2816 nonequivalent mutants within short testing times, is the most efficient. A regards unit testing of programs whose structure remains tractable, the experiments show the adequacy of a fault removal strategy combining statistical and deterministic test patterns.",
-1,Pex-White Box Test Generation for .NET,Springer,Pex–white box test generation for. net,"Tillmann, Nikolai, and Jonathan De Halleux",742," In <i>International conference on tests and proofs</i>, pp. 134-153. Springer Berlin Heidelberg, 2008.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Pex automatically produces a small test suite with high code coverage for a .NET program. To this end, Pex performs a systematic program analysis (using dynamic symbolic execution, similar to path-bounded model-checking) to determine test inputs for Parameterized Unit Tests. Pex learns the program behavior by monitoring execution traces. Pex uses a constraint solver to produce new test inputs which exercise different program behavior. The result is an automatically generated small test suite which often achieves high code coverage. In one case study, we applied Pex to a core component of the .NET runtime which had already been extensively tested over several years. Pex found errors, including a serious issue.</p>",
-1,New Mutations for Evaluation of Specification and Implementation Levels of Adequacy in Testing of Statecharts Models,ieeexplore,New mutations for evaluation of specification and implementation levels of adequacy in testing of statecharts models,"Trakhtenbrot, Mark",16," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 151-160. IEEE, 2007.","In model-based development of embedded real-time systems, statecharts are widely used for formal specification of their behavior, providing a sound basis for test generation and for detection of faults early in the development process. The paper presents a variety of new mutations for adequacy evaluation of tests used in validation of statecharts-based models. These mutations focus on key features of statecharts used in modeling of embedded systems: hierarchy, orthogonality and time expressions. We distinguish between two levels of tests adequacy. In the first, test results are expected to strictly follow the statecharts semantics. The second one takes into account possible deviations from this semantics based on typical implementation oriented decisions, e.g. mapping of orthogonal components into separate tasks executed concurrently. The considered mutations address both types of adequacy. In particular, we consider interleaving enforcing mutations, for testing of alternatives to the canonical ""maximum parallelism "" execution of statecharts.",
-1,DBLP,,DBLP computer science bibliography,"Ley, Michael",269, (2005).,,
-1,SQLMutation: A Tool to Generate Mutants of SQL Database Queries,ieeexplore,"MILU: A customizable, runtime-optimized higher order mutation testing tool for the full C language","Jia, Yue, and Mark Harman",66," In <i>Practice and Research Techniques, 2008. TAIC PART'08. Testing: Academic &amp; Industrial Conference</i>, pp. 94-98. IEEE, 2008.",We present a tool to automatically generate mutants of SQL database queries. The SQLMutation tool is available on the Web and it can be accessed using two different interfaces: A Web application to interactively generate the mutants and a Web service that allows it to be integrated with other applications developed using different platforms.,"
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation operators.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation operators</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Database testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Database testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.SQL testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">SQL testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.SQL query.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">SQL query</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
？,Unit and Integration Testing Strategies for C Programs Using Mutation,Wiley Online Library,Unit and integration testing strategies for C programs using mutation-based criteria,"Vincenzi, Auri Marcelo Rizzo, José Carlos Maldonado, Ellen Francine Barbosa, and Márcio Eduardo Delamaro",19," In <i>Mutation testing for the new century</i>, pp. 45-45. Springer US, 2001.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Mutation testing, originally proposed for unit testing, has been extended to integration testing with the proposition of the Interface Mutation criterion. This paper presents the results of an experiment using two mutation-based testing criteria for unit and integration testing phases: the Mutation Analysis and the Interface Mutation adequacy criteria, respectively. The aim is to investigate how they can be used in a complementary way during the testing activity, establishing an incremental testing strategy comprising the unit and integration testing phases and guidelines on how to obtain a high mutation score with respect to mutation testing with a low cost, in terms of the number of mutants generated. Copyright © 2001 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">incremental testing strategy; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">unit testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">integration testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">interface mutation</span></li>"
-1,Fault Coupling in Finite Bijective Functions,Wiley Online Library,Fault coupling in finite bijective functions,"Wah, K. S",40," <i>Software Testing, Verification and Reliability</i> 5, no. 1 (1995): 3-47.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Fault-based testing attempts to show that particular faults cannot exist in software by using test sets that differentiate between the original program (hypothesized to be correct) and faulty alternate programs. The success of this approach depends on a number of assumptions, notably that programmers are competent insofar as they only commit relatively trivial faults, and that faults only couple infrequently. Fault coupling occurs when test sets are able to differentiate between the original program and faulty alternate programs when faults occur in isolation, but not when they occur in combination; it is a complicating factor in fault-based testing. Fault coupling is studied here within the context of finite bijective functions. A complete mathematical solution of the problem is possible in this simplified case; the results indicate that fault coupling does indeed occur infrequently, and are thus in agreement with the empirical results obtained by others in the field. One surprising result is that certain kinds of test set are able to avoid fault coupling altogether.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault-based testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault coupling; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test situation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">single-fault (double-fault) alternate; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">proper (coupled) test set; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">coupling ratio</span></li>"
-1,A Theoretical Study of Fault Coupling,Wiley Online Library,A theoretical study of fault coupling,"Wah, K. S",67," <i>Software testing, verification and reliability</i> 10, no. 1 (2000): 3-45.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Fault coupling is the phenomenon whereby a test set is able to detect faults when they occur in isolation, but fails to do so when they occur in combination. It is widely regarded as a nuisance in fault-based approaches to software testing, which focus on the detection of single faults and normally neglect multiple faults.</p><p>This paper presents a theoretical study of fault coupling, based on a simple model of fault-based testing. This provides for the presence of two faults that interact with each other and thus includes the possibility of fault coupling between them. The model is analysed mathematically, the conclusion reached being that fault coupling only occurs infrequently. This result provides support for current approaches to fault-based testing, but it is not quite enough to conclude that they are thereby validated. In effect, the paper generalizes the results of a previous paper that dealt with the restricted case where the functions underlying programs are bijective as well as finite. The restriction that functions be bijective is lifted here, but they are still required to be finite. Though the same theoretical framework is used in both cases, and more or less the same results are obtained, the techniques employed to arrive at the results in the general case are quite different. Copyright © 2000 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault-based testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault coupling; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">single-fault (double-fault) alternate; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">proper (coupled) test set; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">coupling ratio; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">degeneracy structure</span></li>"
-1,An Analysis of the Coupling Effect I: Single Test Data,Elsevier,An analysis of the coupling effect I: single test data,"Wah, KS How Tai",36," <i>Science of Computer Programming</i> 48, no. 2-3 (2003): 119-161.",,<span>Coupling effect</span>
？,Requirement Model-Based Mutation Testing for Web Service,ieeexplore,Requirement model-based mutation testing for web service,"Wang, Rui, and Ning Huang",24," In <i>Next Generation Web Services Practices, 2008. NWESP'08. 4th International Conference on</i>, pp. 71-76. IEEE, 2008.","Web services present a new promising software technology. However, some new issues and challenges in testing of them come out due to their characteristics of distribution, source code invisibility etc. This paper discusses the traditional mutation testing and then a new methodology of OWL-S requirement model-based web service mutation testing is brought forward. The traits of this methodology are as follows. Firstly, requirements are used effectively to reduce the magnitude of mutants. Secondly, mutants are generated by AOP technology conveniently and promptly. Thirdly, to reducing testing cost, using business logic implied in OWL-S requirement model as assistant of the process of killing the mutants. Fourthly, two sufficient measurement criteria are employed to evaluate the testing process. Finally, our empirical results have shown the usefulness of this testing method.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Web Service.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Web Service</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.OWL-S.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">OWL-S</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Improved Serial Algorithms for Mutation Analysis,acm,Improved serial algorithms for mutation analysis,"Weiss, Stewart N., and Vladimir N. Fleyshgakker",45," In <i>ACM SIGSOFT Software Engineering Notes</i>, vol. 18, no. 3, pp. 149-158. ACM, 1993.","


 ",ACM SIGSOFT Software Engineering Notes
-1,On Testing Non-Testable Programs,"EJ Weyuker - The Computer Journal, 1982 - Br Computer Soc",Automatic system testing of programs without test oracles,"Murphy, Christian, Kuang Shen, and Gail Kaiser",516," In <i>Proceedings of the eighteenth international symposium on Software testing and analysis</i>, pp. 189-200. ACM, 2009.",,
-1,Mutation Testing Applied to Estelle Specifications,ieeexplore,Mutation testing applied to estelle specifications,"De Souza, S. Do Rocio Senger, José Carlos Maldonado, Sandra Camargo Pinto Ferraz Fabbri, and W. Lopes De Souza",70," In <i>System Sciences, 2000. Proceedings of the 33rd Annual Hawaii International Conference on</i>, pp. 10-pp. IEEE, 2000.","Many researchers have pursued the establishment of a low-cost, effective testing and validation strategy at the program level as well as at the specification level. Mutation Testing is an error-based approach, originally introduced for program testing, that provides testers a systematic way to evaluate how good a given tester is. Some studies have also investigated its use to generate testers. In this article the application of Mutation Testing for validating Estelle specifications is proposed. A mutation operator set for Estelle-one of the crucial points for effectively applying Mutation Testing-is defined, addressing: the validation of the behavior of the modules, the communication among modules and the architecture of the specification. In this scope, these operators can be taken as a fault model. Considering this context, a strategy for validating Estelle-based specification is proposed and exemplified using the alternating-bit protocol.",
-1,Mutation Testing Applied to Estelle Specifications,ieeexplore,Mutation testing applied to estelle specifications,"De Souza, S. Do Rocio Senger, José Carlos Maldonado, Sandra Camargo Pinto Ferraz Fabbri, and W. Lopes De Souza",70," In <i>System Sciences, 2000. Proceedings of the 33rd Annual Hawaii International Conference on</i>, pp. 10-pp. IEEE, 2000.","Many researchers have pursued the establishment of a low-cost, effective testing and validation strategy at the program level as well as at the specification level. Mutation Testing is an error-based approach, originally introduced for program testing, that provides testers a systematic way to evaluate how good a given tester is. Some studies have also investigated its use to generate testers. In this article the application of Mutation Testing for validating Estelle specifications is proposed. A mutation operator set for Estelle-one of the crucial points for effectively applying Mutation Testing-is defined, addressing: the validation of the behavior of the modules, the communication among modules and the architecture of the specification. In this scope, these operators can be taken as a fault model. Considering this context, a strategy for validating Estelle-based specification is proposed and exemplified using the alternating-bit protocol.",
？,Extending Mutation Testing to Find Environmental Bugs,Wiley Online Library,Extending mutation testing to find environmental bugs,"Spafford, Eugene H",27," <i>Software: Practice and Experience</i> 20, no. 2 (1990): 181-189.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p><em>Environmental bugs</em> are bugs caused by limitations of precision or capacity in the environment of a piece of software. These bugs may be difficult to activate and even more difficult to find.</p><p>This paper reports on an extension to traditional mutation testing that enables testing specifically for environmental bugs involving integer arithmetic. This method is both simple and effective, and provides some insight into other possible extensions of the mutation-testing methodology that can be used to expose environmental bugs.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Environmental bugs</span></li>"
-1,Mutation 2000: Uniting the Orthogonal,Springer,Mutation 2000: Uniting the orthogonal,"Offutt, A. Jefferson, and Roland H. Untch",328," In <i>Mutation testing for the new century</i>, pp. 34-44. Springer US, 2001.","
                          <h2 class=""Heading"">Abstract</h2>
                          <p class=""Para"">Mutation testing is a powerful, but computationally expensive, technique for unit testing software. This expense has prevented mutation from becoming widely used in practical situations, but recent engineering advances have given us techniques and algorithms for significantly reducing the cost of mutation testing. These techniques include a new algorithmic execution technique called schema-based mutation, an approximation technique called weak mutation, a reduction technique called selective mutation, heuristics for detecting equivalent mutants, and algorithms for automatic test data generation. This paper reviews experimentation with these advances and outlines a design for a system that will approximate mutation, but in a way that will be accessible to everyday programmers. We envision a system to which a programmer can submit a program unit and get back a set of input/output pairs that are guaranteed to form an effective test of the unit by being close to mutation adequate. We believe this system could be efficient enough to be adopted by leading-edge software developers. Full automation in unit testing has the potential to dramatically change the economic balance between testing and development, by reducing the cost of testing from the major part of the total development cost to a small fraction.</p>
                        ",
-1,Decreasing the Cost of Mutation Testing with Second-Order Mutants,Wiley Online Library,Decreasing the cost of mutation testing with second‐order mutants,"Polo, Macario, Mario Piattini, and Ignacio García‐Rodríguez",105," <i>Software Testing, Verification and Reliability</i> 19, no. 2 (2009): 111-131.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Although powerful, mutation is a computationally very expensive testing technique. In fact, its three main stages (mutant generation, mutant execution and result analysis) require many resources to be successfully accomplished. Thus, researchers have made important efforts to reduce its costs. This paper represents an additional effort in this sense. It describes the results of two experiments in which, by means of combining the original set of mutants and therefore obtaining a new set of mutants—each one with two faults—the number of mutants used is reduced to half. Results lead to believe that mutant combination does not decrease the quality of the test suite, whereas it supposes important savings in mutant execution and result analysis. Copyright © 2008 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">cost reduction; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutant reduction</span></li>"
1,Integrating Techniques and Tools for Testing Automation: Research Articles,"<a href=""/citations?user=k6-ma1sAAAAJ&amp;hl=en&amp;oi=sra"">M Polo</a>, S Tendero, <a href=""/citations?user=M91TyJcAAAAJ&amp;hl=en&amp;oi=sra"">M Piattini</a> - … Testing Verification and …, 2007 - pdfs.semanticscholar.org",Integrating techniques and tools for testing automation,"Polo, Macario, Sergio Tendero, and Mario Piattini",48," <i>Software Testing Verification and Reliability</i> 17, no. 1 (2007): 3-40.","This article presents two tools to generate test cases, one for Java programs and one for .NET programs, as well as a structured testing process whereby such tools can be used in order to help in process automation. The main innovation in this work is the joint use of diverse techniques and technologies, which have been separately applied to test automation: reflection to extract the class structure; regular expressions to describe test templates and test cases; JUnit and NUnit as test case execution frameworks; mutation and MuJava as test case quality measurers; serialization to deal with the parameters of complex data types; and once more, reflection, to facilitate the test engineer in the task of writing the oracle. Finally, the article presents an experiment carried out to validate the work. ",
-1,Mutating Database Queries,Elsevier,Mutating database queries,"Tuya, Javier, Ma José Suárez-Cabal, and Claudio De La Riva",133," <i>Information and Software Technology</i> 49, no. 4 (2007): 398-417.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">A set of mutation operators for SQL queries that retrieve information from a database is developed and tested against a set of queries drawn from the NIST SQL Conformance Test Suite. The mutation operators cover a wide spectrum of SQL features, including the handling of null values. Additional experiments are performed to explore whether the cost of executing mutants can be reduced using selective mutation or the test suite size can be reduced by using an appropriate ordering of the mutants. The SQL mutation approach can be helpful in assessing the adequacy of database test cases and their development, and as a tool for systematically injecting faults in order to compare different database testing techniques.</p>","<li id="""" class=""svKeywords""><span id="""">Software testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Database testing</span>; </li><li id="""" class=""svKeywords""><span id="""">SQL testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Fault-based testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Test adequacy criteria</span></li>"
-1,Mutation-Based Software Testing Using Program Schemata,acm,Mutation-based software testing using program schemata,"Untch, Roland H",33," In <i>Proceedings of the 30th annual Southeast regional conference</i>, pp. 285-291. ACM, 1992.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">Mutation analysis is a powerful technique for assessing the quality of test data used in unit testing software. Unfortunately, current automated mutation analysis systems suffer from severe performance problems. In this paper the principles of mutation analysis are reviewed, current automation approaches are described, and a new method of performing mutation analysis is outlined. Performance improvements of over 300% are reported and other advantages of this new method are highlighted.</div> 
            

            </div>
          ",Fault-based testing; mutation analysis; program schemata; software testing
-1,Mutation Analysis Using Mutant Schemata,acm,Mutation analysis using mutant schemata,"Untch, Roland H., A. Jefferson Offutt, and Mary Jean Harrold",202," In <i>ACM SIGSOFT Software Engineering Notes</i>, vol. 18, no. 3, pp. 139-148. ACM, 1993.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>Mutation analysis is a powerful technique for assessing and improving the quality of test data used to unit test software. Unfortunately, current automated mutation analysis systems suffer from severe performance problems. This paper presents a new method for performing mutation analysis that uses <italic>program schemata</italic> to encode all mutants for a program into one <italic>metaprogram</italic>, which is subsequently compiled and run at speeds substantially higher than achieved by previous interpretive systems. Preliminary performance improvements of over 300% are reported. This method has the additional advantages of being easier to implement than interpretive systems, being simpler to port across a wide range of hardware and software platforms, and using the same compiler and run-time support system that is used during development and/or deployment.</par></div> 
            

            </div>
          ",fault-based testing; mutation analysis; program schemata; software testing
-1,Testing Network-Based Intrusion Detection Signatures Using Mutant Exploits,acm,Testing network-based intrusion detection signatures using mutant exploits,"Vigna, Giovanni, William Robertson, and Davide Balzarotti",199," In <i>Proceedings of the 11th ACM conference on Computer and communications security</i>, pp. 21-30. ACM, 2004.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Misuse-based intrusion detection systems rely on models of attacks to identify the manifestation of intrusive behavior. Therefore, the ability of these systems to reliably detect attacks is strongly affected by the quality of their models, which are often called ""signatures."" A perfect model would be able to detect all the instances of an attack without making mistakes, that is, it would produce a 100% detection rate with 0 false alarms. Unfortunately, writing good models (or good signatures) is hard. Attacks that exploit a specific vulnerability may do so in completely different ways, and writing models that take into account all possible variations is very difficult. For this reason, it would be beneficial to have testing tools that are able to evaluate the ""goodness"" of detection signatures. This work describes a technique to test and evaluate misuse detection models in the case of network-based intrusion detection systems. The testing technique is based on a mechanism that generates a large number of variations of an exploit by applying mutant operators to an exploit template. These mutant exploits are then run against a victim host protected by a network-based intrusion detection system. The results of the systems in detecting these variations provide a quantitative basis for the evaluation of the quality of the corresponding detection model.</p></div> 
            

            </div>
          ",intrusion detection; quality metrics; security testing
-1,Testing for Security Vulnerabilities in Software,"<a href=""/citations?user=rziIZ14AAAAJ&amp;hl=en&amp;oi=sra"">P Vilela</a>, M Machado, <a href=""/citations?user=d9Y04UwAAAAJ&amp;hl=en&amp;oi=sra"">WE Wong</a> - Software Engineering and Applications, 2002",Testing for security vulnerabilities in software,"Vilela, P., M. Machado, and W. E. Wong",12, <i>Software Engineering and Applications</i> (2002).,"This paper presents a case study to produce supporting evidence to prove the hypothesis that it is viable to test a pro gram for security vulnerabilities. The approach considers the use of Mutation Analysis, a structural error-based test ing technique, to increase the chances of detecting code re lated security breaches in software. Two mutant operators with four variations each are deﬁned and subsequently used to generate mutants. Cost related issues are always raised when mutation analysis is used, we address the problem from both the theoretical and empirical point of view.",
-1,Mutation-Based Exploration of a Method for Verifying Concurrent Java Components,ieeexplore,Mutation-based exploration of a method for verifying concurrent Java components,"Long, Brad, Roger Duke, Doug Goldson, Paul Strooper, and Luke Wildman",24," In <i>Parallel and Distributed Processing Symposium, 2004. Proceedings. 18th International</i>, p. 265. IEEE, 2004.","Summary form only given. The Java programming language supports concurrency. Concurrent programs are harder to verify than their sequential counterparts due to their inherent nondeterminism and a number of specific concurrency problems such as interference and deadlock. In previous work, we proposed a method for verifying concurrent Java components based on a mix of code inspection, static analysis tools, and the ConAn testing tool. The method was derived from an analysis of concurrency failures in Java components, but was not applied in practice. In this paper, we explore the method by applying it to an implementation of the well-known readers-writers problem and a number of mutants of that implementation. We only apply it to a single, well-known example, and so we do not attempt to draw any general conclusions about the applicability or effectiveness of the method. However, the exploration does point out several strengths and weaknesses in the method, which enable us to fine-tune the method before we carry out a more formal evaluation on other, more realistic components.",
-1,Evaluation of Mutation Testing for Object-Oriented Programs,acm,Evaluation of mutation testing for object-oriented programs,"Ma, Yu-Seung, Mary Jean Harrold, and Yong-Rae Kwon",44," In <i>Proceedings of the 28th international conference on Software engineering</i>, pp. 869-872. ACM, 2006.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">The effectiveness of mutation testing depends heavily on the types of faults that the mutation operators are designed to represent. Thus, the quality of the mutation operators is key to mutation testing. Although, mutation operators for object-oriented languages have previously been presented, little research has been done to show the usefulness of the class mutation operators. To assess the usefulness of class mutation operators, we conducted two empirical studies. In the first study, we examine the number and kinds of mutants that are generated for object-oriented programs. In the second study, we investigate the way in which class mutation operators model faults that are not detected by traditional mutation testing. We conducted our studies using a well-known object-oriented system, BCEL.</div> 
            

            </div>
          ",
-1,Inter-Class Mutation Operators for Java,ieeexplore,Inter-class mutation operators for Java,"Ma, Yu-Seung, Yong-Rae Kwon, and Jeff Offutt",226," In <i>Software Reliability Engineering, 2002. ISSRE 2003. Proceedings. 13th International Symposium on</i>, pp. 352-363. IEEE, 2002.","The effectiveness of mutation testing depends heavily on the types of faults that the mutation operators are designed to represent. Therefore, the quality of the mutation operators is key to mutation testing. Mutation testing has traditionally been applied to procedural-based languages, and mutation operators have been developed to support most of their language features. Object-oriented programming languages contain new language features, most notably inheritance, polymorphism, and dynamic binding. Not surprisingly; these language features allow new kinds of faults, some of which are not modeled by traditional mutation operators. Although mutation operators for OO languages have previously been suggested, our work in OO faults indicate that the previous operators are insufficient to test these OO language features, particularly at the class testing level. This paper introduces a new set of class mutation operators for the OO language Java. These operators are based on specific OO faults and can be used to detect faults involving inheritance, polymorphism, and dynamic binding, thus are useful for inter-class testing. An initial Java mutation tool has recently been completed, and a more powerful version is currently under construction.",
-1,Mutation Testing of Protocols: Principles and Preliminary Experimental Results,"RL Probert, F Guo - Proceedings of the Workshop on Protocol Test Systems, 1991",Mutation testing of protocols: Principles and preliminary experimental results,"Probert, R. L., and F. Guo",47," In <i>Proceedings of the Workshop on Protocol Test Systems</i>, pp. 57-76. 1991.",,
-1,Challenging Formal Specifications by Mutation: A CSP Security Example,ieeexplore,Challenging formal specifications by mutation: a CSP security example,"Srivatanakul, Thitima, John A. Clark, Susan Stepney, and Fiona Polack",35," In <i>Software Engineering Conference, 2003. Tenth Asia-Pacific</i>, pp. 340-350. IEEE, 2003.","When formal modelling is done we must validate both the model and the assumptions. Formal techniques tend to concentrate on the former. We examine how fault injection (specification mutation) and model checking can help address the latter, in particular, the effects of failure. We find that, in contrast with software testing, where they are a problem, ""equivalent mutants"" are valuable for specification validation.",
-1,Mutation Operators for Spreadsheets,ieeexplore,Mutation operators for spreadsheets,"Abraham, Robin, and Martin Erwig",63," <i>IEEE Transactions on Software Engineering</i> 35, no. 1 (2009): 94-108.","Based on 1) research into mutation testing for general-purpose programming languages and 2) spreadsheet errors that have been reported in the literature, we have developed a suite of mutation operators for spreadsheets. We present an evaluation of the mutation adequacy of definition-use adequate test suites generated by a constraint-based automatic test-case generation system we have developed in previous work. The results of the evaluation suggest additional constraints that can be incorporated into the system to target mutation adequacy. In addition to being useful in mutation testing of spreadsheets, the operators can be used in the evaluation of error-detection tools and also for seeding spreadsheets with errors for empirical studies. We describe two case studies where the suite of mutation operators helped us carry out such empirical evaluations. The main contribution of this paper is a suite of mutation operators for spreadsheets that can be used for performing empirical evaluations of spreadsheet tools to indicate ways in which the tools can be improved.",
-1,Mutation Analysis,Wiley Online Library,Comprehensive mutation analysis of TSC1 and TSC2—and phenotypic correlations in 150 families with tuberous sclerosis,"Jones, Alistair C., Magitha M. Shyamsundar, Meinir W. Thomas, Julie Maynard, Shelley Idziaszczyk, Susan Tomkins, Julian R. Sampson, and Jeremy P. Cheadle",1137," <i>The American Journal of Human Genetics</i> 64, no. 5 (1999): 1305-1315.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Mutations in the tumor suppressor gene TP53 are frequent in most human cancers. Comparison of the mutation patterns in different cancers may reveal clues on the natural history of the disease. Over the past 10 years, several databases of TP53 mutations have been developed. The most extensive of these databases is maintained and developed at the International Agency for Research on Cancer. The database compiles all mutations (somatic and inherited), as well as polymorphisms, that have been reported in the published literature since 1989. The IARC TP53 mutation dataset is the largest dataset available on the variations of any human gene. The database is available at <a href=""http://www.iarc.fr/P53/"" title=""Link to external resource: http://www.iarc.fr/P53/"" target=""_blank"">www.iarc.fr/P53/</a>. In this paper, we describe recent developments of the database. These developments include restructuring of the database, which is now patient-centered, with more detailed annotations on the patient (carcinogen exposure, virus infection, genetic background). In addition, a new on-line application to retrieve somatic mutation data and analyze mutation patterns is now available. We also discuss limitations on the use of the database and provide recommendations to users. Hum Mutat 19:607–614, 2002. © 2002 Wiley-Liss, Inc.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">TP53; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">p53; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">database; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Li-Fraumeni syndrome; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">LFS; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">cancer; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">tumor suppressor</span></li>"
-1,How to Overcome the Equivalent Mutant Problem and Achieve Tailored Selective Mutation Using Co-Evolution,Springer,How to overcome the equivalent mutant problem and achieve tailored selective mutation using co-evolution,"Adamopoulos, Konstantinos, Mark Harman, and Robert Hierons",116," In <i>Genetic and Evolutionary Computation–GECCO 2004</i>, pp. 1338-1349. Springer Berlin/Heidelberg, 2004.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">The use of Genetic Algorithms in evolution of mutants and test cases offers new possibilities in addressing some of the main problems of mutation testing. Most specifically the problem of equivalent mutant detection, and the problem of the large number of mutants produced. In this paper we describe the above problems in detail and introduce a new methodology based on co-evolutionary search techniques using Genetic Algorithms in order to address them effectively. Co-evolution allows the parallel evolution of mutants and test cases. We discuss the advantages of this approach over other existing mutation testing techniques, showing details of some initial experimental results carried out.</p>",
-1,Design of Mutant Operators for the C Programming Language,"H Agrawal, <a href=""/citations?user=Pil9rEEAAAAJ&amp;hl=en&amp;oi=sra"">R DeMillo</a>, R Hathaway, W Hsu, W Hsu… - 1989 - academia.edu",Design of mutant operators for the c programming language,"Richard, Hiralal Agrawal, Richard A. Demillo, Bob Hathaway, William Hsu, Wynne Hsu, E. W. Krauser, R. J. Martin, Aditya P. Mathur, and Eugene H. Spafford",276, (1989).,,
？,Mutation Testing in the Refinement Calculus,Springer,Mutation testing in the refinement calculus,"Aichernig, Bernhard K",39," <i>Formal Aspects of Computing</i> 15, no. 2 (2003): 280-295.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">This article discusses mutation testing strategies in the context of refinement. Here, a novel generalisation of mutation testing techniques is presented to be applied to contracts ranging from formal specifications to programs. It is demonstrated that refinement and its dual abstraction are the key notions leading to a precise and yet simple theory of mutation testing. The refinement calculus of Back and von Wright is used to express concepts like contracts, useful mutations, test cases and test coverage.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Abstraction&nbsp;</span><span class=""Keyword"">Formal methods&nbsp;</span><span class=""Keyword"">Formal specifications&nbsp;</span><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Refinement&nbsp;</span><span class=""Keyword"">Test case generation&nbsp;</span><span class=""Keyword"">Test coverage&nbsp;</span>"
-1,From Faults via Test Purposes to Test Cases: On the Fault-Based Testing of Concurrent Systems,Springer,From faults via test purposes to test cases: on the fault-based testing of concurrent systems,"Aichernig, Bernhard K., and Carlo Corrales Delgado",37," In <i>International Conference on Fundamental Approaches to Software Engineering</i>, pp. 324-338. Springer Berlin Heidelberg, 2006.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Fault-based testing is a technique where testers anticipate errors in a system under test in order to assess or generate test cases. The idea is to have enough test cases capable of detecting these anticipated errors. This paper presents a theory and technique for generating fault-based test cases for concurrent systems. The novel idea is to generate test purposes from faults that have been injected into a model of the system under test. Such test purposes form a specification of a more detailed test case that can detect the injected fault. The theory is based on the notion of refinement. The technique is automated using the TGV test case generator and an equivalence checker of the CADP tools. A case study of testing web servers demonstrates the practicability of the approach.</p>",
-1,Mutation ofJava Objects,ieeexplore,Advanced mutation operators applicable in C# programs,"Derezińska, Anna",65," In <i>Software Engineering Techniques: Design for Quality</i>, pp. 283-288. Springer US, 2006.","Fault insertion based techniques have been used for measuring test adequacy and testability of programs. Mutation analysis inserts faults into a program with the goal of creating mutation-adequate test sets that distinguish the mutant from the original program. Software testability is measured by calculating the probability that a program will fail on the next test input coming from a predefined input distribution, given that the software includes a fault. Inserted faults must represent plausible errors. It is relatively easy to apply standard transformations to mutate scalar values such as integers, floats, and character data, because their semantics are well understood. Mutating objects that are instances of user defined types is more difficult. There is no obvious way to modify such objects in a manner consistent with realistic faults, without writing custom mutation methods for each object class. We propose a new object mutation approach along with a set of mutation operators and support tools for inserting faults into objects that instantiate items from common Java libraries heavily used in commercial software as well as user defined classes. Preliminary evaluation of our technique shows that it should be effective for evaluating real-world software testing suites.",
-1,A Systematic Review of the Application and Empirical Investigation of Search-Based Test-Case Generation,ieeexplore,A Systematic Review of the Application and Empirical Investigation of Search-Based Test Case Generation,"Hemmati, Hadi, Shaukat Ali, Lionel C. Briand, and Rajwinder K. Panesar-Walawege",299, (2010).,"Metaheuristic search techniques have been extensively used to automate the process of generating test cases, and thus providing solutions for a more cost-effective testing process. This approach to test automation, often coined “Search-based Software Testing” (SBST), has been used for a wide variety of test case generation purposes. Since SBST techniques are heuristic by nature, they must be empirically investigated in terms of how costly and effective they are at reaching their test objectives and whether they scale up to realistic development artifacts. However, approaches to empirically study SBST techniques have shown wide variation in the literature. This paper presents the results of a systematic, comprehensive review that aims at characterizing how empirical studies have been designed to investigate SBST cost-effectiveness and what empirical evidence is available in the literature regarding SBST cost-effectiveness and scalability. We also provide a framework that drives the data collection process of this systematic review and can be the starting point of guidelines on how SBST techniques can be empirically assessed. The intent is to aid future researchers doing empirical studies in SBST by providing an unbiased view of the body of empirical evidence and by guiding them in performing well-designed and executed empirical studies.",
-1,Efficient Mutant Generation for Mutation Testing of Pointcuts in Aspect-Oriented Programs,"P Anbalagan, <a href=""/citations?user=DhhH9J4AAAAJ&amp;hl=en&amp;oi=sra"">T Xie</a> - Proceedings of the 2nd Workshop on  …, 2006 - taoxie.cs.illinois.edu",Efficient mutant generation for mutation testing of pointcuts in aspect-oriented programs,"Anbalagan, Prasanth, and Tao Xie",37," In <i>Proceedings of the 2nd Workshop on Mutation Analysis (MUTATION’06)</i>, p. 3. 2006.",,
1,Automated Generation of Pointcut Mutants for Testing Pointcuts in AspectJ Programs,ieeexplore,Automated generation of pointcut mutants for testing pointcuts in AspectJ programs,"Anbalagan, Prasanth, and Tao Xie",42," In <i>Software Reliability Engineering, 2008. ISSRE 2008. 19th International Symposium on</i>, pp. 239-248. IEEE, 2008.","Aspect-Oriented Programming (AOP) provides new modularization of software systems by encapsulating cross-cutting concerns. AspectJ, an AOP language, uses abstractions such as pointcuts, advice, and aspects to achieve AOP’s primary functionality. Faults in pointcuts can cause aspects to fail to satisfy their requirements. Hence, testing pointcuts is necessary in order to ensure correctness of aspects. In mutation testing of pointcuts (a type of fault-based pointcut testing), the number of mutants (i.e., variations) for pointcuts is usually large due to the usage of wildcards. It is tedious to manually identify effective mutants that are of appropriate strength and resemble closely the original pointcut expression, reflecting the kind of mistakes that developers may make. To reduce developers’ effort in this process, we have developed a new framework that automatically identifies the strength of each pointcut and generates pointcut mutants with different strengths. Developers can inspect the pointcut mutants and their join points for pointcut correctness or choose the mutants for conducting mutation testing. We conducted an empirical study on applying our framework on pointcuts from existing AspectJ programs. The results show that our framework can provide valuable assistance in generating effective mutants that are close to the original pointcuts and are of appropriate strength.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.AspectJ.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">AspectJ</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Aspect-Oriented Programs.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Aspect-Oriented Programs</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Is Mutation an Appropriate Tool for Testing Experiments?,acm,Is mutation an appropriate tool for testing experiments?,"Andrews, James H., Lionel C. Briand, and Yvan Labiche",729," In <i>Proceedings of the 27th international conference on Software engineering</i>, pp. 402-411. ACM, 2005.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">The empirical assessment of test techniques plays an important role in software testing research. One common practice is to instrument faults, either manually or by using mutation operators. The latter allows the systematic, repeatable seeding of large numbers of faults; however, we do not know whether empirical results obtained this way lead to valid, representative conclusions. This paper investigates this important question based on a number of programs with comprehensive pools of test cases and known faults. It is concluded that, based on the data available thus far, the use of mutation operators is yielding trustworthy results (generated mutants are similar to real faults). Mutants appear however to be different from hand-seeded faults that seem to be harder to detect than real faults.</div> 
            

            </div>
          ",hand-seeded faults; mutants; real faults
-1,Using Mutation Analysis for Assessing and Comparing Testing Coverage Criteria,ieeexplore,Using mutation analysis for assessing and comparing testing coverage criteria,"Andrews, James H., Lionel C. Briand, Yvan Labiche, and Akbar Siami Namin",331," <i>IEEE Transactions on Software Engineering</i> 32, no. 8 (2006): 608-624.","The empirical assessment of test techniques plays an important role in software testing research. One common practice is to seed faults in subject software, either manually or by using a program that generates all possible mutants based on a set of mutation operators. The latter allows the systematic, repeatable seeding of large numbers of faults, thus facilitating the statistical analysis of fault detection effectiveness of test suites; however, we do not know whether empirical results obtained this way lead to valid, representative conclusions. Focusing on four common control and data flow criteria (block, decision, C-use, and P-use), this paper investigates this important issue based on a middle size industrial program with a comprehensive pool of test cases and known faults. Based on the data available thus far, the results are very consistent across the investigated criteria as they show that the use of mutation operators is yielding trustworthy results: generated mutants can be used to predict the detection effectiveness of real faults. Applying such a mutation analysis, we then investigate the relative cost and effectiveness of the above-mentioned criteria by revisiting fundamental questions regarding the relationships between fault detection, test suite size, and control/data flow coverage. Although such questions have been partially investigated in previous studies, we can use a large number of mutants, which helps decrease the impact of random variation in our analysis and allows us to use a different analysis approach. Our results are then; compared with published studies, plausible reasons for the differences are provided, and the research leads us to suggest a way to tune the mutation analysis process to possible differences in fault detection probabilities in a specific environment","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.experimental design..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">experimental design.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Testing and debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Testing and debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing strategies.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing strategies</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test coverage of code.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test coverage of code</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
?,Automatic Mutation Test Input Data Generation via Ant Colony,acm,Automatic mutation test input data generation via ant colony,"Ayari, Kamel, Salah Bouktif, and Giuliano Antoniol",103," In <i>Proceedings of the 9th annual conference on Genetic and evolutionary computation</i>, pp. 1074-1081. ACM, 2007.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Fault-based testing is often advocated to overcome limitations ofother testing approaches; however it is also recognized as beingexpensive. On the other hand, evolutionary algorithms have beenproved suitable for reducing the cost of data generation in the contextof coverage based testing. In this paper, we propose a newevolutionary approach based on ant colony optimization for automatictest input data generation in the context of mutation testingto reduce the cost of such a test strategy. In our approach the antcolony optimization algorithm is enhanced by a probability densityestimation technique. We compare our proposal with otherevolutionary algorithms, e.g., Genetic Algorithm. Our preliminaryresults on JAVA testbeds show that our approach performed significantlybetter than other alternatives.</p></div> 
            

            </div>
          ",ant colony optimization; mutation testing; search based testing; test input data generation
-1,A Candidate Fault Model for AspectJ Pointcuts,ieeexplore,A candidate fault model for AspectJ pointcuts,"Baekken, Jon S., and Roger T. Alexander",55," In <i>Software Reliability Engineering, 2006. ISSRE'06. 17th International Symposium on</i>, pp. 169-178. IEEE, 2006.","We present a candidate fault model for pointcuts in AspectJ programs. The fault model identifies faults that we believe are likely to occur when writing pointcuts in the AspectJ language. Categories of fault types are identified, and each individual fault type is described as categorized. We argue that a fault model that focuses on the unique constructs of the AspectJ language is needed for the systematic and effective testing of AspectJ programs. Our pointcut fault model is a first step towards such a model",
-1,Heuristics for Determining Equivalence of Program Mutations,"D Baldwin, F Sayward - 1979 - DTIC Document",Heuristics for Determining Equivalence of Program Mutation,"Baldwin, Douglas, and Frederick Sayward",98,". GEORGIA INST OF TECH ATLANTA SCHOOL OF INFORMATION AND COMPUTER SCIENCE, 1979.",,
-1,Toward the Determination of Sufficient Mutant Operators for C,Wiley Online Library,Toward the determination of sufficient mutant operators for C,"Barbosa, Ellen Francine, José Carlos Maldonado, and Auri Marcelo Rizzo Vincenzi",121," <i>Software Testing, Verification and Reliability</i> 11, no. 2 (2001): 113-136.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Mutation testing (MT) has been found to be effective at revealing faults. However, its high cost of application, due to the high number of mutants created and the effort to determine the equivalent ones, has motivated the proposition of alternative approaches for its application. One of them, named ‘selective mutation’, aims to reduce the number of generated mutants through a reduction in the number of mutant operators. A previous relevant study resulted in the proposition of a sufficient mutant operators set for FORTRAN, indicating that it is possible to have a large cost reduction in MT application, whilst preserving a high MT score. This work investigates procedures for the determination of a sufficient mutant operators set for C programs with the perspective of contributing to the establishment of low-cost, effective mutation-based testing strategies. Copyright © 2001 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">sufficient mutant operators</span></li>"
-1,Specification of Timed EFSM Fault Models in SDL,Springer,Specification of timed EFSM fault models in SDL,"Batth, Samrat S., Elisangela Rodrigues Vieira, A. Cavalli, and M. Ümit Uyar",24," In <i>International Conference on Formal Techniques for Networked and Distributed Systems</i>, pp. 50-65. Springer Berlin Heidelberg, 2007.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">In this paper, we apply our timing fault modeling strategy to writing formal specifications for communication protocols. Using the formal language of Specification and Description Language (SDL), we specify the <span class=""Literal"">Controller</span> process of <em class=""EmphasisTypeItalic "">rail-road crossing system</em>, a popular benchmark for real-time systems. Our extended finite state machine (EFSM) model has the capability of representing a class of timing faults, which otherwise may not be detected in an IUT. <em class=""EmphasisTypeItalic "">Hit-or-Jump</em> algorithm is applied to the SDL specification based on our EFSM model to generate a test sequence that can detect these timing faults. This application of fault modeling into SDL specification ensures the synchronization among the timing constraints of different processes, and enables generation of portable test sequences since they can be easily represented in other formal notations such as TTCN or MSC.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Extended Finite State Machines&nbsp;</span><span class=""Keyword"">Timing Fault Models&nbsp;</span><span class=""Keyword"">SDL&nbsp;</span><span class=""Keyword"">Hit-or-Jump&nbsp;</span>"
-1,Genes and Bacteria for Automatic Test Cases Optimization in the .NET Environment,ieeexplore,Genes and bacteria for automatic test cases optimization in the. net environment,"Baudry, Benoit, Franck Fleurey, J-M. Jézéquel, and Yves Le Traon",72," In <i>Software Reliability Engineering, 2002. ISSRE 2003. Proceedings. 13th International Symposium on</i>, pp. 195-206. IEEE, 2002.","The level of confidence in a software component is often linked to the quality of its test cases. This quality can in turn be evaluated with mutation analysis: faulty components (mutants) are systematically generated to check the proportion of mutants detected (""killed"") by the test cases. But while the generation of basic test cases set is easy, improving its quality may require prohibitive effort. We focus on the issue of automating the test optimization. We looked at genetic algorithms to solve this problem and modeled it as follows: a test case can be considered as a predator while a mutant program is analogous to a prey. The aim of the selection process is to generate test cases able to kill as many mutants as possible. To overcome disappointing experimentation results on the studied .NET system, we propose a slight variation on this idea, no longer at the ""animal"" level (lions killing zebras) but at the bacteriological level. The bacteriological level indeed better reflects the test case optimization issue: it introduces a memorization function and suppresses the crossover operator. We describe this model and show how it behaves on the case study.",
-1,Trustable Components: Yet Another Mutation-Based Approach,Springer,Trustable components: Yet another mutation-based approach,"Baudry, Benoit, Vu Le Hanh, Jean-Marc Jézéquel, and Yves Le Traon",29," In <i>Mutation testing for the new century</i>, pp. 47-54. Springer US, 2001.","
                          <h2 class=""Heading"">Abstract</h2>
                          <div class=""Para"">This paper presents the use of mutation analysis as the main qualification technique for:
            <div class=""UnorderedList""><ul class=""UnorderedListMarkDash""><li>
                                <p class=""Para"">estimating and automatically enhancing a test set (using genetic algorithms),</p>
                              </li><li>
                                <p class=""Para"">qualifying and improving a component’s contracts (that is the specification facet)</p>
                              </li><li>
                                <p class=""Para"">measuring the impact of contractable robust components on global system robustness and reliability.</p>
                              </li></ul></div>
            The methodology is based on an integrated design and test approach for 00 software components. It is dedicated to design-by-contract, where the specification is systematically derived into executable assertions called contracts (invariant properties, pre/postconditions of methods). The testing-for-trust approach, using the mutation analysis, checks the consistency between specification, implementation and tests. It points out the tests lack of efficiency but also the lack of precision of the contracts. The feasibility of components validation by mutation analysis and its usefulness for test generation are studied as well as the robustness of trustable and self-testable components into an infected environment.</div>
                        ",
-1,Basic Operations for Generating Behavioral Mutants,ieeexplore,Basic operations for generating behavioral mutants,"Belli, Fevzi, Christof J. Budnik, and W. Eric Wong",35," In <i>Mutation Analysis, 2006. Second Workshop on</i>, pp. 9-9. IEEE, 2006.","This paper attempts to subsume the existing great variety of mutation operations to two basic operations, insertion and omission and their combinations. These basic operations are applied to different elements of graph-based models of increasing representation power. A case study applies the approach to these models for generating mutants of different features and compares the fault detection capacity of the mutants generated.",
-1,A Technique for Mutation of Java Objects,ieeexplore,A technique for mutation of Java objects,"Bieman, James M., Sudipto Ghosh, and Roger T. Alexander",29," In <i>Automated Software Engineering, 2001.(ASE 2001). Proceedings. 16th Annual International Conference on</i>, pp. 337-340. IEEE, 2001.","Mutation analysis inserts faults into a program to create test sets that distinguish the mutant from the original program. Inserted faults must represent plausible errors. Standard transformations can mutate scalar values such as integers, floats, and character data. Mutating objects is an open problem, because object semantics are defined by the programmer and can vary widely. We develop mutation operators and support tools that can mutate Java library items that are heavily used in commercial software. Our mutation engine can support reusable libraries of mutation components to inject faults into objects that instantiate items from these common Java libraries. Our technique should be effective for evaluating real-world software testing suites.",
?,Mutation of Model Checker Specifications for Test Generation and Evaluation,Springer,Mutation of model checker specifications for test generation and evaluation,"Black, Paul E., Vadim Okun, and Yaacov Yesha",39," In <i>Mutation testing for the new century</i>, pp. 14-20. Springer US, 2001.","
                          <h2 class=""Heading"">Abstract</h2>
                          <p class=""Para"">Mutation analysis on model checking specifications is a recent development. This approach mutates a specification, then applies a model checker to compare the mutants with the original specification to automatically generate tests or evaluate coverage. The properties of specification mutation operators have not been explored in depth. We report our work on theoretical and empirical comparison of these operators. Our future plans include studying how the form of a specification influences the results, finding relations between different operators, and validating the method against independent metrics.</p>
                        ","
                          <h3 class=""Heading"">Keywords</h3>
                          <span class=""Keyword"">specification mutation</span>
                          <span class=""Keyword"">mutation operators</span>
                          <span class=""Keyword"">test generation</span>
                          <span class=""Keyword"">model checking.</span>
                        "
-1,Evaluation of Test Code Quality with Aspect-Oriented Mutations,Springer,Evaluation of test code quality with aspect-oriented mutations,"Bogacki, Bartosz, and Bartosz Walter",9," In <i>International Conference on Extreme Programming and Agile Processes in Software Engineering</i>, pp. 202-204. Springer Berlin Heidelberg, 2006.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Along with growing popularity of agile methodologies and open source movement, unit testing has become one of the core practices in modern software engineering. It is particularly important in eXtreme Programming [1], which explicitly diminish the importance of other artifacts than source code and tests cases. In XP unit test cases not only verify if software meets functional requirements, but also enable refactoring, alleviate comprehension and provide guidance on how the production code should be used. Therefore, they contribute to many other important practices of XP, which explicitly or implicitly rely on their ability to effectively discover bugs.</p>",
-1,A Mutation Model for the SystemC TLM2.0 Communication Interfaces,acm,A mutation model for the SystemC TLM 2.0 communication interfaces,"Bombieri, Nicola, Franco Fummi, and Graziano Pravadelli",51," In <i>Proceedings of the conference on Design, automation and test in Europe</i>, pp. 396-401. ACM, 2008.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p>Mutation analysis is a widely-adopted strategy in software testing with two main purposes: measuring the quality of test suites, and identifying redundant code in programs. Similar approaches are applied in hardware verification and testing too, especially at RTL or gate level, where mutants are generally referred as faults, and mutation analysis is performed by means of fault modeling and fault simulation. However, in modern embedded systems there is a close integration between HW and SW parts, and verification strategies should be applied early in the design flow. This requires the definition of new mutation analysis-based strategies that work at system level, where HW and SW functionalities are not partitioned yet. In this context, the paper proposes a mutation model for perturbing transaction level modeling (TLM) SystemC descriptions. In particular, the main constructs provided by the SystemC TLM 2.0 library have been analyzed, and a set of mutants is proposed to perturb the primitives related to the TLM communication interfaces.</p></div> 
            

            </div>
          ",
-1,Reference Manual for Ada Mutant Operators,"JH Bowser - Georiga Institute of Technology, Atlanta, Georgia,  …, 1988",Reference manual for Ada mutant operators,"Bowser, John H",25," <i>Georiga Institute of Technology, Atlanta, Georgia, Technique Report GITSERC-88/02</i> (1988).",,
-1,ExMAn: A Generic and Customizable Framework for Experimental Mutation Analysis,ieeexplore,Exman: A generic and customizable framework for experimental mutation analysis. Mutation Analysis,"Bradbury, J. S., J. R. Cordy, and J. Dingel",21," In <i>Workshop on, 0</i>, vol. 4. 2006.","Current mutation analysis tools are primarily used to compare different test suites and are tied to a particular programming language. In this paper we present the ExMAn experimental mutation analysis framework - ExMAn is automated, general and flexible and allows for the comparison of different quality assurance techniques such as testing, model checking, and static analysis. The goal of ExMAn is to allow for automatic mutation analysis that can be reproduced by other researchers. After describing ExMAn, we present a scenario of using ExMAn to compare testing with static analysis of temporal logic properties. We also provide both the benefits and the current limitations of using our framework.",
-1,Mutation Operators for Concurrent Java (J2SE 5.0),ieeexplore,Mutation operators for concurrent Java (J2SE 5.0),"Bradbury, Jeremy S., James R. Cordy, and Juergen Dingel",78," In <i>Mutation Analysis, 2006. Second Workshop on</i>, pp. 11-11. IEEE, 2006.","The current version of Java (J2SE 5.0) provides a high level of support for concurreny in comparison to previous versions. For example, programmers using J2SE 5.0 can now achieve synchronization between concurrent threads using explicit locks, semaphores, barriers, latches, or exchangers. Furthermore, built-in concurrent data structures such as hash maps and queues, built-in thread pools, and atomic variables are all at the programmer's disposal. We are interested in using mutation analysis to evaluate, compare and improve quality assurance techniques for concurrent Java programs. Furthermore, we believe that the current set of method mutation operators and class operators proposed in the literature are insufficient to evaluate concurrent Java source code because the majority of operators do not directly mutate the portions of code responsible for synchronization. In this paper we will provide an overview of concurrency constructs in J2SE 5.0 and a new set of concurrent mutation operators. We will justify the operators by categorizing them with an existing bug pattern taxonomy for concurrency. Most of the bug patterns in the taxonomy have been used to classify real bugs in a benchmark of concurrent Java applications.",
-1,Comparative Assessment of Testing and Model Checking Using Program Mutation,ieeexplore,Comparative assessment of testing and model checking using program mutation,"Bradbury, Jeremy S., James R. Cordy, and Juergen Dingel",25," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 210-222. IEEE, 2007.","Developing correct concurrent code is more difficult than developing correct sequential code. This difficulty is due in part to the many different, possibly unexpected, executions of the program, and leads to the need for special quality assurance techniques for concurrent programs such as randomized testing and state space exploration. In this paper an approach is used that assesses testing and formal analysis tools using metrics to measure the effectiveness and efficiency of each technique at finding concurrency bugs. Using program mutation, the assessment method creates a range of faulty versions of a program and then evaluates the ability of various testing and formal analysis tools to detect these faults. The approach is implemented and automated in an experimental mutation analysis framework (ExMAn) which allows results to be more easily reproducible. To demonstrate the approach, we present the results of a comparison of testing using the IBM tool ConTest and model checking using the NASA tool Java PathFinder (JPF).",
-1,MutateMe,P Brady - 2007,eer WVW,"No, JJw",3,,,
-1,Two Notions of Correctness and Their Relation to Testing,Springer,Two notions of correctness and their relation to testing,"Budd, Timothy A., and Dana Angluin",212," <i>Acta informatica</i> 18, no. 1 (1982): 31-45.","<h2 class=""Heading"">Summary</h2><p class=""Para"">We consider two interpretations for what it means for test data to demonstrate correctness. For each interpretation, we examine under what conditions data sufficient to demonstrate correctness exists, and whether it can be automatically detected and/or generated. We establish the relation between these questions and the problem of deciding equivalence of two programs.</p>",
-1,The Design of a Prototype Mutation System for Program Testing,"TA Budd, RJ Lipton, <a href=""/citations?user=Pil9rEEAAAAJ&amp;hl=en&amp;oi=sra"">R DeMillo</a>, F Sayward - afips, 1899 - IEEE",The design of a prototype mutation system for program testing,"Budd, Timothy A., Richard J. Lipton, Richard DeMillo, and Frederick Sayward",112," In <i>afips</i>, p. 623. IEEE, 1899.",,
-1,Theoretical and Empirical Studies on Using Program Mutation to Test the Functional Correctness of Programs,acm,Theoretical and empirical studies on using program mutation to test the functional correctness of programs,"Budd, Timothy A., Richard A. DeMillo, Richard J. Lipton, and Frederick G. Sayward",174," In <i>Proceedings of the 7th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</i>, pp. 220-233. ACM, 1980.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">
<p>In testing for program correctness, the standard approaches
[11,13,21,22,23,24,34] have centered on finding data D, a finite
subset of all possible inputs to program P, such that</p>

<p>1) if for all x in D, P(x) = f(x), then P* = f</p>

<p>where f is a partial recursive function that specifies the
intended behavior of the program and P* is the function actually
computed by program P. A major stumbling block in such
formalizations has been that the conclusion of (1) is so strong
that, except for trivial classes of programs, (1) is bound to be
formally undecidable [23].</p>

<p>There is an undeniable tendency among practitioners to consider
program testing an ad hoc human technique: one creates test data
that intuitively seems to capture some aspect of the program,
observes the program in execution on it, and then draws conclusions
on the program's correctness based on the observations. To augment
this undisciplined strategy, techniques have been proposed that
yield quantitative information on the degree to which a program has
been tested. (See Goodenough [14] for a recent survey.) Thus the
tester is given an inductive basis for confidence that (1) holds
for the particular application. Paralleling the undecidability of
deductive testing methods, the inductive methods all have had
trivial examples of failure [14,18,22,23].</p>

<p>These deductive and inductive approaches have had a common
theme: all have aimed at the strong conclusion of (1). Program
mutation [1,7,9,27], on the other hand, is a testing technique that
aims at drawing a weaker, yet quite realistic, conclusion of the
following nature:</p>

<p>(2) if for all x in D, P(x) = f(x), then P* = f OR P is
""pathological.""</p>

<p>To paraphrase,</p>

<p>3) if P is not pathological and P(x) = f(x) for all x in D then
P* = f.</p>

<p>Below we will make precise what is meant by ""P is pathological"";
for now it suffices to say that P not pathological means that P was
written by a competent programmer who had a good understanding of
the task to be performed. Therefore if P does not realize f it is
""close"" to doing so. This underlying hypothesis of program mutation
has become known as the <i>competent programmer hypothesis</i>:
either P* = f or some program Q ""close"" to P has the property Q* =
f.</p>

<p>To be more specific, program mutation is a testing method that
proposes the following version of correctness testing:</p>

<p>Given that P was written by a competent programmer, find test
data D for which P(D) = f(D) implies P* = f.</p>

<p>Our method of developing D, assuming either P or some program
close to P is correct, is by eliminating the alternatives. Let
&amp;phis; be the set of programs close to P. We restate the method
as follows:</p>

<p>Find test data D such that:</p>

<p>i) for all x in D P(x) = f(x) and</p>

<p>ii) for all Q in &amp;phis; either Q* = P* or for some x in D,
Q(x) ≠ P(x).</p>

<p>If test data D can be developed having properties (i) and (ii),
then we say that D <i>differentiates</i> P from &amp;phis;,
alternatively P passes the &amp;phis; mutant test.</p>

<p>The goal of this paper is to study, from both theoretical and
experimental viewpoints, two basic questions:</p>

<p><i>Question 1:</i> If P is written by a competent programmer and
if P passes the &amp;phis; mutant test with test data D, does P* =
f?</p>

<p>Note that, after formally defining &amp;phis; for P in a fixed
programming language L, an affirmative answer to question 1 reduces
to showing that the competent programmer hypothesis holds for this
L and &amp;phis;.</p>

<p>We have observed that under many natural definitions of
&amp;phis; there is often a strong coupling between members of
&amp;phis; and a small subset µ. That is, often one can
reduce the problem of finding test data that differentiates P from
&amp;phis; to that of finding test data that differentiates P from
µ. We will call this subset µ the <i>mutants</i> of P
and the second question we will study involves the so-called
<i>coupling effect</i> [9]:</p>

<p><i>Question 2</i> (Coupling Effect): If P passes the µ
mutant test with data D, does P pass the &amp;phis; mutant test
with data D?</p>

<p>Intuitively, one can think of µ as representing the
programs that are ""very close"" to P.</p>

<p>In the next section we will present two types of theoretical
results concerning the two questions above: general results
expressed in terms of properties of the language class L, and
specific results for a class of decision table programs and for a
subset of LISP. Portions of the work on decision tables and LISP
have appeared elsewhere [5,6], but the presentations given here are
both simpler and more unified. In the final section we present a
system for applying program mutation to FORTRAN and we introduce a
new type of software experiment, called a ""beat the system",
-1,Program Testing by Specification Mutation,Elsevier,Program testing by specification mutatio,"Gopal, Ajei, and Timothy Budd",70,". Department of Computer Science, University of Arizona, 1983.",,<span>Testing</span>
-1,EXPER Implementor Guide,ieeexplore,A guide to using the identity selector interoperability profile v1. 5 within web applications and browsers,"Jones, Michael B",315, <i>Microsoft Corporation</i> (2008): 79.,"The authors give a brief introduction to mutation analysis. They they discuss Mothra, emphasizing how it interacts with the tester. The authors present some major problems with using mutation analysis and discuss possible solutions. They conclude with a solution to one of these problems-a method of automatically generating mutation-adequate data.",
-1,Users Guide to the Pilot Mutation System,"T Budd, F Sayward - Yale University, New Haven, Connecticut, Technique  …, 1977",Users guide to the Pilot mutation system,"Budd, Tim, and Fred Sayward",25," <i>Yale University, New Haven, Connecticut, Technique Report</i> 114 (1977).",,
-1,Mutation-Based Testing of Concurrent Programs,ieeexplore,Mutation-based testing of concurrent programs,"Carver, Richard",28," In <i>Test Conference, 1993. Proceedings., International</i>, pp. 845-853. IEEE, 1993.","Mutation-based software testing is a powerful technique for testing software systems. It requires executing many slightly different versions of the same program to evaluate the quality of the test cases used to test the program. Mutation-based testing has been applied to sequential software; however, problems are encountered when it is applied to concurrent programs. These problems are a product of the nondeterminism inherent in the executions of concurrent programs. In this paper, we describe a general approach to testing and debugging concurrent programs, called deterministic execution testing and debugging. We then describe a combination of deterministic execution testing and mutation-based testing, called deterministic execution mutation testing (DEMT), and illustrate the DEMT approach with an example.",
-1,Fault-Based Testing of Database Application Programs with Conceptual Data Model,ieeexplore,Fault-based testing of database application programs with conceptual data model,"Chan, W. K., Shing Chi Cheung, and T. H. Tse",73," In <i>Quality Software, 2005.(QSIC 2005). Fifth International Conference on</i>, pp. 187-196. IEEE, 2005.","Database application programs typically contain program units that use SQL statements to manipulate records in database instances. Testing the correctness of data manipulation by these programs is challenging. When a tester provides a database instance to test such a program, the program unit may output faulty SQL statements and, hence, manipulate inappropriate database records. Nonetheless, these failures may only be revealed in very specific database instances. This paper proposes to integrate SQL statements and the conceptual data models of an application for fault-based testing. It proposes a set of mutation operators based on the standard types of constraint used in the enhanced entity-relationship model. These operators are semantic in nature. This semantic information guides the construction of affected attributes and join conditions of mutants. The usefulness of our proposal is illustrated by an example in which a missing-record fault is revealed.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.semantic mutants..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">semantic mutants.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.database application testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">database application testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.fault-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">fault-based testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Applying Mutation Analysis for Object-Oriented Programs Using a Reflective Approach,ieeexplore,Applying mutation analysis for object-oriented programs using a reflective approach,"Chevalley, Philippe",48," In <i>Software Engineering Conference, 2001. APSEC 2001. Eighth Asia-Pacific</i>, pp. 267-270. IEEE, 2001.","This paper presents a mutation analysis tool based on a reflective macro system. Mutation analysis is a powerful and computationally expensive technique that measures the effectiveness of test cases for revealing faults. The principal expense of mutation analysis is that many faulty versions of the program under test, called mutants, must be repeatedly executed. This technique has originally been developed in the framework of procedural programs, and should be revisited to consider some types of faults likely to appear in object-oriented environments. The mutation system detailed in this paper deals with object-oriented concepts introduced in the Java programming language, and is able to generate automatically mutant programs according to 20 types of object-oriented faults.",
-1,A Mutation Analysis Tool for Java Programs,Springer,A mutation analysis tool for Java programs,"Chevalley, Philippe, and Pascale Thévenod-Fosse",76," <i>International Journal on Software Tools for Technology Transfer (STTT)</i> 5, no. 1 (2003): 90-103.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Program mutation is a fault-based technique for measuring the effectiveness of test cases that, although powerful, is computationally expensive. The principal expense of mutation is that many faulty versions of the program under test, called mutants, must be created and repeatedly executed. This paper describes a tool, called JavaMut, that implements 26 traditional and object-oriented mutation operators for supporting mutation analysis of Java programs. The current version of that tool is based on syntactic analysis and reflection for implementing mutation operators. JavaMut is interactive; it provides a graphical user interface to make mutation analysis faster and less painful. Thanks to such automated tools, mutation analysis should be achieved within reasonable costs. </p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Test case evaluation&nbsp;</span><span class=""Keyword"">Mutation analysis&nbsp;</span><span class=""Keyword"">Mutation operators&nbsp;</span><span class=""Keyword"">Object-oriented programming&nbsp;</span><span class=""Keyword"">Java&nbsp;</span><span class=""Keyword"">Reflective systems&nbsp;</span><span class=""Keyword"">OpenJava &nbsp;</span>"
-1,High-Performance Mutation Testing,Elsevier,High-Performance Mutation Testing,Choi Byoungju,63,jss,,
-1,The SESAME Experience: From Assembly Languages to Declarative Models,ieeexplore,The SESAME experience: from assembly languages to declarative models,"Crouzet, Yves, Helene Waeselynck, Benjamin Lussier, and David Powell",21," In <i>Mutation Analysis, 2006. Second Workshop on</i>, pp. 7-7. IEEE, 2006.","SESAME (Software Environment for Software Analysis by Mutation Effects) is a fault injection tool using mutation as the target fault model. It has been used for 15 years to support dependability research at LAAS-CNRS. A salient feature of SESAME is that it is multi-language. This made it possible to inject faults into software written in assembly languages, procedural languages (Pascal, C), a data-flow language (LUSTRE), as well as in a declarative language for temporal planning in robotics. This paper provides an overview of the tool, and reports on its use in experimental research addressing either fault removal or fault tolerance topics.",
-1,Software Error Analysis: A Real Case Study Involving Real Faults and Mutations,acm,Software error analysis: a real case study involving real faults and mutations,"Daran, Murial, and Pascale Thévenod-Fosse",143," In <i>ACM SIGSOFT Software Engineering Notes</i>, vol. 21, no. 3, pp. 158-171. ACM, 1996.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline"">The paper reports on a first experimental comparison of software errors generated by real faults and by 1st-order mutations. The experiments were conducted on a program developed by a student from the industrial specification of a critical software from the civil nuclear field. Emphasis was put on the analysis of errors produced upon activation of 12 real faults by focusing on the mechanisms of error creation, masking, and propagation up to failure occurrence, and on the comparison of these errors with those created by 24 mutations. The results involve a total of 3730 errors recorded from program execution traces: 1458 errors were produced by the real faults, and the 2272 others by the mutations. They are in favor of a suitable consistency between errors generated by mutations and by real faults: 85% of the 2272 errors due to the mutations were also produced by the real faults. Moreover, it was observed that although the studied mutations were simple faults, they can create erroneous behaviors as complex as those identified for the real faults. This lends support to the representativeness of errors due to mutations.</div> 
            

            </div>
          ",ACM SIGSOFT Software Engineering Notes
-1,AjMutator: A Tool for the Mutation Analysis of AspectJ Pointcut Descriptors,ieeexplore,AjMutator: a tool for the mutation analysis of AspectJ pointcut descriptors,"Delamare, Romain, Benoit Baudry, and Yves Le Traon",40," In <i>Software Testing, Verification and Validation Workshops, 2009. ICSTW'09. International Conference on</i>, pp. 200-204. IEEE, 2009.","Aspect-oriented programming introduces new challenges for software testing. Inparticular the pointcut descriptor (PCD) requires particular attention fromtesters. The PCD describes the set of joinpoints where the advices are woven.In this paper we present a tool, AjMutator, for the mutation analysis of PCDs.AjMutator implements several mutation operators that introduce faults in thePCDs to generate a set of mutants. AjMutator classifies the mutants accordingto the set of joinpoints they match compared to the set of joinpoints matchedby the initial PCD. An interesting result is that this automaticclassification can identify equivalent mutants for a particular class of PCDs.AjMutator can also run a set of test cases on the mutants to give a mutationscore. We have applied AjMutator on two systems to show that this tool issuitable for the mutation analysis of PCDs on large AspectJ systems.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.pointcut descriptors.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">pointcut descriptors</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.aspect-oriented programming.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">aspect-oriented programming</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,ProteumA Tool for the Assessment of Test Adequacy for C Programs,"<a href=""/citations?user=htqWT0IAAAAJ&amp;hl=en&amp;oi=sra"">ME Delamaro</a>, <a href=""/citations?user=78aU9DcAAAAJ&amp;hl=en&amp;oi=sra"">JC Maldonado</a>, <a href=""/citations?user=DdQMeHoAAAAJ&amp;hl=en&amp;oi=sra"">AP Mathur</a> - PCS, 1996 - inf.ufpr.br",Proteum-A Tool for the Assessment of Test Adequacy for C Programs User’s guide,"Delamaro, Márcio Eduardo, José Carlos Maldonado, and A. P. Mathur",223," In <i>PCS</i>, vol. 96, pp. 79-95. 1996.",,
-1,Interface Mutation: Assessing Testing Quality at Interprocedural Level,ieeexplore,Interface mutation: Assessing testing quality at interprocedural level,"Delamaro, Márcio, and Jose Carlos Maldonado",21," In <i>Computer Science Society, 1999. Proceedings. SCCC'99. XIX International Conference of the Chilean</i>, pp. 78-86. IEEE, 1999.","Software testing is one of the hardest and most expensive activities in software development. The need for test adequacy criteria is widely recognized. Several of them, together with software tools to support them, have been proposed. However, in most cases such criteria and tools aim at unit testing only. Other testing phases, like integration testing have few automated aids. Interface mutation is a new criterion for interprocedural test quality assessment based on mutations. This paper focuses on a testing tool named PROTEUM/IM that supports interface mutation for C programs.",
-1,Integration Testing Using Interface Mutation,ieeexplore,Integration testing using interface mutation,"Delamaro, Marcio Eduardo, José Carlos Maldonado, and Aditya P. Mathur",75," In <i>Software Reliability Engineering, 1996. Proceedings., Seventh International Symposium on</i>, pp. 112-121. IEEE, 1996.",A criterion for assessing the adequacy of test sets during integration testing is proposed. The criterion is based on a testing technique named Interface Mutation. The technique itself is designed to be scalable with the size of the software under test; the size being measured in the number of subsystems integrated. Using Interface Mutation it is possible to assess the adequacy of tests incrementally while integrating various subsystems. Also reported are results from a pilot experiment conducted to study the cost and error defection effectiveness of Interface Mutation.,
-1,Interface Mutation: An Approach for Integration Testing,ieeexplore,Interface mutation: An approach for integration testing,"Delamaro, Marcio Eduardo, J. C. Maidonado, and Aditya P. Mathur",262," <i>IEEE transactions on software engineering</i> 27, no. 3 (2001): 228-247.","The need for test adequacy criteria is widely recognized. Several criteria have been proposed for the assessment of adequacy of tests at the unit level. However, there remains a lack of criteria for the assessment of the adequacy of tests generated during integration testing. We present a mutation based interprocedural criterion, named Interface Mutation (IM), suitable for use during integration testing. A case study to evaluate the proposed criterion is reported. In the study, the UNIX sort utility was seeded with errors and Interface Mutation evaluated by measuring the cost of its application and its error revealing effectiveness. Alternative IM criteria using different sets of Interface Mutation operators were also evaluated. While comparing the error revealing effectiveness of these Interface Mutation-based test sets with same size randomly generated test sets, we observed that in most cases Interface Mutation based test sets are superior. The results suggest that Interface Mutation offers a viable test adequacy criteria for use at the integration level.",
-1,Interface Mutation Test Adequacy Criterion: An Empirical Evaluation,Springer,Interface mutation test adequacy criterion: An empirical evaluation,"Delamaro, Márcio Eduardo, José Carlos Maldonado, Alberto Pasquini, and Aditya P. Mathur",23," <i>Empirical Software Engineering</i> 6, no. 2 (2001): 111-142.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">An experiment was conducted to evaluate an inter-procedural test adequacy criterion named Interface Mutation. Program <em class=""EmphasisTypeItalic "">SPACE</em>, developed for the European Space Agency (ESA), was used in this experiment. The development record available for this program was used to find the faults uncovered during its development. Using this information the test process was reproduced starting with a version of <em class=""EmphasisTypeItalic "">SPACE</em> containing several faults and then applying Interface Mutation. Thus we could evaluate the fault revealing effectiveness of Interface Mutation. Results from the experiment suggest that (a) the application of Interface Mutation favors the selection of fault revealing test cases when they exist and (b) Interface Mutation tends to select fault revealing test cases more efficiently than in the case where random selection is used.</p>","<span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">interface mutation&nbsp;</span><span class=""Keyword"">test adequacy criteria&nbsp;</span><span class=""Keyword"">software testing&nbsp;</span>"
-1,Proteum/IM 2.0: An Integrated Mutation Testing Environment,Springer,Proteum/IM 2.0: An integrated mutation testing environment,"Delamaro, Márcio Eduardo, José Carlos Maldonado, and Auri Marcelo Rizzo Vincenzi",72," In <i>Mutation testing for the new century</i>, pp. 91-101. Springer US, 2001.","
                          <h2 class=""Heading"">Abstract</h2>
                          <p class=""Para"">Mutation testing has been used mostly at the unit level. To support its application few tools have been developed and used, mainly in the academic environment. Interface Mutation has been proposed aiming at applying mutation at the integration level. A tool named Proteum/IM was implemented to support such criterion. With the definition of the Interface Mutation criterion the tester has the possibility of applying mutation testing concepts throughout the software development. It seems mandatory to have a single, integrated environment that would support mutation-based unit and integration testing. Such environment, which provides facilities to investigate low-cost and incremental testing strategies, is the focus of this paper.</p>
                        ","
                          <h3 class=""Heading"">Keywords</h3>
                          <span class=""Keyword"">Software Testing</span>
                          <span class=""Keyword"">Mutation testing</span>
                          <span class=""Keyword"">Interface Mutation</span>
                          <span class=""Keyword"">Testing Tool</span>
                          <span class=""Keyword"">Proteum/IM 2.0.</span>
                        "
-1,Program Mutation: An Approach to Software Testing,"<a href=""/citations?user=Pil9rEEAAAAJ&amp;hl=en&amp;oi=sra"">RA DeMillo</a> - 1983 - DTIC Document",Program Mutation: An Approach to Software Testin,"DeMillo, R. A",4,". GEORGIA INST OF TECH ATLANTA SCHOOL OF INFORMATION AND COMPUTER SCIENCE, 1983.",,
-1,On the Use of Software Artifacts to Evaluate the Effectiveness of Mutation Analysis in Detecting Errors in Production Software,Purdue University. Software Engineering Research  … - 1991,"On the Use of Software Artifacts to Evaluate the Effectiveness of Mutation Analysis for Detecting Errors in Production Software, Rapport, Softwarc Engincering Research Ccntcr, Purdue University, W","DeMillo, R. A., and A. P. Mathur",51,a book,,
-1,Test Adequacy and Program Mutation,acm,Class mutation: Mutation testing for object-oriented programs,"Kim, Sunwoo, John A. Clark, and John A. McDermid",35," In <i>Proc. Net. ObjectDays</i>, pp. 9-12. 2000.","
  <div class=""tabbody"">
              <div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"">
                  An abstract is not available.
              </div>
                      

</div>
            ",
-1,An Overview of the Mothra Software Testing Environment,"RA DeMillo, DS Guindi, KN King, WM McCracken… - Purdue University, West  …, 1987",An overview of the mothra software testing environment,"DeMillo, R. A., D. S. Guindi, K. N. King, W. M. McCracken, A. Mathur, and A. Offutt",11," <i>Purdue University, West Lafayette, Indiana, Technique Report SERC-TR-3-P</i> (1987).",,
-1,An Extended Overview of the Mothra Software Testing Environment,ieeexplore,An extended overview of the Mothra software testing environment,"DeMillo, Richard A., Dany S. Guindi, W. M. McCracken, A. J. Offutt, and K. N. King",315," In <i>Software Testing, Verification, and Analysis, 1988., Proceedings of the Second Workshop on</i>, pp. 142-151. IEEE, 1988.","The authors give a brief introduction to mutation analysis. They they discuss Mothra, emphasizing how it interacts with the tester. The authors present some major problems with using mutation analysis and discuss possible solutions. They conclude with a solution to one of these problems-a method of automatically generating mutation-adequate data.",
-1,Compiler-Integrated Program Mutation,ieeexplore,MuJava: a mutation system for Java,"Ma, Yu-Seung, Jeff Offutt, and Yong-Rae Kwon",64," In <i>Proceedings of the 28th international conference on Software engineering</i>, pp. 827-830. ACM, 2006.","A method for integrating support for program mutation into a compiler is presented. The method is both efficient and sufficiently powerful to support program mutation software testing. Moreover, existing research suggests that this approach appears to be essential for the cost-effective application of program mutation to testing large commercial software systems. It is believed that a compiler-integrated approach will provide a significant increase in the efficiency of several existing testing tools and allow program mutation to be effectively used to test commercial software systems.",
-1,Hints on Test Data Selection: Help for the Practicing Programmer,ieeexplore,Hints on test data selection: Help for the practicing programmer,"DeMillo, Richard A., Richard J. Lipton, and Frederick G. Sayward",1899," <i>Computer</i> 11, no. 4 (1978): 34-41.",In many cases tests of a program that uncover simple errors are also effective in uncovering much more complex errors. This so-called coupling effect can be used to save work during the testing process.,
-1,Constraint-Based Automatic Test Data Generation,ieeexplore,Constraint-based automatic test data generation,"DeMilli, R. A., and A. Jefferson Offutt",941," <i>IEEE Transactions on Software Engineering</i> 17, no. 9 (1991): 900-910.",A novel technique for automatically generating test data is presented. The technique is based on mutation analysis and creates test data that approximate relative adequacy. It is a fault-based technique that uses algebraic constraints to describe test cases designed to find particular types of faults. A set of tools (collectively called Godzilla) that automatically generates constraints and solves them to create test cases for unit and module testing has been implemented. Godzilla has been integrated with the Mothra testing system and has been used as an effective way to generate test data that kill program mutants. The authors present an initial list of constraints and discuss some of the problems that have been solved to develop the complete implementation of the technique.,
-1,Experimental Results from an Automatic Test Case Generator,acm,Experimental results from an automatic test case generator,"DeMillo, Richard A., and A. Jefferson Offutt",162," <i>ACM Transactions on Software Engineering and Methodology (TOSEM)</i> 2, no. 2 (1993): 109-127.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><par>Constraint-based testing is a novel way of generating test data to detect specific types of common programming faults. The conditions under which faults will be detected are encoded as mathematical systems of constraints in terms of program symbols. A set of tools, collectively called Godzilla, has been implemented that automatically generates constraint systems and solves them to create test cases for use by the Mothra testing system. Experimental results from using Godzilla show that the technique can produce test data that is very close in terms of mutation adequacy to test data that is produced manually, and at substantially reduced cost. Additionally, these experiments have suggested a new procedure for unit testing, where test cases are viewed as throw-away items rather than scarce resources.</par></div> 
            

            </div>
          ",http://dl.acm.org/citation.cfm?id=151257.151258
-1,Object-Oriented Mutation to Assess the Quality of Tests,ieeexplore,Object-oriented mutation to assess the quality of tests,"Derezińska, Anna",17," In <i>Proceedings of the 29th Conference on EUROMICRO. IEEE Computer Society, Belek, Turkey</i>, pp. 417-420. 2003.",The quality of a test suite can be measured using mutation analysis. Groups of OO mutation operators are proposed for testing object-oriented features. The OO operators applied to UML specification and C++ code are illustrated by an example. Experimental results demonstrate effectiveness of different mutation operators and the reduction of functional test suite.,
-1,Advanced Mutation Operators Applicable in C# Programs,Springer,Advanced mutation operators applicable in C# programs,"Derezińska, Anna",36," In <i>Software Engineering Techniques: Design for Quality</i>, pp. 283-288. Springer US, 2006.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">This paper is devoted to advanced mutation operators for C# source code. They deal with object-oriented (OO mutations) and other complex features of the code. They require structural information about a code, unlike the standard mutations. Applicability of OO operators in C# is compared with those for other OO languages. Operators for specific features of C# language are also proposed. The detailed specification of operators can be provided in terms of pre- and post-conditions of a program transformation. Based on the operators’ specification, the generation of mutated C# programs can be automated.</p>",
-1,Quality Assessment of Mutation Operators Dedicated for C# Programs,ieeexplore,Quality assessment of mutation operators dedicated for C# programs,"Derezinska, Anna",42," In <i>Quality Software, 2006. QSIC 2006. Sixth International Conference on</i>, pp. 227-234. IEEE, 2006.","The mutation technique inserts faults in a program under test in order to assess or generate test cases, or evaluate the reliability of the program. Faults introduced into the source code are defined using mutation operators. They should be related to different, also object-oriented features of a program. The most research on OO mutations was devoted to Java programs. This paper describes analytical and empirical study performed to evaluate the quality of advanced mutation operators for C# programs. Experimental results demonstrate effectiveness of different mutation operators. Unit tests suites and functional tests were used in experiments. A detailed analysis was conducted on mutation operators dealing with delegates and exception handling",
-1,CREAMA System for Object-Oriented Mutation of C# Programs,"<a href=""/citations?user=O2vVf90AAAAJ&amp;hl=en&amp;oi=sra"">A Derezińska</a>, A Szustek - …  Gdansk University of Technology Faculty of  …, 2007 - ii.pw.edu.pl",CREAM-a System for Object-oriented Mutation of C# Programs,"Derezińska, Anna, and Anna Szustek",12, <i>Annals Gdansk University of Technology Faculty of ETI</i> 5 (2007): 389-406.,,
-1,Tool-Supported Advanced Mutation Approach for Verification of C# Programs,ieeexplore,Tool-supported advanced mutation approach for verification of C# programs,"Derezinska, Anna, and Anna Szustek",34," In <i>Dependability of Computer Systems, 2008. DepCos-RELCOMEX'08. Third International Conference on</i>, pp. 261-268. IEEE, 2008.","Mutation testing is a fault-based testing technique used to inject faults into an existing program and see if its test suite is sensitive enough to detect common faults. We are interested in using the mutation analysis to evaluate, compare and improve quality assurance techniques for testing object-oriented mechanisms and other advanced features of C# programs. This paper provides an overview of a current version of the CREAM system (CREAtor of Mutants), and reports on its use in experimental research. We apply advanced, object-oriented mutation operators to testing of open-source C# programs and discuss the results.",
-1,A Controlled Experiment Assessing Test Case Prioritization Techniques via Mutation Faults,ieeexplore,A controlled experiment assessing test case prioritization techniques via mutation faults,"Do, Hyunsook, and Gregg Rothermel",71," In <i>Software Maintenance, 2005. ICSM'05. Proceedings of the 21st IEEE International Conference on</i>, pp. 411-420. IEEE, 2005.","Regression testing is an important part of software maintenance, but it can also be very expensive. To reduce this expense, software testers may prioritize their test cases so that those that are more important are run earlier in the regression testing process. Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited to hand-seeded faults, primarily due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults. We have therefore designed and performed a controlled experiment to assess the ability of prioritization techniques to improve the rate of fault detection techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. We also compare our results to those collected earlier with respect to the relationship between hand-seeded faults and mutation faults, and the implications this has for researchers performing empirical studies of prioritization.",
0,On the Use of Mutation Faults in Empirical Assessments of Test Case Prioritization Techniques,ieeexplore,On the use of mutation faults in empirical assessments of test case prioritization techniques,"Do, Hyunsook, and Gregg Rothermel",206," <i>IEEE Transactions on Software Engineering</i> 32, no. 9 (2006): 733-752.","Regression testing is an important activity in the software life cycle, but it can also be very expensive. To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of test case prioritization techniques is to increase a test suite's rate of fault detection (how quickly, in a run of its test cases, that test suite can detect faults). Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited primarily to hand-seeded faults, largely due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults and that the use of hand-seeded faults can be problematic for the validity of empirical results focusing on fault detection. We have therefore designed and performed two controlled experiments assessing the ability of prioritization techniques to improve the rate of fault detection of test case prioritization techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. More importantly, a comparison of our results with those collected using hand-seeded faults reveals several implications for researchers performing empirical studies of test case prioritization techniques in particular and testing techniques in general","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Regression testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Regression testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case prioritization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case prioritization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.program mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">program mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical studies..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical studies.</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,A Framework for Mutant Genetic Generation for WS-BPEL,,A Framework for Mutant Genetic Generation for WS-BPEL,"Domínguez-Jiménez, Juan, Antonia Estero-Botaro, and Inmaculada Medina-Bulo.",26,SOFSEM 2009: Theory and Practice of Computer Science (2009),,
?,Vulnerability Testing of Software System Using Fault Injection,"<a href=""/citations?user=1aMkcasAAAAJ&amp;hl=en&amp;oi=sra"">W Du</a>, <a href=""/citations?user=DdQMeHoAAAAJ&amp;hl=en&amp;oi=sra"">AP Mathur</a> - …  Lafayette, Indiana, Technique Report COAST TR, 1998 - academia.edu",Vulnerability testing of software system using fault injection,"Du, Wenliang, and Aditya P. Mathur",62," <i>Purdue University, West Lafayette, Indiana, Technique Report COAST TR</i> (1998): 98-02.",,
-1,Testing for Software Vulnerability Using Environment Perturbation,Wiley Online Library,Testing for software vulnerability using environment perturbation,"Du, Wenliang, and Aditya P. Mathur",91," <i>Quality and Reliability Engineering International</i> 18, no. 3 (2002): 261-272.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>We describe a methodology for testing a software system for possible security flaws. Based on the observation that most security flaws are caused by the program's inappropriate interactions with the environment, and are triggered by a user's malicious perturbation on the environment (which we call an environment fault), we view the security testing problem as the problem of testing for the fault-tolerance properties of a software system. We consider each environment perturbation as a fault and the resulting security compromise a failure in the toleration of such faults. Our approach is based on the well-known technique of fault injection. Environment faults are injected into the system under test and system behavior observed. The failure to tolerate faults is an indicator of a potential security flaw in the system. An Environment-Application Interaction (EAI) fault model is proposed which guides us to decide what faults to inject. Based on EAI, we have developed a security testing methodology, and applied it to several applications. We have successfully identified a number of vulnerabilities including vulnerabilities in the Windows NT operating system. Copyright © 2002 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">security testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">security flaws; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault injection; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">environment perturbation</span></li>"
-1,Mutation Analysis for Lustre Programs: Fault Model Description and Validation,ieeexplore,Mutation analysis for lustre programs: Fault model description and validation,"Du Bousquet, Lydie, and Michel Delaunay",4," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 176-184. IEEE, 2007.","Mutation analysis is usually used to provide an indication of the fault detection ability of a test set. It is mainly used for unit testing evaluation, but has also been extended for integration testing evaluation. This paper describes adaptation of mutation analysis to the Lustre programming language, including both unit and integration testing. This paper focuses on the fault model, which has been extended since our previous works. Validation of the fault model is presented.",
-1,Using Mutation Analysis to Evaluate Test Generation Strategies in a Synchronous Context,ieeexplore,Using mutation analysis to evaluate test generation strategies in a synchronous context,"du Bousquet, Lydie, and Michel Delaunay",4," In <i>Software Engineering Advances, 2007. ICSEA 2007. International Conference on</i>, pp. 40-40. IEEE, 2007.","LUTESS is a test data generator dedicated to synchronous software validation. The tool produces test with respect to an environment description. To check if this description is really as expected, we use mutation analysis. The key point of the approach is to select a subset of mutants which characterizes some kind of ""interesting situations"" that are supposed to be often produced thanks to environment description. Intuitively, if preselected mutants are killed ""very often"" during tests, environment description is as expected (with respect to these ""interesting situations"").",
-1,The Csaw C Mutation Tool:Initial Results,ieeexplore,The Csaw C mutation tool: Initial results,"Ellims, Michael, Darrel Ince, and Marian Petre",36," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 185-192. IEEE, 2007.",There is a perceived lack of mutation tools for the C language and information about the tools that are available was not widely disseminated until recently. This has lead to the development of a small set of programs to support the use of mutation on C language programs as part of a research effort into the use of automatically generated test sets. This paper describes a lightweight C language mutation tool and some initial results from its application to sorting algorithms. The paper describes how kill rates could be improved using a different encoding for Boolean values and details how the use of CPU time can be used as an additional means of detecting mutants.,
-1,Mutation Operators for WS-BPEL 2.0,"<a href=""/citations?user=xQq9tZ0AAAAJ&amp;hl=en&amp;oi=sra"">A Estero-Botaro</a>, <a href=""/citations?user=YYxn9QwAAAAJ&amp;hl=en&amp;oi=sra"">F Palomo-Lozano</a>… - …  on Software &amp;  …, 2008 - researchgate.net",Quality metrics for mutation testing with applications to WS‐BPEL compositions,"Estero‐Botaro, Antonia, Francisco Palomo‐Lozano, Inmaculada Medina‐Bulo, Juan José Domínguez‐Jiménez, and Antonio García‐Domínguez",49," <i>Software Testing, Verification and Reliability</i> 25, no. 5-7 (2015): 536-571.",,
-1,Proteum/FSM: A Tool to Support Finite State Machine Validation Based on Mutation Testing,ieeexplore,Proteum/FSM: a tool to support finite state machine validation based on mutation testing,"Fabbri, Sandra Camargo Pinto Ferraz, José Carlos Maldonado, and M. E. Delamaro",47," In <i>Computer Science Society, 1999. Proceedings. SCCC'99. XIX International Conference of the Chilean</i>, pp. 96-104. IEEE, 1999.","The quality of the VV&amp;T-Verification, Validation and Testing-activity is extremely relevant to the software development process. Testing techniques and criteria have been investigated in the context of VV&amp;T of reactive systems specifications, providing mechanisms to the VV&amp;T activity quality assessment. The establishment of a low-cost, effective testing and validation strategy and the development of supporting tools have been pursued by many researchers for coding and specification as well. This paper discusses the main architectural and operational aspects of a tool, named Proteum/FSM, that supports the application of mutation testing for validating reactive systems specifications based on finite state machines (FSM). Further improvements and research issues are briefly discussed.",
-1,Mutation Testing Applied to Validate Specifications Based on Petri Nets,,Mutation testing applied to validate specifications based on statecharts,"Fabbri, Sandra Camargo Pinto Ferraz, José Carlos Maldonado, Tatiana Sugeta, and Paulo Cesar Masiero",72," In <i>Software Reliability Engineering, 1999. Proceedings. 10th International Symposium on</i>, pp. 210-219. IEEE, 1999.",,
-1,Mutation Testing Applied to Validate Specifications Based on Statecharts,ieeexplore,Mutation testing applied to validate specifications based on petri nets,"Fabbri, Sandra Camargo Pinto Ferraz, José Carlos Maldonado, Paulo Cesar Masiero, Márcio Eduardo Delamaro, and E. Wong",109," In <i>Formal Description Techniques VIII</i>, pp. 329-337. Springer US, 1996.","The establishment of a low-cost, effective testing and validation strategy has been pursued by many researchers at the program level as well as at the specification level. The application of mutation testing for validating specifications based on statecharts is proposed. A mutation operator set for statecharts, one of the crucial points for effectively applying mutation testing is defined; in this scope these operators can be taken as a fault model. We also provide strategies to abstract the statechart components according to different statechart features that may comprise the testing and validation activity aims, providing in this way mechanisms for the establishment of an incremental, hierarchical, mutation-based testing strategy. Implementation and functional aspects of PROTEUM/ST, a tool under development are also presented.",
-1,Mutation Analysis Testing for Finite State Machines,ieeexplore,Mutation analysis testing for finite state machines,"Fabbri, SC Pinto Ferraz, Márcio Eduardo Delamaro, José Carlos Maldonado, and Paulo Cesar Masiero",136," In <i>Software Reliability Engineering, 1994. Proceedings., 5th International Symposium on</i>, pp. 220-229. IEEE, 1994.","Proposes the application of the mutation analysis criterion in the context of specifications based on finite state machines. The main concepts of finite state machines and mutation analysis are briefly introduced. An experiment is reported which manually applies mutation analysis to a finite state machine modeling a Class 0 ISO transport protocol specification, using two test-sequence generator criteria-the W method and the TT (transition tours) method. The results obtained are presented, and evidences are given that the use of mutation analysis is effective in this context. Finally, the lines of evolution of the work presented in this paper are briefly discussed.",
-1,ESTP: An Experimental Software Testing Platform,ieeexplore,ESTP: An experimental software testing platform,"Feng, Xin, Simon Marr, and Tony O'Callaghan",6," In <i>Practice and Research Techniques, 2008. TAIC PART'08. Testing: Academic &amp; Industrial Conference</i>, pp. 59-63. IEEE, 2008.","Most commercial software testing tools used in industry do not automatically generate test data even though many testing strategies have been proposed in academia. In this paper, we introduce a prototype software testing platform that we developed to automatically generate test data from tabular specifications. This method of documenting software specifications has been used successfully in industry to help produce reliable software. This platform can also be used to measure the effectiveness of new testing strategies.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Test case constraint.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Test case constraint</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.constraint solver.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">constraint solver</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.tabular expression.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">tabular expression</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Mutation Testing for Aspect-Oriented Programs,ieeexplore,Mutation testing for aspect-oriented programs,"Ferrari, Fabiano Cutigi, José Carlos Maldonado, and Awais Rashid",99," In <i>Software Testing, Verification, and Validation, 2008 1st International Conference on</i>, pp. 52-61. IEEE, 2008.","Mutation testing has been shown to be one of the strongest testing criteria for the evaluation of both programs and test suites. Comprehensive sets of mutants require strong test sets to achieve acceptable testing coverage. Moreover, mutation operators are valuable for the evaluation of other testing approaches. Although its importance has been highlighted for Aspect-Oriented (AO) programs, there is still a need for a suitable set of mutation operators for AO languages. The quality of the mutation testing itself relies on the quality of such operators. This paper presents the design of a set of mutation operators for AspectJ-based programs. These operators model instances of fault types identified in an extensive survey. The fault types and respective operators are grouped according to the related languages features. We also discuss the generalisation of the fault types to AO approaches other than AspectJ and the coverage that may be achieved with the application of the proposed operators. In addition, a cost analysis based on two case studies involving real-world applications has provided us feedback on the most expensive operators, which will support the definition of further testing strategies.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.AO fault types.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">AO fault types</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Aspect-Oriented testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Aspect-Oriented testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation operators.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation operators</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
-1,Efficient Mutation Analysis: A New Approach,acm,Efficient mutation analysis: A new approach,"Fleyshgakker, Vladimir N., and Stewart N. Weiss",30," In <i>Proceedings of the 1994 ACM SIGSOFT international symposium on Software testing and analysis</i>, pp. 185-195. ACM, 1994.","


 ",
-1,All-Uses vs Mutation Testing: An Experimental Comparison of Effectiveness,Elsevier,All-uses vs mutation testing: an experimental comparison of effectiveness,"Frankl, Phyllis G., Stewart N. Weiss, and Cang Hu",218," <i>Journal of Systems and Software</i> 38, no. 3 (1997): 235-253.",,
-1,Mutant Minimization for Model-Checker Based Test-Case Generation,ieeexplore,Mutant minimization for model-checker based test-case generation,"Fraser, Gordon, and Franz Wotawa",19," In <i>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION, 2007. TAICPART-MUTATION 2007</i>, pp. 161-168. IEEE, 2007.","Mutation of model-checker specifications is used to generate test-cases automatically. In general, model-checker based techniques are efficient when using small, abstract models, but are limited in their applicability by the performance of the model-checker. Issues that contribute to potentially bad performance are equivalent mutants which result in no test-cases, and the fact that many different mutants lead to identical or subsumed test-cases. Another drawback of such approaches is that the size of resulting test-suites can be rather large, which might require test-suite reduction as an additional post-processing step. In this paper, we describe how the number of mutants can be minimized with special properties, which help to detect equivalent mutants more quickly and to avoid the creation of redundant test-cases. Consequently, the size of created test-suites is reduced.",
-1,Estimation and Enhancement of Real-Time Software Reliability through Mutation Analysis,ieeexplore,Estimation and enhancement of real-time software reliability through mutation analysis,"Geist, Robert, A. Jefferson Offutt, and Frederick C. Harris",62," <i>IEEE Transactions on Computers</i> 41, no. 5 (1992): 550-558.","A simulation-based method for obtaining numerical estimates of the reliability of N-version, real-time software is proposed. An extended stochastic Petri net is used to represent the synchronization structure of N versions of the software, where dependencies among versions are modeled through correlated sampling of module execution times. The distributions of execution times are derived from automatically generated test cases that are based on mutation testing. Since these test cases are designed to reveal software faults, the associated execution times and reliability estimates are likely to be conservative. Experimental results using specifications for NASA's planetary lander control software suggest that mutation-based testing could hold greater potential for enhancing reliability than the desirable but perhaps unachievable goal of independence among N versions. Nevertheless, some support for N-version enhancement of high-quality, mutation-tested code is also offered. Mutation analysis could also be valuable in the design of fault-tolerant software systems.",
-1,An Automated Approach for Identifying Potential Vulnerabilities in Software,ieeexplore,An automated approach for identifying potential vulnerabilities in software,"Ghosh, Anup K., Tom O'Connor, and Gary McGraw",130," In <i>Security and Privacy, 1998. Proceedings. 1998 IEEE Symposium on</i>, pp. 104-114. IEEE, 1998.","The paper presents results from analyzing the vulnerability of security-critical software applications to malicious threats and anomalous events using an automated fault injection analysis approach. The work is based on the well understood premise that a large proportion of security violations result from errors in software source code and configuration. The methodology employs software fault injection to force anomalous program states during the execution of software and observes their corresponding effects on system security. If insecure behaviour is detected, the perturbed location that resulted in the violation is isolated for further analysis and possibly retrofitting with fault tolerant mechanisms.",
-1,Towards Measurement of Testability of Concurrent Object-Oriented Programs Using Fault Insertion: A Preliminary Investigation,ieeexplore,Towards measurement of testability of concurrent object-oriented programs using fault insertion: a preliminary investigation,"Ghosh, Sudipto",18," In <i>Source Code Analysis and Manipulation, 2002. Proceedings. Second IEEE International Workshop on</i>, pp. 17-25. IEEE, 2002.","There is a lack of methods and techniques for measuring testability of concurrent object-oriented programs. Current theory and practice for testing sequential programs do not usually apply to concurrent systems. An approach towards measuring the testability of concurrent Java programs is proposed in this paper. The key idea is to take a program and insert faults that are related to the concurrency aspects. The approach is based on two methods: (1) mutation of the program based on keywords, and (2) creation of conflict graphs based on static analysis of the code.",
