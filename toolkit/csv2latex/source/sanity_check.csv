search_title,database,result_title,authors,citation,venue,abstract,keywords
Efficient Mutation Killers in Action,ieeexplore,Efficient mutation killers in action,"Aichernig, Bernhard K., Harald Brandl, Elisabeth Jöbstl, and Willibald Krenn",23," In <i>Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on</i>, pp. 120-129. IEEE, 2011.","This paper presents the techniques and results of a novel model-based test case generation approach that automatically derives test cases from UML state machines. Mutation testing is applied on the modeling level to generate test cases. We present the test case generation approach, discuss the tool chain, and present the properties of the generated test cases. The main contribution of this paper is an empirical study of a car alarm system where different strategies for killing mutants are compared. We present detailed figures on the effectiveness of the test case generation technique. Although UML serves as an input language, all techniques are grounded on solid foundations: we give UML state transition diagrams a formal semantics by mapping them to Back's action systems.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Unified Modeling Language.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Unified Modeling Language</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.ioco.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">ioco</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.action systems.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">action systems</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Killing strategies for model-based mutation testing,Wiley Online Library,Killing strategies for model‐based mutation testing,"Aichernig, Bernhard K., Harald Brandl, Elisabeth Jöbstl, Willibald Krenn, Rupert Schlick, and Stefan Tiran",32," <i>Software Testing, Verification and Reliability</i> 25, no. 8 (2015): 716-748.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">Summary</h2><p>This article presents the techniques and results of a novel model-based test case generation approach that automatically derives test cases from UML state machines. The main contribution of this article is the fully automated fault-based test case generation technique together with two empirical case studies derived from industrial use cases. Also, an in-depth evaluation of different fault-based test case generation strategies on each of the case studies is given and a comparison with plain random testing is conducted. The test case generation methodology supports a wide range of UML constructs and is grounded on the formal semantics of Back's action systems and the well-known input–output conformance relation. Mutation operators are employed on the level of the specification to insert faults and generate test cases that will reveal the faults inserted. The effectiveness of this approach is shown and it is discussed how to gain a more expressive test suite by combining cheap but undirected random test case generation with the more expensive but directed mutation-based technique. Finally, an extensive and critical discussion of the lessons learnt is given as well as a future outlook on the general usefulness and practicability of mutation-based test case generation. Copyright © 2014 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test case generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model-based testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">random testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">ioco; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">action systems; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Unified Modeling Language; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">UML</span></li>"
Using mutation analysis for assessing and comparing testing coverage criteria,ieeexplore,Using mutation analysis for assessing and comparing testing coverage criteria,"Andrews, James H., Lionel C. Briand, Yvan Labiche, and Akbar Siami Namin",330," <i>IEEE Transactions on Software Engineering</i> 32, no. 8 (2006): 608-624.","The empirical assessment of test techniques plays an important role in software testing research. One common practice is to seed faults in subject software, either manually or by using a program that generates all possible mutants based on a set of mutation operators. The latter allows the systematic, repeatable seeding of large numbers of faults, thus facilitating the statistical analysis of fault detection effectiveness of test suites; however, we do not know whether empirical results obtained this way lead to valid, representative conclusions. Focusing on four common control and data flow criteria (block, decision, C-use, and P-use), this paper investigates this important issue based on a middle size industrial program with a comprehensive pool of test cases and known faults. Based on the data available thus far, the results are very consistent across the investigated criteria as they show that the use of mutation operators is yielding trustworthy results: generated mutants can be used to predict the detection effectiveness of real faults. Applying such a mutation analysis, we then investigate the relative cost and effectiveness of the above-mentioned criteria by revisiting fundamental questions regarding the relationships between fault detection, test suite size, and control/data flow coverage. Although such questions have been partially investigated in previous studies, we can use a large number of mutants, which helps decrease the impact of random variation in our analysis and allows us to use a different analysis approach. Our results are then; compared with published studies, plausible reasons for the differences are provided, and the research leads us to suggest a way to tune the mutation analysis process to possible differences in fault detection probabilities in a specific environment","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.experimental design..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">experimental design.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Testing and debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Testing and debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing strategies.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing strategies</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test coverage of code.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test coverage of code</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Using mutation to assess fault detection capability of model review,Wiley Online Library,Using mutation to assess fault detection capability of model review,"Arcaini, Paolo, Angelo Gargantini, and Elvinia Riccobene",6," <i>Software Testing, Verification and Reliability</i> 25, no. 5-7 (2015): 629-652.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">Summary</h2><p>Among validation techniques, <em>model review</em> is a static analysis approach that can be performed at the early stages of software development, at the specification level, and aims at determining if a model owns certain quality attributes (like completeness, consistency and minimality). However, the model review capability to detect behavioural faults has never been measured. In this paper, a methodology and a supporting tool for evaluating the fault detection capability of a NuSMV model advisor are presented, which performs an automatic static model review of NuSMV models. The approach is based on the use of <em>mutation</em> in a similar way as in mutation testing: several mutation operators for NuSMV models are defined, and the model advisor is used to detect behavioural faults by statically analysing mutated specifications. In this way, it is possible to measure the model advisor ability to discover faults. To improve the quality of the analysis, the equivalence between a NuSMV model and any of its mutants must be checked. To perform this task, this paper proposes a technique based on the concept of equivalent Kripke structures, as NuSMV models are Kripke structures. A number of experiments assess the fault-detecting capability, precision and accuracy of the proposed approach. Analysis of variance is used to check if the results are statistically significant. Some relationships among mutation operators and model quality attributes are also established. Copyright © 2014 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">model review; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault detection capability; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">NuSMV; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">equivalent mutants</span></li>"
An empirical evaluation of mutation testing for improving the test quality of safety-critical software,ieeexplore,An empirical evaluation of mutation testing for improving the test quality of safety-critical software,"Baker, Richard, and Ibrahim Habli",24," <i>IEEE Transactions on Software Engineering</i> 39, no. 6 (2013): 787-805.","Testing provides a primary means for assuring software in safety-critical systems. To demonstrate, particularly to a certification authority, that sufficient testing has been performed, it is necessary to achieve the test coverage levels recommended or mandated by safety standards and industry guidelines. Mutation testing provides an alternative or complementary method of measuring test sufficiency, but has not been widely adopted in the safety-critical industry. In this study, we provide an empirical evaluation of the application of mutation testing to airborne software systems which have already satisfied the coverage requirements for certification. Specifically, we apply mutation testing to safety-critical software developed using high-integrity subsets of C and Ada, identify the most effective mutant types, and analyze the root causes of failures in test cases. Our findings show how mutation testing could be effective where traditional structural coverage analysis and manual peer review have failed. They also show that several testing issues have origins beyond the test activity, and this suggests improvements to the requirements definition and coding process. Our study also examines the relationship between program characteristics and mutation survival and considers how program size can provide a means for targeting test areas most likely to have dormant faults. Industry feedback is also provided, particularly on how mutation testing can be integrated into a typical verification life cycle of airborne software.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.certification.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">certification</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.safety-critical software.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">safety-critical software</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.verification.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">verification</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
From genetic to bacteriological algorithms for mutation-based testing,Wiley Online Library,From genetic to bacteriological algorithms for mutation‐based testing,"Baudry, Benoit, Franck Fleurey, Jean‐Marc Jézéquel, and Yves Le Traon",82," <i>Software Testing, Verification and Reliability</i> 15, no. 2 (2005): 73-96.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>The level of confidence in a software component is often linked to the quality of its test cases. This quality can in turn be evaluated with mutation analysis: faults are injected into the software component (making mutants of it) to check the proportion of mutants detected (‘killed’) by the test cases. But while the generation of a set of basic test cases is easy, improving its quality may require prohibitive effort. This paper focuses on the issue of automating the test optimization. The application of genetic algorithms would appear to be an interesting way of tackling it. The optimization problem is modelled as follows: a test case can be considered as a predator while a mutant program is analogous to a prey. The aim of the selection process is to generate test cases able to kill as many mutants as possible, starting from an initial set of predators, which is the test cases set provided by the programmer. To overcome disappointing experimentation results, on .Net components and unit Eiffel classes, a slight variation on this idea is studied, no longer at the ‘animal’ level (lions killing zebras, say) but at the bacteriological level. The bacteriological level indeed better reflects the test case optimization issue: it mainly differs from the genetic one by the introduction of a memorization function and the suppression of the crossover operator. The purpose of this paper is to explain how the genetic algorithms have been adapted to fit with the issue of test optimization. The resulting algorithm differs so much from genetic algorithms that it has been given another name: bacteriological algorithm. Copyright © 2005 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">automatic test generation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">evolutionist algorithms; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">object-oriented testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis</span></li>"
Exploiting model morphology for event-based testing,ieeexplore,Exploiting model morphology for event-based testing,"Belli, Fevzi, and Mutlu Beyazıt",3," <i>IEEE Transactions on Software Engineering</i> 41, no. 2 (2015): 113-134.","Model-based testing employs models for testing. Model-based mutation testing (MBMT) additionally involves fault models, called mutants, by applying mutation operators to the original model. A problem encountered with MBMT is the elimination of equivalent mutants and multiple mutants modeling the same faults. Another problem is the need to compare a mutant to the original model for test generation. This paper proposes an event-based approach to MBMT that is not fixed on single events and a single model but rather operates on sequences of events of length k ≥ 1 and invokes a sequence of models that are derived from the original one by varying its morphology based on k. The approach employs formal grammars, related mutation operators, and algorithms to generate test cases, enabling the following: (1) the exclusion of equivalent mutants and multiple mutants; (2) the generation of a test case in linear time to kill a selected mutant without comparing it to the original model; (3) the analysis of morphologically different models enabling the systematic generation of mutants, thereby extending the set of fault models studied in related literature. Three case studies validate the approach and analyze its characteristics in comparison to random testing and another MBMT approach.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutant selection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutant selection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-based mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-based mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.grammar-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">grammar-based testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
"Mutation Testing of"" Go-Back"" Functions Based on Pushdown Automata",ieeexplore,"Mutation Testing of ""Go-Back"" Functions Based on Pushdown Automata","Belli, Fevzi, Mutlu Beyazit, Tomohiko Takagi, and Zengo Furukawa",7,"Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on","A go-back (GB) function for canceling recent user or system operations and going back to and resuming of previous state(s) is very often used regardless of the application domain. Therefore, faulty handling of them can cause severe damages in those applications. This paper proposes a mutation-based approach to testing GB functions modeled by pushdown automata. Novel mutation operators, recent coverage criteria, and a new algorithm for test case generation are introduced. A case study validates the approach and discusses its characteristics.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.pushdown automata.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">pushdown automata</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.go-back function.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">go-back function</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.model-based testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">model-based testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
An approach for testing pointcut descriptors in aspectj,Wiley Online Library,An approach for testing pointcut descriptors in aspectj,"Delamare, Romain, Benoit Baudry, Sudipto Ghosh, Shashank Gupta, and Yves Le Traon",7," <i>Software Testing, Verification and Reliability</i> 21, no. 3 (2011): 215-239.","Aspect-oriented programming (AOP) promises better software quality through enhanced modularity. Crosscutting concerns are encapsulated in separate units called aspects and are introduced at specific points in the base program at compile time or runtime. However, aspect-oriented mechanisms also introduce new risks for reliability that must be tackled by specific testing techniques in order to fully benefit from the use of AOP. This paper focuses on the pointcut descriptor (PCD) that declares the set of points in the base program's execution where the crosscutting concern must be woven. A fault in the PCD can have a ripple effect and result in many different faults. New behavior may be added in unexpected places, or places where new behavior should be added may be missed. When implementing aspect-oriented programs with AspectJ, JUnit is most commonly used to test the program. However, JUnit does not offer any mechanism to look for faults specifically located in the PCD. As a consequence, these faults can be detected only through complex test scenarios and side effects that are difficult to trigger and observe. This paper proposes to monitor the execution of advices in an aspect-oriented program and use this information to build test cases that target faults in PCDs. The AdviceTracer tool has been developed to automatically monitor and store all information related to advice executions. It also offers a set of operations that can be used to check the presence or absence of advices at specific points in the execution. These operations improve the definition of an oracle for PCD test cases. An empirical study is performed to compare JUnit and AdviceTracer for testing PCDs in terms of the complexity of test cases and their ability to detect faults. The study is performed on a Healthwatcher system that has 93 classes and 19 PCDs. It reveals that test cases that use AdviceTracer to test PCDs are easier to write (shorter test cases and written in less time than with JUnit) and detect more faults. ","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">aspect-oriented programming; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test oracle; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test framework</span></li>"
Generating complex and faulty test data through model-based mutation analysis,ieeexplore,Generating complex and faulty test data through model-based mutation analysis,"Di Nardo, Daniel, Fabrizio Pastore, and Lionel Briand",8," In <i>Software Testing, Verification and Validation (ICST), 2015 IEEE 8th International Conference on</i>, pp. 1-10. IEEE, 2015.","Testing the correct behaviour of data processing systems in the presence of faulty data is extremely expensive. The data structures processed by these systems are often complex, with many data fields and multiple constraints among them. Software engineers, in charge of testing these systems, have to handcraft complex data files or databases, while ensuring compliance with the multiple constraints to prevent the generation of trivially invalid inputs. In addition, assessing test results often means analysing complex output and log data. Though many techniques have been proposed to automatically test systems based on models, little exists in the literature to support the testing of systems where the complexity is in the data consumed in input or produced in output, with complex constraints between them. In particular, such systems often need to be tested with the presence of faults in the input data, in order to assess the robustness and behaviour of the system in response to such faults. This paper presents an automated test technique that relies upon six generic mutation operators to automatically generate faulty data. The technique receives two inputs: field data and a data model, i.e. a UML class diagram annotated with stereotypes and OCL constraints. The annotated class diagram is used to tailor the behaviour of the generic mutation operators to the fault model that is assumed for the system under test and the environment in which it is deployed. Empirical results obtained with a large data acquisition system in the satellite domain show that our approach can successfully automate the generation of test suites that achieve slightly better instruction coverage than manual testing based on domain expertise.",
A controlled experiment assessing test case prioritization techniques via mutation faults,ieeexplore,A controlled experiment assessing test case prioritization techniques via mutation faults,"Do, Hyunsook, and Gregg Rothermel",71," In <i>Software Maintenance, 2005. ICSM'05. Proceedings of the 21st IEEE International Conference on</i>, pp. 411-420. IEEE, 2005.","Regression testing is an important part of software maintenance, but it can also be very expensive. To reduce this expense, software testers may prioritize their test cases so that those that are more important are run earlier in the regression testing process. Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited to hand-seeded faults, primarily due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults. We have therefore designed and performed a controlled experiment to assess the ability of prioritization techniques to improve the rate of fault detection techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. We also compare our results to those collected earlier with respect to the relationship between hand-seeded faults and mutation faults, and the implications this has for researchers performing empirical studies of prioritization.",
On the use of mutation faults in empirical assessments of test case prioritization techniques,ieeexplore,On the use of mutation faults in empirical assessments of test case prioritization techniques,"Do, Hyunsook, and Gregg Rothermel",206," <i>IEEE Transactions on Software Engineering</i> 32, no. 9 (2006): 733-752.","Regression testing is an important activity in the software life cycle, but it can also be very expensive. To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of test case prioritization techniques is to increase a test suite's rate of fault detection (how quickly, in a run of its test cases, that test suite can detect faults). Previous work has shown that prioritization can improve a test suite's rate of fault detection, but the assessment of prioritization techniques has been limited primarily to hand-seeded faults, largely due to the belief that such faults are more realistic than automatically generated (mutation) faults. A recent empirical study, however, suggests that mutation faults can be representative of real faults and that the use of hand-seeded faults can be problematic for the validity of empirical results focusing on fault detection. We have therefore designed and performed two controlled experiments assessing the ability of prioritization techniques to improve the rate of fault detection of test case prioritization techniques, measured relative to mutation faults. Our results show that prioritization can be effective relative to the faults considered, and they expose ways in which that effectiveness can vary with characteristics of faults and test suites. More importantly, a comparison of our results with those collected using hand-seeded faults reveals several implications for researchers performing empirical studies of test case prioritization techniques in particular and testing techniques in general","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Regression testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Regression testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case prioritization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case prioritization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.program mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">program mutation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.empirical studies..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">empirical studies.</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Mutation-driven generation of unit tests and oracles,ieeexplore,Mutation-driven generation of unit tests and oracles,"Fraser, Gordon, and Andreas Zeller",246," <i>IEEE Transactions on Software Engineering</i> 38, no. 2 (2012): 278-292.","To assess the quality of test suites, mutation analysis seeds artificial defects (mutations) into programs; a nondetected mutation indicates a weakness in the test suite. We present an automated approach to generate unit tests that detect these mutations for object-oriented classes. This has two advantages: First, the resulting test suite is optimized toward finding defects modeled by mutation operators rather than covering code. Second, the state change caused by mutations induces oracles that precisely detect the mutants. Evaluated on 10 open source libraries, our μtest prototype generates test suites that find significantly more seeded defects than the original manually written test suites.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.search-based testing..QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">search-based testing.</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test case generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test case generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test oracles.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test oracles</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.assertions.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">assertions</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Achieving scalable mutation-based generation of whole test suites,Springer,Achieving scalable mutation-based generation of whole test suites,"Fraser, Gordon, and Andrea Arcuri",34," <i>Empirical Software Engineering</i> 20, no. 3 (2015): 783-812.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Without complete formal specification, automatically generated software tests need to be manually checked in order to detect faults. This makes it desirable to produce the strongest possible test set while keeping the number of tests as small as possible. As commonly applied coverage criteria like branch coverage are potentially weak, mutation testing has been proposed as a stronger criterion. However, mutation based test generation is hampered because usually there are simply too many mutants, and too many of these are either trivially killed or equivalent. On such mutants, any effort spent on test generation would per definition be wasted. To overcome this problem, our search-based E<span class=""EmphasisTypeSmallCaps "">vo</span>S<span class=""EmphasisTypeSmallCaps "">uite</span> test generation tool integrates two novel optimizations: First, we avoid redundant test executions on mutants by monitoring state infection conditions, and second we use whole test suite generation to optimize test suites towards killing the highest number of mutants, rather than selecting individual mutants. These optimizations allowed us to apply E<span class=""EmphasisTypeSmallCaps "">vo</span>S<span class=""EmphasisTypeSmallCaps "">uite</span> to a random sample of 100 open source projects, consisting of a total of 8,963 classes and more than two million lines of code, leading to a total of 1,380,302 mutants. The experiment demonstrates that our approach scales well, making mutation testing a viable test criterion for automated test case generation tools, and allowing us to analyze the relationship of branch coverage and mutation testing in detail.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Test case generation&nbsp;</span><span class=""Keyword"">Search-based testing&nbsp;</span><span class=""Keyword"">Testing classes&nbsp;</span><span class=""Keyword"">Unit testing&nbsp;</span>"
Strong higher order mutation-based test data generation,acm,Strong higher order mutation-based test data generation,"Harman, Mark, Yue Jia, and William B. Langdon",103," In <i>Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering</i>, pp. 212-222. ACM, 2011.","This paper introduces SHOM, a mutation-based test data generation approach that combines Dynamic Symbolic Execution and Search Based Software Testing. SHOM targets strong mutation adequacy and is capable of killing both first and higher order mutants. We report the results of an empirical study using 17 programs, including production industrial code from ABB and Daimler and open source code as well as previously studied subjects. SHOM achieved higher strong mutation adequacy than two recent mutation-based test data generation approaches, killing between 8% and 38% of those mutants left unkilled by the best performing previous approach.",mutation testing; test data generation
Analysing the effectiveness of rule-coverage as a reduction criterion for test suites of grammar-based software,Springer,Analysing the effectiveness of rule-coverage as a reduction criterion for test suites of grammar-based software,"Hennessy, Mark, and James F. Power",13," <i>Empirical Software Engineering</i> 13, no. 4 (2008): 343-368.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">The term <em class=""EmphasisTypeItalic "">grammar-based software</em> describes software whose input can be specified by a context-free grammar. This grammar may occur explicitly in the software, in the form of an input specification to a parser generator, or implicitly, in the form of a hand-written parser. Grammar-based software includes not only programming language compilers, but also tools for program analysis, reverse engineering, software metrics and documentation generation. Hence, ensuring their completeness and correctness is a vital prerequisite for their use. In this paper we propose a strategy for the construction of test suites for grammar based software, and illustrate this strategy using the ISO C<sup> + + </sup> grammar. We use the concept of grammar-rule coverage as a pivot for the reduction of an implementation-based test suite, and demonstrate a significant decrease in the size of this suite. The effectiveness of this reduced test suite is compared to the original test suite with respect to code coverage and more importantly, fault detection. This work greatly expands upon previous work in this area and utilises large scale mutation testing to compare the effectiveness of grammar-rule coverage to that of statement coverage as a reduction criterion for test suites of grammar-based software. This work finds that when grammar rule coverage is used as the sole criterion for reducing test suites of grammar based software, the fault detection capability of that reduced test suite is greatly diminished when compared to other coverage criteria such as statement coverage.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Software testing&nbsp;</span><span class=""Keyword"">Grammar-based software&nbsp;</span><span class=""Keyword"">Test suite reduction&nbsp;</span><span class=""Keyword"">Rule coverage&nbsp;</span><span class=""Keyword"">Mutation testing&nbsp;</span>"
Applying interface-contract mutation in regression testing of component-based software,ieeexplore,Applying interface-contract mutation in regression testing of component-based software,"Hou, Shan-Shan, Lu Zhang, Tao Xie, Hong Mei, and Jia-Su Sun",21," In <i>Software Maintenance, 2007. ICSM 2007. IEEE International Conference on</i>, pp. 174-183. IEEE, 2007.","Regression testing, which plays an important role in software maintenance, usually relies on test adequacy criteria to select and prioritize test cases. However, with the wide use and reuse of black-box components, such as reusable class libraries and COTS components, it is challenging to establish test adequacy criteria for testing software systems built on components whose source code is not available. Without source code or detailed documents, the misunderstanding between the system integrators and component providers has become a main factor of causing faults in component-based software. In this paper, we apply mutation on interface contracts, which can describe the rights and obligations between component users and providers, to simulate the faults that may occur in this way of software development. The mutation adequacy score for killing the mutants of interface contracts can serve as a test adequacy criterion. We performed an experimental study on three subject systems to evaluate the proposed approach together with four other existing criteria. The experimental results show that our adequacy criterion is helpful for both selecting good-quality test cases and scheduling test cases in an order of exposing faults quickly in regression testing of component-based software.",
Using machine learning techniques to detect metamorphic relations for programs without test oracles,ieeexplore,Using machine learning techniques to detect metamorphic relations for programs without test oracles,"Kanewala, Upulee, and James M. Bieman",21," In <i>Software Reliability Engineering (ISSRE), 2013 IEEE 24th International Symposium on</i>, pp. 1-10. IEEE, 2013.","Much software lacks test oracles, which limits automated testing. Metamorphic testing is one proposed method for automating the testing process for programs without test oracles. Unfortunately, finding the appropriate metamorphic relations required for use in metamorphic testing remains a labor intensive task, which is generally performed by a domain expert or a programmer. In this work we present a novel approach for automatically predicting metamorphic relations using machine learning techniques. Our approach uses a set of features developed using the control flow graph of a function for predicting likely metamorphic relations. We show the effectiveness of our method using a set of real world functions often used in scientific applications.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Support vector machines.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Support vector machines</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Metamorphic testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Metamorphic testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Metamorphic relation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Metamorphic relation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Machine learning.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Machine learning</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Scientific software testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Scientific software testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Test oracles.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Test oracles</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Decision trees.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Decision trees</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Investigating the effectiveness of object-oriented testing strategies using the mutation method,Wiley Online Library,Investigating the effectiveness of object‐oriented testing strategies using the mutation method,"Kim, Sun‐Woo, John A. Clark, and John A. McDermid",86," <i>Software Testing, Verification and Reliability</i> 11, no. 4 (2001): 207-225.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>The mutation method assesses test quality by examining the ability of a test set to distinguish syntactic deviations representing specific types of faults from the program under test. This paper describes an empirical study performed to evaluate the effectiveness of object-oriented (OO) test strategies using the mutation method. The test sets for the experimental system are generated according to three selected OO test strategies and their effectiveness is compared by determining how well the developed test sets kill injected mutants derived from an established mutation system Mothra and the authors' own OO-specific mutation technique which is termed Class Mutation. Copyright © 2001 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">object-oriented testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Java; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Class Mutation</span></li>"
Generating test cases for XML-based Web component interactions using mutation analysis,ieeexplore,Generating test cases for XML-based Web component interactions using mutation analysis,"Lee, Suet Chun, and Jeff Offutt",95," In <i>Software Reliability Engineering, 2001. ISSRE 2001. Proceedings. 12th International Symposium on</i>, pp. 200-209. IEEE, 2001.","Web software systems are built using heterogeneous software components. They interact by passing messages that exchange data and activity state information. Such heterogeneous message transfers can be structured using the eXtensible Markup Language (XML), which allows a flexible common data exchange. Parsers have been developed to check the syntax of component interactions, but there are as yet no techniques for checking the semantic correctness of the interactions. The paper presents a technique for using mutation analysis to test the semantic correctness of XML-based component interactions. The Web software interactions are specified using an Interaction Specification Model (ISM) that consists of document type definitions, messaging specifications, and a set of constraints. Test cases are XML messages that are passed between the Web software components. Classes of interaction-specific mutation operators are introduced and applied to the ISM to generate mutant interactions and test cases.",
An approach to test data generation for killing multiple mutants,ieeexplore,An approach to test data generation for killing multiple mutants,"Liu, Ming-Hao, You-Feng Gao, Jin-Hui Shan, Jiang-Hong Liu, Lu Zhang, and Jia-Su Sun",27," In <i>Software Maintenance, 2006. ICSM'06. 22nd IEEE International Conference on</i>, pp. 113-122. IEEE, 2006.","Software testing is an important technique for assurance of software quality. Mutation testing has been identified as a powerful fault-based technique for unit testing, and there has been some research on automatic generation of test data for mutation testing. However, existing approaches to this kind of test data generation usually generate test data according to one mutant at one time. Thus, more test data that are needed for achieving a given mutation score. In this paper, we propose a new approach to generating one test data according to multiple mutants that are mutated at the same location at one time. Thus, our approach can generate smaller test suite that can achieve the same mutation testing score. To evaluate our approach, we implemented a prototype tool based on our approach and carried out some preliminary experiments. The experimental results show that our approach is more cost-effective","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.adequacy criterion.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">adequacy criterion</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.unit testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">unit testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test data.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test data</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">generation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Model-Based Mutation Testing of Synchronous and Asynchronous Real-Time Systems,ieeexplore,Model-Based Mutation Testing of Synchronous and Asynchronous Real-Time Systems,"Lorber, Florian",1," In <i>Software Testing, Verification and Validation (ICST), 2015 IEEE 8th International Conference on</i>, pp. 1-2. IEEE, 2015.","A lot of systems nowadays, especially in safety-critical areas, have to comply to very strict real-time requirements. Deviation from the specified time behavior can lead to severe faults. Thus the components need to be thoroughly tested to ensure a high quality standard. Model-based testing is a popular technology for automatic and systematic test-case generation, where a system-under-test is tested for conformance with a model that specifies its intended behavior. Model-based mutation testing is a specific fault-oriented variant of model- based testing. In this variant of testing, the test case generation is guided by a mutant, an intentionally altered version of the original model that specifies a common modeling error, to generate a specific test case capable of identifying that error. In the presented thesis we investigate ways to apply model-based mutation testing to real-time applications. The plan is to investigate two specification languages: timed automata and timed contracts. We already developed an algorithm and an implementation for testing deterministic timed automata and a theory and implementation for untimed contracts. In the last year of the thesis we will concentrate on determinizing timed automata restricted to the bounded case, supporting the test-case generation from networks of timed automata and adding real-time support to our contract-based testing tool. The final step of the thesis will be the evaluation on industrial case studies.",
Mutation-based test-case prioritization in software evolution,ieeexplore,Mutation-based test-case prioritization in software evolution,"Lou, Yiling, Dan Hao, and Lu Zhang",6," In <i>Software Reliability Engineering (ISSRE), 2015 IEEE 26th International Symposium on</i>, pp. 46-57. IEEE, 2015.","During software evolution, to assure the software quality, test cases for an early version tend to be reused by its latter versions. As a large number of test cases may aggregate during software evolution, it becomes necessary to schedule the execution order of test cases so that the faults in the latter version may be detected as early as possible, which is test-case prioritization in software evolution. In this paper, we proposed a novel test-case prioritization approach for software evolution, which first uses mutation faults on the difference between the early version and the latter version to simulate real faults occurred in software evolution, and then schedules the execution order of test cases based on their fault-detection capability, which is defined based on mutation faults. In particular, we present two models on calculating fault-detection capability, which are statistics-based model and probability-based model. Moreover, we conducted an experimental study and found that our approach with the statistics-based model outperforms our approach with the probability-based model and the total statement coverage-based approach, and slightly outperforms the additional statement-coverage based approach in many cases. Furthermore, compared with the total or additional statement coverage-based approach, our approach with either the statistics-based model or the probability-based model tends to be stably effective when the difference on the source code between the early version and the latter version is non-trivial.",
Effective test generation and adequacy assessment for JavaScript-based web applications,acm,Effective test generation and adequacy assessment for JavaScript-based web applications,"Mirshokraie, Shabnam",2," In <i>Proceedings of the 2014 International Symposium on Software Testing and Analysis</i>, pp. 453-456. ACM, 2014.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> Modern web applications rely heavily on JavaScript and client-side runtime manipulation of the DOM (Document Object Model) tree. However, JavaScript is loosely typed, dynamic, and challenging to analyze and test. We propose an automated technique to generate regression test cases at two complementary levels: (1) individual JavaScript functions, and (2) DOM event sequences. Moreover, to assess the quality of the test cases we propose a mutation testing technique that leverages static and dynamic program analysis to guide the mutation generation process towards parts of the code that are error-prone or likely to influence the program's output. </p></div> 
            

            </div>
          ",JavaScript; Mutation Testing; Test generation
Ask the mutants: Mutating faulty programs for fault localization,ieeexplore,Ask the mutants: Mutating faulty programs for fault localization,"Moon, Seokhyeon, Yunho Kim, Moonzoo Kim, and Shin Yoo",33," In <i>Software Testing, Verification and Validation (ICST), 2014 IEEE Seventh International Conference on</i>, pp. 153-162. IEEE, 2014.","We present MUSE (MUtation-baSEd fault localization technique), a new fault localization technique based on mutation analysis. A key idea of MUSE is to identify a faulty statement by utilizing different characteristics of two groups of mutants-one that mutates a faulty statement and the other that mutates a correct statement. We also propose a new evaluation metric for fault localization techniques based on information theory, called Locality Information Loss (LIL): it can measure the aptitude of a localization technique for automated fault repair systems as well as human debuggers. The empirical evaluation using 14 faulty versions of the five real-world programs shows that MUSE localizes a fault after reviewing 7.4 statements on average, which is about 25 times more precise than the state-of-the-art SBFL technique Op2.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.fault localization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">fault localization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Static analysis of model transformations for effective test generation,ieeexplore,Static analysis of model transformations for effective test generation,"Mottu, Jean-Marie, Sagar Sen, Massimo Tisi, and Jordi Cabot",23," In <i>Software Reliability Engineering (ISSRE), 2012 IEEE 23rd International Symposium on</i>, pp. 291-300. IEEE, 2012.","Model transformations are an integral part of several computing systems that manipulate interconnected graphs of objects called models in an input domain specified by a metamodel and a set of invariants. Test models are used to look for faults in a transformation. A test model contains a specific set of objects, their interconnections and values for their attributes. Can we automatically generate an effective set of test models using knowledge from the transformation? We present a white-box testing approach that uses static analysis to guide the automatic generation of test inputs for transformations. Our static analysis uncovers knowledge about how the input model elements are accessed by transformation operations. This information is called the input metamodel footprint due to the transformation. We transform footprint, input metamodel, its invariants, and transformation pre-conditions to a constraint satisfaction problem in Alloy. We solve the problem to generate sets of test models containing traces of the footprint. Are these test models effective? With the help of a case study transformation we evaluate the effectiveness of these test inputs. We use mutation analysis to show that the test models generated from footprints are more effective (97.62% avg. mutation score) in detecting faults than previously developed approaches based on input domain coverage criteria (89.9% avg.) and unguided generation (70.1% avg.).","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.White Box Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">White Box Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-Driven Engineering.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-Driven Engineering</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model Transformation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model Transformation Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Alloy.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Alloy</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Automatic Model Completion.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Automatic Model Completion</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Automatic mutation test case generation via dynamic symbolic execution,ieeexplore,Automatic mutation test case generation via dynamic symbolic execution,"Papadakis, Mike, and Nicos Malevris",71," In <i>Software reliability engineering (ISSRE), 2010 IEEE 21st international symposium on</i>, pp. 121-130. IEEE, 2010.","The automatic test case generation is the principal issue of the software testing activity. Dynamic symbolic execution appears to be a promising approach to this matter as it has been shown to be quite powerful in producing the sought tests. Despite its power, it has only been effectively applied to the entry level criteria of the structural criteria hierarchy such as branch testing. In this paper an extension of this technique is proposed in order to effectively generate test data based on mutation testing. The proposed approach conjoins program transformation and dynamic symbolic execution techniques in order to successfully automate the test generation process. The propositions made in this paper have been incorporated into an automated framework for producing mutation based test cases. Its evaluation on a set of benchmark programs suggests that it is able to produce tests capable of killing most of the non equivalent introduced mutants. The same study also provides some evidence that by employing efficient heuristics it can be possible to perform mutation with reasonable resources.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutant schemata.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutant schemata</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.automated test case generation.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">automated test case generation</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.dynamic symbolic execution.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">dynamic symbolic execution</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
"Automatically performing weak mutation with the aid of symbolic execution, concolic testing and search-based testing",Springer,"Automatically Performing Weak Mutation with the Aid of: Symbolic Execution, Concolic and Search Based Testing1","Papadakis, Mike, and Nicos Malevris",33,,"<h2 class=""Heading"">Abstract</h2><p class=""Para"">Automating software testing activities can increase the quality and drastically decrease the cost of software development. Toward this direction, various automated test data generation tools have been developed. The majority of existing tools aim at structural testing, while a quite limited number aim at a higher level of testing thoroughness such as mutation. In this paper, an attempt toward automating the generation of mutation-based test cases by utilizing existing automated tools is proposed. This is achieved by reducing the killing mutants’ problem into a covering branches one. To this extent, this paper is motivated by the use of state of the art techniques and tools suitable for covering program branches when performing mutation. Tools and techniques such as symbolic execution, concolic execution, and evolutionary testing can be easily adopted toward automating the test input generation activity for the weak mutation testing criterion by simply utilizing a special form of the mutant schemata technique. The propositions made in this paper integrate three automated tools in order to illustrate and examine the method’s feasibility and effectiveness. The obtained results, based on a set of Java program units, indicate the applicability and effectiveness of the suggested technique. The results advocate that the proposed approach is able to guide existing automating tools in producing test cases according to the weak mutation testing criterion. Additionally, experimental results with the proposed mutation testing regime show that weak mutation is able to speedup the mutant execution time by at least 4.79 times when compared with strong mutation.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Weak mutation&nbsp;</span><span class=""Keyword"">Automated test case generation&nbsp;</span><span class=""Keyword"">Mutant schemata&nbsp;</span><span class=""Keyword"">Symbolic execution&nbsp;</span><span class=""Keyword"">Concolic execution&nbsp;</span><span class=""Keyword"">Search-based testing&nbsp;</span>"
Mutation based test case generation via a path selection strategy,Elsevier,Mutation based test case generation via a path selection strategy,"Papadakis, Mike, and Nicos Malevris",43," <i>Information and Software Technology</i> 54, no. 9 (2012): 915-932.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><h4 id=""absSec_1"">Context</h4><p id=""sp005"">Generally, mutation analysis has been identified as a powerful testing method. Researchers have shown that its use as a testing criterion exercises quite thoroughly the system under test while it achieves to reveal more faults than standard structural testing criteria. Despite its potential, mutation fails to be adopted in a widespread practical use and its popularity falls significantly short when compared with other structural methods. This can be attributed to the lack of thorough studies dealing with the practical problems introduced by mutation and the assessment of the effort needed when applying it. Such an incident, masks the real cost involved preventing the development of easy and effective to use strategies to circumvent this problem.</p><h4 id=""absSec_2"">Objective</h4><p id=""sp010"">In this paper, a path selection strategy for selecting test cases able to effectively kill mutants when performing weak mutation testing is presented and analysed.</p><h4 id=""absSec_3"">Method</h4><p id=""sp015"">The testing effort is highly correlated with the number of attempts the tester makes in order to generate adequate test cases. Therefore, a significant influence on the efficiency associated with a test case generation strategy greatly depends on the number of candidate paths selected in order to achieve a predefined coverage goal. The effort can thus be related to the number of infeasible paths encountered during the test case generation process.</p><h4 id=""absSec_4"">Results</h4><p id=""sp020"">An experiment, investigating well over 55 million of program paths is conducted based on a strategy that alleviates the effects of infeasible paths. Strategy details, along with a prototype implementation are reported and analysed through the experimental results obtained by its employment to a set of program units.</p><h4 id=""absSec_5"">Conclusion</h4><p id=""sp025"">The results obtained suggest that the strategy used can play an important role in making the mutation testing method more appealing and practical.</p>","<li id="""" class=""svKeywords""><span id="""">Software testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Unit testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Path testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Adequacy criterion</span>; </li><li id="""" class=""svKeywords""><span id="""">Infeasible paths</span></li>"
"Using mutants to locate ""unknown"" faults",ieeexplore,Using mutants to locat,"Papadakis, Mike, and Yves Le Traon",32, unknown,"Many fault localization techniques operate by crosscutting coverage information of passed and failed test executions. Generally, their accuracy depends on the utilized coverage elements and on the selected test cases. This paper proposes a novel fault localization method using mutation and investigates its accuracy when using classical test selection criteria such as mutation, branch and block. A controlled experiment shows that (1) the mutation based approach is quite effective at identifying ""unknown"" faulty program statements. Additionally, the experimental results reveal (2) that the mutation-based test suites are significantly more effective at supporting fault localization than block or branch-based test suites. Further, (3) evidence in support of facilitating mutation alternatives, such as mutant sampling, in order to diminish mutation overheads is also given.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.fault localization.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">fault localization</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.debugging.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">debugging</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation analysis</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Sampling program inputs with mutation analysis: Going beyond combinatorial interaction testing,ieeexplore,Sampling program inputs with mutation analysis: Going beyond combinatorial interaction testing,"Papadakis, Mike, Christopher Henard, and Yves Le Traon",18," In <i>Software Testing, Verification and Validation (ICST), 2014 IEEE Seventh International Conference on</i>, pp. 1-10. IEEE, 2014.","Modern systems tend to be highly configurable. Testing such systems requires selecting test cases from a large input space. Thus, there is a need to systematically sample program inputs in order to reduce the testing effort. In such cases, testing the interactions between program parameters has been identified as an effective way to deal with this problem. In these lines, Combinatorial Interaction Testing (CIT) models the program input interactions and uses this model to select test cases. Going a step further, we apply mutation analysis on the CIT input model to select program test cases. Mutation operates by injecting defects to the program input model and measures the number of defects found by the selected test cases. Experiments performed on four real programs show that measuring the number of model-based defects gives a stronger correlation to code-level faults than measuring the number of the exercised interactions. Therefore, the proposed mutation analysis approach forms a valid and more effective alternative to CIT.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Fault Detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Fault Detection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Combinatorial Interaction Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Combinatorial Interaction Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Metallaxis-FL: mutation-based fault localization,Wiley Online Library,Metallaxis‐FL: mutation‐based fault localization,"Papadakis, Mike, and Yves Le Traon",38," <i>Software Testing, Verification and Reliability</i> 25, no. 5-7 (2015): 605-628.","Fault localization methods seek to identify faulty program statements based on the information provided by the failing and passing test executions. Spectrum-based methods are among the most popular ones and assist programmers by assigning suspiciousness values on program statements according to their probability of being faulty. This paper proposes Metallaxis, a fault localization approach based on mutation analysis. The innovative part of Metallaxis is that it uses mutants and links them with the faulty program places. Thus, mutants that are killed mostly by failing tests provide a good indication about the location of a fault. Experimentation using Metallaxis suggests that it is significantly more effective than statement-based approaches. This is true even in the case where mutation cost-reduction techniques, such as mutant sampling, are facilitated. Additionally, results from a controlled experiment show that the use of mutation as a testing technique provides benefits to the fault localization process. Therefore, fault localization is significantly improved by using mutation-based tests instead of block-based or branch-based test suites. Finally, evidence in support of the methods’ scalability is also given.","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">debugging; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation analysis; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">fault localization</span></li>"
Model-based tests for access control policies,ieeexplore,Model-based tests for access control policies,"Pretschner, Alexander, Tejeddine Mouelhi, and Yves Le Traon",71," In <i>Software Testing, Verification, and Validation, 2008 1st International Conference on</i>, pp. 338-347. IEEE, 2008.","We present a model-based approach to testing access control requirements. By using combinatorial testing, we first automatically generate test cases from and without access control policies—i.e., the model—and assess the effectiveness of the test suites by means of mutation testing. We also compare them to purely random tests. For some of the investigated strategies, non-random tests kill considerably more mutants thanthe same number of random tests. Since we rely on policies only, no information on the application is required at this stage. As a consequence, our methodology applies to arbitrary implementations of the policy decision points.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Combinatorial Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Combinatorial Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Access Control.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Access Control</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model-Based Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model-Based Testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Testing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Assessing oracle quality with checked coverage,ieeexplore,Assessing oracle quality with checked coverage,"Schuler, David, and Andreas Zeller",34," In <i>Software Testing, Verification and Validation (ICST), 2011 IEEE Fourth International Conference on</i>, pp. 90-99. IEEE, 2011.","A known problem of traditional coverage metrics is that they do not assess oracle quality - that is, whether the computation result is actually checked against expectations. In this paper, we introduce the concept of checked coverage - the dynamic slice of covered statements that actually influence an oracle. Our experiments on seven open-source projects show that checked coverage is a sure indicator for oracle quality - and even more sensitive than mutation testing, its much more demanding alternative.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation testing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation testing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.test suite quality.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">test suite quality</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.coverage metrics.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">coverage metrics</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.dynamic slicing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">dynamic slicing</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Checked coverage: an indicator for oracle quality,Wiley Online Library,Checked coverage: an indicator for oracle quality,"Schuler, David, and Andreas Zeller",11," <i>Software Testing, Verification and Reliability</i> 23, no. 7 (2013): 531-551.","<div class=""article-section__content mainAbstract""><h2 class=""article-section__header"">SUMMARY</h2><p>A known problem of traditional coverage metrics is that they do not assess <em>oracle quality</em>—that is, whether the computation result is actually checked against expectations. In this paper, we introduce the concept of <em>checked coverage</em>—the dynamic slice of covered statements that actually influence an oracle. Our experiments on seven open-source projects show that checked coverage is a sure indicator for oracle quality and even more sensitive than mutation testing. Copyright © 2013 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test suite quality; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">coverage metrics; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">dynamic slicing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing</span></li>"
Artificial neural networks as multi-networks automated test oracle,Springer,Artificial neural networks as multi-networks automated test oracle,"Shahamiri, Seyed Reza, Wan MN Wan-Kadir, Suhaimi Ibrahim, and Siti Zaiton Mohd Hashim",15," <i>Automated Software Engineering</i> 19, no. 3 (2012): 303-334.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">One of the important issues in software testing is to provide an automated test oracle. Test oracles are reliable sources of how the software under test must operate. In particular, they are used to evaluate the actual results produced by the software. However, in order to generate an automated test oracle, it is necessary to map the input domain to the output domain automatically. In this paper, Multi-Networks Oracles based on Artificial Neural Networks are introduced to handle the mapping automatically. They are an enhanced version of previous ANN-Based Oracles. The proposed model was evaluated by a framework provided by mutation testing and applied to test two industry-sized case studies. In particular, a mutated version of each case study was provided and injected with some faults. Then, a fault-free version of it was developed as a Golden Version to evaluate the capability of the proposed oracle finding the injected faults. Meanwhile, the quality of the proposed oracle is measured by assessing its accuracy, precision, misclassification error and recall. Furthermore, the results of the proposed oracle are compared with former ANN-based Oracles. Accuracy of the proposed oracle was up to 98.93%, and the oracle detected up to 98% of the injected faults. The results of the study show the proposed oracle has better quality and applicability than the previous model.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Automated software testing&nbsp;</span><span class=""Keyword"">Software test oracle&nbsp;</span><span class=""Keyword"">Artificial neural networks&nbsp;</span><span class=""Keyword"">Mutation testing&nbsp;</span>"
On guiding the augmentation of an automated test suite via mutation analysis,Springer,On guiding the augmentation of an automated test suite via mutation analysis,"Smith, Ben H., and Laurie Williams",39," <i>Empirical Software Engineering</i> 14, no. 3 (2009): 341-369.","<h2 class=""Heading"">Abstract</h2><p class=""Para"">Mutation testing has traditionally been used as a defect injection technique to assess the effectiveness of a test suite as represented by a “mutation score.” Recently, mutation testing tools have become more efficient, and industrial usage of mutation analysis is experiencing growth. Mutation analysis entails adding or modifying test cases until the test suite is sufficient to detect as many mutants as possible and the mutation score is satisfactory. The augmented test suite resulting from mutation analysis may reveal latent faults and provides a stronger test suite to detect future errors which might be injected. Software engineers often look for guidance on how to augment their test suite using information provided by line and/or branch coverage tools. As the use of mutation analysis grows, software engineers will want to know how the emerging technique compares with and/or complements coverage analysis for guiding the augmentation of an automated test suite. Additionally, software engineers can benefit from an enhanced understanding of efficient mutation analysis techniques. To address these needs for additional information about mutation analysis, we conducted an empirical study of the use of mutation analysis on two open source projects. Our results indicate that a focused effort on increasing mutation score leads to a corresponding increase in line and branch coverage to the point that line coverage, branch coverage and mutation score reach a maximum but leave some types of code structures uncovered. Mutation analysis guides the creation of additional “common programmer error” tests beyond those written to increase line and branch coverage. We also found that 74% of our chosen set of mutation operators is useful, on average, for producing new tests. The remaining 26% of mutation operators did not produce new test cases because their mutants were immediately detected by the initial test suite, indirectly detected by test suites we added to detect other mutants, or were not able to be detected by any test.</p>","<h3 class=""Heading"">Keywords</h3><span class=""Keyword"">Mutation testing&nbsp;</span><span class=""Keyword"">Line coverage&nbsp;</span><span class=""Keyword"">Fault injection&nbsp;</span><span class=""Keyword"">Empirical effectiveness&nbsp;</span><span class=""Keyword"">Test case augmentation&nbsp;</span><span class=""Keyword"">Mutation analysis&nbsp;</span><span class=""Keyword"">Mutation testing tool&nbsp;</span><span class=""Keyword"">Statement coverage&nbsp;</span><span class=""Keyword"">Test adequacy&nbsp;</span><span class=""Keyword"">Web application&nbsp;</span><span class=""Keyword"">Open source&nbsp;</span><span class=""Keyword"">Unit testing&nbsp;</span>"
Should software testers use mutation analysis to augment a test set?,Elsevier,Should software testers use mutation analysis to augment a test set?,"Smith, Ben H., and Laurie Williams",25," <i>Journal of Systems and Software</i> 82, no. 11 (2009): 1819-1832.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Mutation testing has historically been used to assess the fault-finding effectiveness of a test suite or other verification technique. Mutation analysis, rather, entails augmenting a test suite to detect all killable mutants. Concerns about the time efficiency of mutation analysis may prohibit its widespread, practical use. <em>The goal of our research is to assess the effectiveness of the mutation analysis process when used by software testers to augment a test suite to obtain higher statement coverage scores.</em> We conducted two empirical studies and have shown that mutation analysis can be used by software testers to effectively produce new test cases and to improve statement coverage scores in a feasible amount of time. Additionally, we find that our user study participants view mutation analysis as an effective but relatively expensive technique for writing new test cases. Finally, we have shown that the choice of mutation tool and operator set can play an important role in determining how efficient mutation analysis is for producing new test cases.</p>","<li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Empirical effectiveness</span>; </li><li id="""" class=""svKeywords""><span id="""">User study</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation analysis</span>; </li><li id="""" class=""svKeywords""><span id="""">Test adequacy</span>; </li><li id="""" class=""svKeywords""><span id="""">Web application</span>; </li><li id="""" class=""svKeywords""><span id="""">Open source</span>; </li><li id="""" class=""svKeywords""><span id="""">Unit testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing tool</span></li>"
"Automated oracle creation support, or: how I learned to stop worrying about fault propagation and love mutation testing",acm,"Automated oracle creation support, or: how I learned to stop worrying about fault propagation and love mutation testing","Staats, Matt, Gregory Gay, and Mats PE Heimdahl",49," In <i>Proceedings of the 34th International Conference on Software Engineering</i>, pp. 870-880. IEEE Press, 2012.","
<div style=""margin-left:10px; margin-top:10px; margin-right:10px; margin-bottom: 10px;"" class=""tabbody"">

             <div style=""display:inline""><p> In testing, the test oracle is the artifact that determines whether an application under test executes correctly. The choice of test oracle can significantly impact the effectiveness of the testing process. However, despite the prevalence of tools that support the selection of test inputs, little work exists for supporting oracle creation. In this work, we propose a method of supporting test oracle creation. This method automatically selects the oracle data â the set of variables monitored during testingâfor expected value test oracles. This approach is based on the use of mutation analysis to rank variables in terms of fault-finding effectiveness, thus automating the selection of the oracle data. Experiments over four industrial examples demonstrate that our method may be a cost-effective approach for producing small, effective oracle data, with fault finding improvements over current industrial best practice of up to 145.8% observed. </p></div> 
            

            </div>
          ",
Model Clone Detector Evaluation Using Mutation Analysis,ieeexplore,Model clone detector evaluation using mutation analysis,"Stephan, Matthew",5," In <i>Software Maintenance and Evolution (ICSME), 2014 IEEE International Conference on</i>, pp. 633-638. IEEE, 2014.","Model Clone Detection is a growing area within the field of software model maintenance. New model clone detection techniques and tools for different types of models are being created, however, there is no clear way of objectively and quantitatively evaluating and comparing them. In this paper, we provide a synopsis of our work in devising and validating an evaluation framework that uses Mutation Analysis to provide such a facility. In order to demonstrate the framework's feasibility and also walk through its steps, we implement a framework implementation for evaluating Simulink model clone detectors. This includes a taxonomy of Simulink mutations, Simulink clone report transformations, and more. We outline how the framework calculates precision and recall, and do so on multiple Simulink model clone detectors. In addition, we also discuss areas of future work, including semantic clone mutations, and developing framework implementations for other model types, like UML. Lastly, we address some lessons we learned during the Ph.D. Process, such as partitioning the work into logical, self-contained, milestones, and being open and willing to engage in other research. We hope that our framework will help cultivate further research gains in Model Clone Detection.","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Simulink.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Simulink</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Model Clone Detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Model Clone Detection</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Mutation Analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Mutation Analysis</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.Clone Detection.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">Clone Detection</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Constraint based structural testing criteria,Elsevier,Constraint based structural testing criteria,"Vergilio, Silvia Regina, José Carlos Maldonado, Mario Jino, and Inali Wisniewski Soares",15," <i>Journal of Systems and Software</i> 79, no. 6 (2006): 756-771.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Structural criteria generally divide the input domain of the program under test and require the execution of at least one point from each derived sub-domain without addressing the most relevant question: “Which points from each sub-domain should be selected?”. This question is related to data-sensitive faults which lead to one of the drawbacks of the testing activity. The constraints and conditions used by fault-based data generation techniques describe faults related to the boundaries of these sub-domains. Our conjecture is that we would improve the efficacy of the adequate test case sets by associating those constraints and conditions to the elements required by a criterion. With this goal, this work presents Constraint Based Criteria (CBC) that associate a constraint <em>C</em> to an element <em>E</em>, required by a structural criterion. CBC allow to combine the fundamentals of different testing generation techniques with structural testing, increasing the probability of revealing faults described by <em>C</em>. We also discuss complexity, inclusion relation and automation aspects of CBC. Results from three experiments of CBC evaluation using the factors cost, efficacy and strength provide evidence that our objectives have been achieved. We also present some results from the evaluation of random test sets.</p>","<li id="""" class=""svKeywords""><span id="""">Data flow based criteria</span>; </li><li id="""" class=""svKeywords""><span id="""">Constraint based testing</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation analysis</span></li>"
Correlating context-awareness and mutation analysis for pervasive computing systems,ieeexplore,Correlating context-awareness and mutation analysis for pervasive computing systems,"Wang, Huai, Ke Zhai, and T. H. Tse",6," In <i>Quality Software (QSIC), 2010 10th International Conference on</i>, pp. 151-160. IEEE, 2010.","Pervasive computing systems often use middleware as a means to communicate with the changing environment. However, the interactions with the context-aware middleware as well as the interactions among applications sharing the same middleware may introduce faults that are difficult to reveal by existing testing techniques. Our previous work proposed the notion of context diversity as a metric to measure the degree of changes in test inputs for pervasive software. In this paper, we present a case study on how much context diversity for test cases relates to fault-based mutants in pervasive software. Our empirical results show that conventional mutation operators can generate sufficient candidate mutants to support test effectiveness evaluation of pervasive software, and test cases with higher context diversity values tend to have higher mean mutation scores. On the other hand, for test cases sharing the same context diversity, their mutation scores can vary significantly in terms of standard derivations","
<strong class=""ng-binding"">Author Keywords </strong>
<div>
<!-- ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.pervasive computing.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">pervasive computing</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.context diversity.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">context diversity</a>, 
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index --><span ng-repeat=""term in ::keyword.kwd track by $index"" class=""ng-binding ng-scope"">
<a href=""/search/searchresult.jsp?matchBoolean=true&amp;queryText=&quot;Index%20Terms&quot;:.QT.mutation analysis.QT.&amp;newsearch=true"" ng-bind-html=""::term"" data-tealium_data=""{&quot;keywordType&quot;: &quot;Author Keywords &quot;}"" class=""ng-binding"">mutation analysis</a>
</span><!-- end ngRepeat: term in ::keyword.kwd track by $index -->
</div>
"
Effective test case selection for component customization and its application to Enterprise JavaBeans,Wiley Online Library,Effective test case selection for component customization and its application to Enterprise JavaBeans,"Yoon, Hoijin, and Byoungju Choi",11," <i>Software Testing, Verification and Reliability</i> 14, no. 1 (2004): 45-70.","Component users need to customize components they obtain from providers, because providers usually develop components for general use. Although the customization is accomplished by modifying the interface of a component, faults from customization appear when the implementation part of a component and the interfaces interact. The implementation part is a black-box, whose source code is not available to a component user, while the interface is a white-box, whose source code is available for customization. Therefore, customization faults should be tested using both the black-box part and the white-box part of a component. This paper proposes a new technique to test customization faults using software fault injection and mutation testing, and the technique is tailored to Enterprise JavaBeans. Test cases are selected by injecting faults not into the entire interface but into specific parts of the component's interface. The specific parts that are chosen control the effectiveness of the test cases. An empirical study to evaluate the technique is reported. ","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">test case effectiveness; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">component-based software development; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">composition; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Enterprise JavaBeans</span></li>"
A search-based framework for automatic testing of MATLAB/Simulink models,Elsevier,A search-based framework for automatic testing of MATLAB/Simulink models,"Zhan, Yuan, and John A. Clark",44," <i>Journal of Systems and Software</i> 81, no. 2 (2008): 262-285.","<h2 class=""secHeading"" id=""author1"">Abstract</h2><p id="""">Search-based test-data generation has proved successful for code-level testing but almost no search-based work has been carried out at higher levels of abstraction. In this paper the application of such approaches at the higher levels of abstraction offered by <em>MATLAB/Simulink</em> models is investigated and a wide-ranging framework for test-data generation and management is presented. Model-level analogues of code-level structural coverage criteria are presented and search-based approaches to achieving them are described. The paper also describes the first search-based approach to the generation of mutant-killing test data, addressing a fundamental limitation of mutation testing. Some problems remain whatever the level of abstraction considered. In particular, complexity introduced by the presence of persistent state when generating test sequences is as much a challenge at the <em>Simulink</em> model level as it has been found to be at the code level. The framework addresses this problem. Finally, a flexible approach to test sub-set extraction is presented, allowing testing resources to be deployed effectively and efficiently.</p>","<li id="""" class=""svKeywords""><span id=""""><em>MATLAB/Simulink</em></span>; </li><li id="""" class=""svKeywords""><span id="""">Test-data generation</span>; </li><li id="""" class=""svKeywords""><span id="""">Automation</span>; </li><li id="""" class=""svKeywords""><span id="""">Structural coverage</span>; </li><li id="""" class=""svKeywords""><span id="""">Mutation testing</span>; </li><li id="""" class=""svKeywords""><span id="""">State problem</span>; </li><li id="""" class=""svKeywords""><span id="""">Tracing and deducing</span>; </li><li id="""" class=""svKeywords""><span id="""">Test-set reduction</span></li>"
Test generation via dynamic symbolic execution for mutation testing,ieeexplore,Test generation via dynamic symbolic execution for mutation testing,"Zhang, Lingming, Tao Xie, Lu Zhang, Nikolai Tillmann, Jonathan De Halleux, and Hong Mei",67," In <i>Software Maintenance (ICSM), 2010 IEEE International Conference on</i>, pp. 1-10. IEEE, 2010.","Mutation testing has been used to assess and improve the quality of test inputs. Generating test inputs to achieve high mutant-killing ratios is important in mutation testing. However, existing test-generation techniques do not provide effective support for killing mutants in mutation testing. In this paper, we propose a general test-generation approach, called PexMutator, for mutation testing using Dynamic Symbolic Execution (DSE), a recent effective test-generation technique. Based on a set of transformation rules, PexMutator transforms a program under test to an instrumented meta-program that contains mutant-killing constraints. Then PexMutator uses DSE to generate test inputs for the meta-program. The mutant-killing constraints introduced via instrumentation guide DSE to generate test inputs to kill mutants automatically. We have implemented our approach as an extension for Pex, an automatic structural testing tool developed at Microsoft Research. Our preliminary experimental study shows that our approach is able to strongly kill more than 80% of all the mutants for the five studied subjects. In addition, PexMutator is able to outperform Pex, a state-of-the-art test-generation tool, in terms of strong mutant killing while achieving the same block coverage.",
JDAMA: Java database application mutation analyser,Wiley Online Library,JDAMA: Java database application mutation analyser,"Zhou, Chixiang, and Phyllis Frankl",20," <i>Software Testing, Verification and Reliability</i> 21, no. 3 (2011): 241-263.","<div id=""en_main_abstract"" class=""article-section__content mainAbstract"" lang=""en""><h2 class=""article-section__header"">Abstract</h2><p>Database application programs are ubiquitous; hence, good techniques for testing them are needed. Several approaches to testing database applications have been proposed recently, including test generation techniques and adequacy criteria. Tuya <em>et al.</em> proposed mutation-based adequacy criteria for database queries and developed a set of mutation operators for Structured Query Language <span class=""monospace "">SELECT</span> statements. This paper extends that approach by integrating it with analysis and instrumentation of the application bytecode. The design and implementation of a tool, Java Database Application Mutation Analyser (JDAMA), are described. JDAMA instruments application bytecode so as to compare the results of queries executed by the application under test to the results of mutants of those queries. JDAMA can be used to support mutation testing for Java database applications. A second, potentially more useful application of JDAMA is to support experiments evaluating testing techniques for database applications, in which query mutation is used to seed faults into subject applications. The paper illustrates these uses of JDAMA with experiments comparing two approaches to test generation and experiments evaluating coverage criteria. Copyright © 2011 John Wiley &amp; Sons, Ltd.</p></div>","<li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">software testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">database application testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">mutation testing; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">empirical evaluation; </span></li><li class=""article-info__keywords-item""><span class=""article-info__keywords-data"">Java</span></li>"
